# FinTrack – Pre-Accounting Backend for SMBs - Complete Documentation

> Fintrack is a pre-accounting backend system designed for small and medium-sized businesses. It provides a scalable REST API and an extensible data model for users, customers, suppliers, products or services, invoices, payments, and expenses. The platform supports core financial reporting, with all data isolated per business and ready for frontend or mobile app integration.

This document contains the full documentation for all services in the FinTrack – Pre-Accounting Backend for SMBs project. It is designed for comprehensive reference by both humans and AI agents.

---

## Table of Contents

### Getting Started
- [Introduction](#intro)

### Frontend Prompts
- [Authentication Management](#frontend-prompts-frontend-prompt-1-authmanagement)
- [Verification Management](#frontend-prompts-frontend-prompt-2-verification)
- [Profile Management](#frontend-prompts-frontend-prompt-3-profile)
- [User Management](#frontend-prompts-frontend-prompt-4-usermanagement)
- [CustomerManagement Service](#frontend-prompts-frontend-prompt-5-customermanagementservice)
- [ExpenseManagement Service](#frontend-prompts-frontend-prompt-6-expensemanagementservice)
- [InvoiceManagement Service](#frontend-prompts-frontend-prompt-7-invoicemanagementservice)
- [PaymentManagement Service](#frontend-prompts-frontend-prompt-8-paymentmanagementservice)
- [ProductCatalog Service](#frontend-prompts-frontend-prompt-9-productcatalogservice)
- [SupplierManagement Service](#frontend-prompts-frontend-prompt-10-suppliermanagementservice)

### CustomerManagement Service
- [Service Design](#customermanagement-service-service-design)
- [REST API Guide](#customermanagement-service-rest-api-guide)
- [Event Guide](#customermanagement-service-event-guide)
- **Data Objects**
  - [customer Design](#customermanagement-service-customer-design)
- **Business APIs**
  - [createCustomer API](#customermanagement-service-business-api-createcustomer-api-design)
  - [deleteCustomer API](#customermanagement-service-business-api-deletecustomer-api-design)
  - [getCustomer API](#customermanagement-service-business-api-getcustomer-api-design)
  - [listCustomers API](#customermanagement-service-business-api-listcustomers-api-design)
  - [updateCustomer API](#customermanagement-service-business-api-updatecustomer-api-design)
  - [_fetchListCustomer API](#customermanagement-service-business-api--fetchlistcustomer-api-design)

### ExpenseManagement Service
- [Service Design](#expensemanagement-service-service-design)
- [REST API Guide](#expensemanagement-service-rest-api-guide)
- [Event Guide](#expensemanagement-service-event-guide)
- **Data Objects**
  - [expense Design](#expensemanagement-service-expense-design)
- **Business APIs**
  - [createExpense API](#expensemanagement-service-business-api-createexpense-api-design)
  - [deleteExpense API](#expensemanagement-service-business-api-deleteexpense-api-design)
  - [getExpense API](#expensemanagement-service-business-api-getexpense-api-design)
  - [listExpenses API](#expensemanagement-service-business-api-listexpenses-api-design)
  - [updateExpense API](#expensemanagement-service-business-api-updateexpense-api-design)
  - [_fetchListExpense API](#expensemanagement-service-business-api--fetchlistexpense-api-design)

### InvoiceManagement Service
- [Service Design](#invoicemanagement-service-service-design)
- [REST API Guide](#invoicemanagement-service-rest-api-guide)
- [Event Guide](#invoicemanagement-service-event-guide)
- **Data Objects**
  - [invoice Design](#invoicemanagement-service-invoice-design)
  - [invoiceItem Design](#invoicemanagement-service-invoiceitem-design)
- **Business APIs**
  - [createInvoice API](#invoicemanagement-service-business-api-createinvoice-api-design)
  - [createInvoiceItem API](#invoicemanagement-service-business-api-createinvoiceitem-api-design)
  - [deleteInvoice API](#invoicemanagement-service-business-api-deleteinvoice-api-design)
  - [deleteInvoiceItem API](#invoicemanagement-service-business-api-deleteinvoiceitem-api-design)
  - [getInvoice API](#invoicemanagement-service-business-api-getinvoice-api-design)
  - [getInvoiceItem API](#invoicemanagement-service-business-api-getinvoiceitem-api-design)
  - [listInvoiceItems API](#invoicemanagement-service-business-api-listinvoiceitems-api-design)
  - [listInvoices API](#invoicemanagement-service-business-api-listinvoices-api-design)
  - [updateInvoice API](#invoicemanagement-service-business-api-updateinvoice-api-design)
  - [updateInvoiceItem API](#invoicemanagement-service-business-api-updateinvoiceitem-api-design)
  - [_fetchListInvoice API](#invoicemanagement-service-business-api--fetchlistinvoice-api-design)
  - [_fetchListInvoiceItem API](#invoicemanagement-service-business-api--fetchlistinvoiceitem-api-design)

### PaymentManagement Service
- [Service Design](#paymentmanagement-service-service-design)
- [REST API Guide](#paymentmanagement-service-rest-api-guide)
- [Event Guide](#paymentmanagement-service-event-guide)
- **Data Objects**
  - [payment Design](#paymentmanagement-service-payment-design)
- **Business APIs**
  - [createPayment API](#paymentmanagement-service-business-api-createpayment-api-design)
  - [deletePayment API](#paymentmanagement-service-business-api-deletepayment-api-design)
  - [getPayment API](#paymentmanagement-service-business-api-getpayment-api-design)
  - [listPayments API](#paymentmanagement-service-business-api-listpayments-api-design)
  - [updatePayment API](#paymentmanagement-service-business-api-updatepayment-api-design)

### ProductCatalog Service
- [Service Design](#productcatalog-service-service-design)
- [REST API Guide](#productcatalog-service-rest-api-guide)
- [Event Guide](#productcatalog-service-event-guide)
- **Data Objects**
  - [productOrService Design](#productcatalog-service-productorservice-design)
- **Business APIs**
  - [createProductOrService API](#productcatalog-service-business-api-createproductorservice-api-design)
  - [deleteProductOrService API](#productcatalog-service-business-api-deleteproductorservice-api-design)
  - [getProductOrService API](#productcatalog-service-business-api-getproductorservice-api-design)
  - [listProductOrServices API](#productcatalog-service-business-api-listproductorservices-api-design)
  - [updateProductOrService API](#productcatalog-service-business-api-updateproductorservice-api-design)
  - [_fetchListProductOrService API](#productcatalog-service-business-api--fetchlistproductorservice-api-design)

### SupplierManagement Service
- [Service Design](#suppliermanagement-service-service-design)
- [REST API Guide](#suppliermanagement-service-rest-api-guide)
- [Event Guide](#suppliermanagement-service-event-guide)
- **Data Objects**
  - [supplier Design](#suppliermanagement-service-supplier-design)
- **Business APIs**
  - [createSupplier API](#suppliermanagement-service-business-api-createsupplier-api-design)
  - [deleteSupplier API](#suppliermanagement-service-business-api-deletesupplier-api-design)
  - [getSupplier API](#suppliermanagement-service-business-api-getsupplier-api-design)
  - [listSuppliers API](#suppliermanagement-service-business-api-listsuppliers-api-design)
  - [updateSupplier API](#suppliermanagement-service-business-api-updatesupplier-api-design)
  - [_fetchListSupplier API](#suppliermanagement-service-business-api--fetchlistsupplier-api-design)

### Auth Service
- [Service Design](#auth-service-service-design)
- [REST API Guide](#auth-service-rest-api-guide)
- [Event Guide](#auth-service-event-guide)
- **Data Objects**
  - [user Design](#auth-service-user-design)
  - [business Design](#auth-service-business-design)
- **Business APIs**
  - [getUser API](#auth-service-business-api-getuser-api-design)
  - [updateUser API](#auth-service-business-api-updateuser-api-design)
  - [updateProfile API](#auth-service-business-api-updateprofile-api-design)
  - [createUser API](#auth-service-business-api-createuser-api-design)
  - [deleteUser API](#auth-service-business-api-deleteuser-api-design)
  - [archiveProfile API](#auth-service-business-api-archiveprofile-api-design)
  - [listUsers API](#auth-service-business-api-listusers-api-design)
  - [searchUsers API](#auth-service-business-api-searchusers-api-design)
  - [updateUserRole API](#auth-service-business-api-updateuserrole-api-design)
  - [updateUserPassword API](#auth-service-business-api-updateuserpassword-api-design)
  - [updateUserPasswordByAdmin API](#auth-service-business-api-updateuserpasswordbyadmin-api-design)
  - [getBriefUser API](#auth-service-business-api-getbriefuser-api-design)
  - [registerBusinessOwner API](#auth-service-business-api-registerbusinessowner-api-design)
  - [registerBusinessUser API](#auth-service-business-api-registerbusinessuser-api-design)
  - [createBusiness API](#auth-service-business-api-createbusiness-api-design)
  - [getBusiness API](#auth-service-business-api-getbusiness-api-design)
  - [getBusinessByCodename API](#auth-service-business-api-getbusinessbycodename-api-design)
  - [listRegisteredBusinesses API](#auth-service-business-api-listregisteredbusinesses-api-design)
  - [listBriefBusinesses API](#auth-service-business-api-listbriefbusinesses-api-design)
  - [getBriefBusiness API](#auth-service-business-api-getbriefbusiness-api-design)
  - [updateBusiness API](#auth-service-business-api-updatebusiness-api-design)
  - [deleteBusiness API](#auth-service-business-api-deletebusiness-api-design)
  - [_fetchListBusiness API](#auth-service-business-api--fetchlistbusiness-api-design)

### Bff Service
- [Service Design](#bff-service-service-design)
- [REST API Guide](#bff-service-rest-api-guide)
- [Event Guide](#bff-service-event-guide)

### Notification Service
- [Service Design](#notification-service-service-design)
- [REST API Guide](#notification-service-rest-api-guide)
- [Event Guide](#notification-service-event-guide)

### LLM Documents
- [Documentation Index](#llm-llms)
- [Complete Documentation](#llm-llms-full)
- [REST API Reference](#llm-llms-restapi)
- [Frontend Prompts](#llm-llms-prompts)


---

# Getting Started

<a id="intro"></a>

## FinTrack – Pre-Accounting Backend for SMBs


# FinTrack – Pre-Accounting Backend for SMBs
Version : 1.0.12

Fintrack is a pre-accounting backend system designed for small and medium-sized businesses. It provides a scalable REST API and an extensible data model for users, customers, suppliers, products or services, invoices, payments, and expenses. The platform supports core financial reporting, with all data isolated per business and ready for frontend or mobile app integration.

## How to Use Project Documents

The `Fintrack` project has been designed and generated using **Mindbricks**, a powerful microservice-based backend generation platform. All documentation is automatically produced by the **Mindbricks Genesis Engine**, based on the high-level architectural patterns defined by the user or inferred by AI.

This documentation set is intended for both **AI agents** and **human developers**—including frontend and backend engineers—who need precise and structured information about how to interact with the backend services of this project. Each document reflects the live architecture of the system, providing a reliable reference for API consumption, data models, authentication flows, and business logic.

By following this documentation, developers can seamlessly integrate with the backend, while AI agents can use it to reason about the service structure, make accurate decisions, or even generate compatible client-side code.

## Accessing Project Services

Each service generated by Mindbricks is exposed via a **dedicated REST API** endpoint. Every service documentation set includes the **base URL** of that service along with the **specific API paths** for each available route.

Before consuming any API, developers or agents must understand the service URL structure and environment-specific endpoints.

### Service Endpoint Structure

| Environment | URL Pattern Example |
|-------------|---------------------|
| **Preview** | `https://fintrack.prw.mindbricks.com/auth-api` |
| **Staging** | `https://fintrack-stage.mindbricks.co/auth-api` |
| **Production** | `https://fintrack.mindbricks.co/auth-api` |


Replace `auth` with the actual service name as lower case (e.g., `order-api`, `bff-service`, customermanagement-api etc.).

### Environment Usage Notes

* **Preview APIs** become accessible after a project is previewed inside the Mindbricks platform. These are ideal for development and testing.
* **Staging** and **Production** APIs are only accessible after the project is deployed to cloud environments provisioned via Mindbricks.
* In some cases, the project owner may choose to deploy services on their **own infrastructure**. In such scenarios, the service base URLs will be **custom** and should be communicated manually by the project owner to developers or AI agents.

> **Frontend applications** should be designed to **easily switch between environments**, allowing dynamic endpoint targeting for Preview, Staging, and Production.

## Getting Started: Use the Auth Service First

Before interacting with other services in the `Fintrack` project, **AI agents and developers should begin by integrating with the Auth Service**.

Mindbricks automatically generates a dedicated authentication microservice based on the project’s authentication definitions provided by the architect. This service provides the essential user and access management foundation for the project.

Agents should first utilize the Auth Service to:

* Register and authenticate users (login)
* Manage users, roles, and permissions
* Handle user groups (if defined)
* Support multi-tenancy logic (if configured)
* Perform Policy-Based Access Control (PBAC), if activated by the architect

### Auth Service Documentation

Use the following resources to understand and integrate the Auth Service:

* **REST API Guide** – ideal for frontend and direct HTTP usage  
  [Auth REST API Guide](docs/auth-service/rest-api-guide.html)

* **Event Guide** – helpful for event-driven or cross-service integrations  
  [Auth Event Guide](docs/auth-service/event-guide.html)

* **Service Design Document** – overall structure, patterns, and logic  
  [Auth Service Design](docs/auth-service/service-design.html)

> **Note:** For most frontend use cases, the **REST API Guide** will be the primary source. The **Event Guide** and **Service Design** documents are especially useful when integrating with other backend microservices or building systems that interact with the auth service indirectly.

## Using the BFF (Backend-for-Frontend) Service

In Mindbricks, all backend services are designed with an advanced **CQRS (Command Query Responsibility Segregation)** architecture. Within this architecture, **business services** are responsible for managing their respective domains and ensuring the accuracy and freshness of domain data.

The **BFF service** complements these business services by providing a **read-only** aggregation and query layer tailored specifically for frontend and client-side applications.

### Key Principles of the BFF Service

* **Elasticsearch Replicas for Fast Queries:**  
  Each data object managed by a business service is automatically replicated as an **Elasticsearch index**, making it accessible for fast, frontend-oriented queries through the BFF.

* **Cross-Service Data Aggregation:**  
  The BFF offers an **aggregation layer** capable of combining data across multiple services, enabling complex filters, searches, and unified views of related data.

* **Read-Only by Design:**  
  The BFF service is **strictly read-only**. All create, update, or delete operations must be performed through the relevant business services, or via event-driven sagas if designed.

### BFF Service Documentation

* **REST API Guide** – querying aggregated and indexed data  
  [BFF REST API Guide](docs/bff-service/rest-api-guide.html)

* **Event Guide** – syncing strategies across replicas  
  [BFF Event Guide](docs/bff-service/event-guide.html)

* **Service Design** – aggregation patterns and index structures  
  [BFF Service Design](docs/bff-service/service-design.html)

> **Tip:** Use the BFF service as the **main entry point for all frontend data queries**. It simplifies access, reduces round-trips, and ensures that data is shaped appropriately for the UI layer.

## Business Services Overview

The `FinTrack – Pre-Accounting Backend for SMBs` project consists of multiple **business services**, each responsible for managing a specific domain within the system. These services expose their own REST APIs and documentation sets, and are accessible based on the environment (Preview, Staging, Production).

### Usage Guidance

Business services are primarily designed to:

* Handle the **state and operations of domain data**
* Offer **Create, Update, Delete** operations over owned entities
* Serve **direct data queries** (`get`, `list`) for their own objects when needed

For advanced query needs across multiple services or aggregated views, prefer using the [BFF service](#using-the-bff-backend-for-frontend-service).

### Available Business Services


### customerManagement Service

**Description:** Handles all business-specific customer CRUD operations and exposes customer data for sales invoice and reporting workflows. Ensures strict tenant (business) isolation for all customer records and supports role-based access control per business context.

**Documentation:**

* [REST API Guide](docs/customerManagement-service/rest-api-guide.html)
* [Event Guide](docs/customerManagement-service/event-guide.html)
* [Service Design](docs/customerManagement-service/service-design.html)

**Base URL Examples:**

| Environment | URL |
|-------------|---------------------|
| **Preview** | `https://fintrack.prw.mindbricks.com/customermanagement-api` |
| **Staging** | `https://fintrack-stage.mindbricks.co/customermanagement-api` |
| **Production** | `https://fintrack.mindbricks.co/customermanagement-api` |


### expenseManagement Service

**Description:** Handles CRUD for general business expenses (not tied to invoices), enforcing per-business tenant isolation, enabling categorization and supporting future reporting/analytics. Part of the FinTrack financial management backend.

**Documentation:**

* [REST API Guide](docs/expenseManagement-service/rest-api-guide.html)
* [Event Guide](docs/expenseManagement-service/event-guide.html)
* [Service Design](docs/expenseManagement-service/service-design.html)

**Base URL Examples:**

| Environment | URL |
|-------------|---------------------|
| **Preview** | `https://fintrack.prw.mindbricks.com/expensemanagement-api` |
| **Staging** | `https://fintrack-stage.mindbricks.co/expensemanagement-api` |
| **Production** | `https://fintrack.mindbricks.co/expensemanagement-api` |


### invoiceManagement Service

**Description:** Handles creation and modification of all sales (outgoing) and purchase (incoming) invoices for FinTrack SMBs. Supports multi-item entry per invoice, VAT at item level, detailed filtering, and status calculation based on payments and due dates. Strictly scoped to a single business context.

**Documentation:**

* [REST API Guide](docs/invoiceManagement-service/rest-api-guide.html)
* [Event Guide](docs/invoiceManagement-service/event-guide.html)
* [Service Design](docs/invoiceManagement-service/service-design.html)

**Base URL Examples:**

| Environment | URL |
|-------------|---------------------|
| **Preview** | `https://fintrack.prw.mindbricks.com/invoicemanagement-api` |
| **Staging** | `https://fintrack-stage.mindbricks.co/invoicemanagement-api` |
| **Production** | `https://fintrack.mindbricks.co/invoicemanagement-api` |


### paymentManagement Service

**Description:** Handles recording and lifecycle management of payments for invoices or as general/unallocated entries. Ensures invoice payment state is synchronized after each payment operation, supports strict business (tenant) isolation, and underpins core financial workflows in FinTrack.

**Documentation:**

* [REST API Guide](docs/paymentManagement-service/rest-api-guide.html)
* [Event Guide](docs/paymentManagement-service/event-guide.html)
* [Service Design](docs/paymentManagement-service/service-design.html)

**Base URL Examples:**

| Environment | URL |
|-------------|---------------------|
| **Preview** | `https://fintrack.prw.mindbricks.com/paymentmanagement-api` |
| **Staging** | `https://fintrack-stage.mindbricks.co/paymentmanagement-api` |
| **Production** | `https://fintrack.mindbricks.co/paymentmanagement-api` |


### productCatalog Service

**Description:** Handles CRUD operations for products and services offered by the business. Makes products/services available for invoice itemization and supports future extensions (e.g., category, inventory, VAT config).

**Documentation:**

* [REST API Guide](docs/productCatalog-service/rest-api-guide.html)
* [Event Guide](docs/productCatalog-service/event-guide.html)
* [Service Design](docs/productCatalog-service/service-design.html)

**Base URL Examples:**

| Environment | URL |
|-------------|---------------------|
| **Preview** | `https://fintrack.prw.mindbricks.com/productcatalog-api` |
| **Staging** | `https://fintrack-stage.mindbricks.co/productcatalog-api` |
| **Production** | `https://fintrack.mindbricks.co/productcatalog-api` |


### supplierManagement Service

**Description:** Handles all business-specific supplier CRUD operations and exposes supplier data for invoice and reporting workflows. Ensures strict tenant (business) isolation for all supplier records and supports all roles per business context.

**Documentation:**

* [REST API Guide](docs/supplierManagement-service/rest-api-guide.html)
* [Event Guide](docs/supplierManagement-service/event-guide.html)
* [Service Design](docs/supplierManagement-service/service-design.html)

**Base URL Examples:**

| Environment | URL |
|-------------|---------------------|
| **Preview** | `https://fintrack.prw.mindbricks.com/suppliermanagement-api` |
| **Staging** | `https://fintrack-stage.mindbricks.co/suppliermanagement-api` |
| **Production** | `https://fintrack.mindbricks.co/suppliermanagement-api` |


## Conclusion

This documentation set provides a comprehensive guide for understanding and consuming the `FinTrack – Pre-Accounting Backend for SMBs` backend, generated by the Mindbricks platform. It is structured to support both AI agents and human developers in navigating authentication, data access, service responsibilities, and system architecture.

To summarize:

* Start with the **Auth Service** to manage users, roles, sessions, and permissions.
* Use the **BFF Service** for optimized, read-only data queries and cross-service aggregation.
* Refer to the **Business Services** when you need to manage domain-specific data or perform direct CRUD operations.

Each service offers a complete set of documentation—REST API guides, event interface definitions, and design insights—to help you integrate efficiently and confidently.

Whether you are building a frontend application, configuring an automation agent, or simply exploring the architecture, this documentation is your primary reference for working with the backend of this project.

> For environment-specific access, ensure you're using the correct base URLs (Preview, Staging, Production), and coordinate with the project owner for any custom deployments.


---

# Frontend Prompts

<a id="frontend-prompts-frontend-prompt-1-authmanagement"></a>

## Authentication Management



# **FINTRACK**

**FRONTEND GUIDE FOR AI CODING AGENTS - PART 1 - Authentication Management**

This document is the first part of a REST API guide for the fintrack project.
It is designed for AI agents that will generate frontend code to consume the project’s backend.

This first document includes general information about the project and its authentication management. Please read it carefully and implement all requirements described here.

The project has 1 auth service, 1 notification service, 1 BFF service, and 6 business services, plus other helper services such as bucket and realtime. In this document you will be informed only about the auth service. The initial frontend will be generated to use this service.

Each service is a separate microservice application and listens for HTTP requests at different service URLs.

Services may be deployed to the preview server, staging server, or production server. Therefore, each service has 3 access URLs.
The frontend application must support all deployment environments during development, and the user should be able to select the target API server on the home page.

## Project Introduction

Fintrack is a pre-accounting backend system designed for small and medium-sized businesses. It provides a scalable REST API and an extensible data model for users, customers, suppliers, products or services, invoices, payments, and expenses. The platform supports core financial reporting, with all data isolated per business and ready for frontend or mobile app integration.


## API Structure

### Object Structure of a Successful Response

When the service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope includes the data and essential metadata such as configuration details and pagination information, providing context to the client.

**HTTP Status Codes:**

* **200 OK**: Returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request was processed successfully.
* **201 Created**: Returned for CREATE operations, indicating that the resource was created successfully.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling that the request executed successfully. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3,
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
```

* **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation.

### Additional Data

Each API may include additional data besides the main data object, depending on the business logic of the API. These will be provided in each API’s response signature.

### Error Response

If a request encounters an issue—whether due to a logical fault or a technical problem—the service responds with a standardized JSON error structure. The HTTP status code indicates the nature of the error, using commonly recognized codes for clarity:

* **400 Bad Request**: The request was improperly formatted or contained invalid parameters.
* **401 Unauthorized**: The request lacked a valid authentication token; login is required.
* **403 Forbidden**: The current token does not grant access to the requested resource.
* **404 Not Found**: The requested resource was not found on the server.
* **500 Internal Server Error**: The server encountered an unexpected condition.

Each error response is structured to provide meaningful insight into the problem, assisting in efficient diagnosis and resolution.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```

## Accessing the backend

Each backend service has its own URL for each deployment environment. Users may want to test the frontend in one of the three deployments—preview, staging, or production. Please ensure that the home page includes a deployment server selection option so that, as the frontend coding agent, you can set the base URL for all services.

The base URL of the application in each environment is as follows:

* **Preview:** `https://fintrack.prw.mindbricks.com`
* **Staging:** `https://fintrack-stage.mindbricks.co`
* **Production:** `https://fintrack.mindbricks.co`

For the auth service, the base URLs are:

* **Preview:** `https://fintrack.prw.mindbricks.com/auth-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/auth-api`
* **Production:** `https://fintrack.mindbricks.co/auth-api`

For each other service, the service base URL will be given in the service sections.

Any request that requires login must include a valid token in the Bearer authorization header.

Please note that for each service in the project (which will be introduced in following pages) will use a different address so it is a good practice to define a separate client for each service in the frontend application lib source. Not only the different base urls, some services even may need different access rules when shaping the request. 


## Multi-Tenancy Management

**THIS APPLICATION IS MULTI-TENANT**

This application is mult-tanant, it means; as a SaaS application, it isolates each tenant-data from each other. The tenants are called `business` and a data object with the same name exist to store and manage the tenant information. The `business` data instances are referenced from other data objects or entities as `businessId`. Any data object which is in tenant level (some data objects may still stay in SaaS level) has a `businessId` property which attaches it to a `business` tenant. But this value is added to the data object instance in the time of creation by the system according to the current `business` user is navigating. 

For the human readability each `business` has also got a `businessCodename` which is a unique form of its name. Any api call to the application should claim its target `business` tenant, so it should provide `businessCodename` parameter at one of the following request locations.

```js
// In header with special header name
headers["mbx-business-codename"] = "babil",

// or in query with ( _business ) parameter

const url = `${serviceUrl}/v1/users/${userId}?_business=babil`

// or in post body with ( _business ) parameter
const body = {
  //...
  _business: "babil",
  //...
}
```

When no `businessCodename` is given in the related parameters, application will assume that the access targets the root target, the Saas level. The `businessCodename` of SaaS level is always `root`. When no `businessCodename` is specified, `root` is assumed as the current `businessCodename`.

Note that, logins and registrations are all tenant scoped. If any a tenant-lvel api is login-required then it will check for a `business` specific token according to the target `business` defined in a related parameter with its codename. The application creates the cookies with `businessCodename` prefixes but it is recommended for the frontend application to populate the bearer header with the user's `business` related token.

Not that all `business` tenants are managed in the same backend services, however a `business` tanant frontend should be specific to one `business`. Frontend should have a technical way to understand which `business` is targeted by the user, for production frontend application this should be managed by the subdomains that represents the codename of the business like,

````
https://babil.storeCreator.com
````

Using the subdomain, frontend will distinguish that the codename is `babil` and will atatch it to all tenant-level api calls.

The url may also be used for the SaaS directly with a more general wording like,

````
https://www.storeCreator.com
````

However, this subdomain management may not be handled easily in the AI frontend builders that they use their own preview urls, an other url structure should be handled to simulate the subdomain behaviour for tenant forwarding.

It may be like,

````
https://{somePreviewUrlOfABuilderPlatform}/babil/login
````

In some way, frontend should provide a simple and practical way to the user to target a specific tenant.

### Sample Business Tenant

The applcation backend also includes a sample tenant created with a sample tenant owner, who has the same email and password of the superadmin. This sample is created in the backend to be able to test the multi-tenant behaviour of the frontend at the beginning.

The sample business has a codename `babil` and can be targetd by attaching this codename to the API calls. So whwn the front end home page is built, homepages both for the SaaS and tenant shoul be created and ready to be tested.


## Home page

First build a home page which shows some static content about the application, and has got login and registration (if is public) buttons. The home page shpuld be updated later according to the content that each service provides, as a frontend developer use best and common practices to reflect the service content to the home page. User may also give extra information for the home page content in addtion to this prompt.

Note that this page should include a deployment (environment) selection option to set the base URL. Set the default to `production`.

After user logs in, page header should show the current login state as in modern web pages, logged in user fullname, avatar, email and with a logout link, make a fancy current user component. The home page may have different views before and after login.


Since this application is a multi-tenant application, the SaaS homepage and `Business` homepages will be different. 
The SaaS home page will include a saas login link for the saas admins and users to login, and a **create business** link that tenant owners can register themselves with their `business` tenant data.

This tenant home page will also include the current user component in its header after login.

Most importantly in the development phase, the SaasHome page will also serve as a gateway to the tenant homepages. For this there is a public api which can be called before login to get a list of the `business` tenants with brief information.

Use the following  `listBriefBusinesses` api, and show the list of these tenants in the homepage and arrange their links to go to the  `business`  tenant homepage. The `business` tenant homepage will serve as the store front of the tenant, and it will include links to login or register to the `business` tenant. Once navigation have been transferred to a tenant, the frontend code should always obey the rule of sending the `business codename` in the related header when making a call to the backend.


### `List Briefbusinesses` API
Get a list of businesses, this route can be called by public, no login required


**Rest Route**

The `listBriefBusinesses` API REST controller can be triggered via the following route:

`/v1/briefbusinesses`


**Rest Request Parameters**
The `listBriefBusinesses` api has got no request parameters.    



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/briefbusinesses**
```js
  axios({
    method: 'GET',
    url: '/v1/briefbusinesses',
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "businesses",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"businesses": [
		{
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```




## Registration Management


Since the application is multi-tenant, there will be two registration process. First one is the `business` register and the other one is `user` registration.

Users are either in SaaS level, like administrators, or in `business` tenant level like `business` owners, admins and users.

### SaaS Level User Registration

SaaS user registration is not public in the application, SaaS users can only be created through `createUser` api which can be called by the `superAdmin` or `saasAdmin` of the SaaS level. Creating a new SaaS user is handled through admin panel which will be described in the next prompt.

SaaS users will belong to the `root` tenant and they will be able to see and manage root level data that all tenants use in common. SaaS users should login to the application with claiming their tenant codenames as `root` or none.

### Tenant -`business`- Registration

Tenant registraration, creating a new business, is always handled together with tenant owner registration.

Tenant and tenant owner registration are not public in the application, so creating a new business with its owner user is handled through admin panel which will be describe in the next prompt.

### Tenant -`business`- User Registration

This application doesn't allow public user registration for business tenants, so skip a public registration page. Users will be created only in the admin business panel which will be described in the next prompt. Start with a home page and set up the login  and verification  flow. 


## Login Management

After successful registration and completing any required verifications, the user can log in. Please create a minimal, polished login page where the user can enter email and password. Note that this page should respect the deployment (environment) selection option made in the home page to set the base URL. If the user reaches this page directly skipping home page, the default `production`deployment will be used.

The login API returns a created session. This session can be retrieved later with the access token using the `/currentuser` system route.

Any request that requires login must include a valid token. When a user logs in successfully, the response JSON includes a JWT access token in the `accessToken` field. Under normal conditions, this token is also set as a cookie and consumed automatically. However, since AI coding agents’ preview options may fail to use cookies, ensure that each request includes the access token in the Bearer authorization header.

If the login fails due to verification requirements, the response JSON includes an `errCode`. If it is `EmailVerificationNeeded`, start the email verification flow; if it is `MobileVerificationNeeded`, start the mobile verification flow.

After a successful login, you can access session (user) information at any time with the `/currentuser` API. On inner pages, show brief profile information (avatar, name, etc.) using the session information from this API.

Note that the `currentuser` API returns a session object, so there is no `id` property; instead, the values for the user and session are exposed as `userId` and `sessionId`. The response combines user and session information.

The login, logout, and currentuser APIs are as follows. They are system routes and are not versioned.

### `POST /login` — User Login

**Purpose:**
Verifies user credentials and creates an authenticated session with a JWT access token.

**Access Routes:**

#### Request Parameters

| Parameter  | Type   | Required | Source                  |
| ---------- | ------ | -------- | ----------------------- |
| `username` | String | Yes      | `request.body.username` |
| `password` | String | Yes      | `request.body.password` |

#### Behavior

* Authenticates credentials and returns a session object.
* Sets cookie: `projectname-access-token[-tenantCodename]`
* Adds the same token in response headers.
* Accepts either `username` or `email` fields (if both exist, `username` is prioritized).

#### Example

```js
axios.post("/login", {
  username: "user@example.com",
  password: "securePassword"
});
```

#### Success Response

```json
{
  "sessionId": "e81c7d2b-4e95-9b1e-842e-3fb9c8c1df38",
  "userId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  "email": "user@example.com",
  "fullname": "John Doe",
  //...
  "accessToken": "ey7....",
  "userBucketToken": "e56d...."
}
```

### Error Responses

* `401 Unauthorized`: Invalid credentials
* `403 Forbidden`: Email/mobile verification or 2FA pending
* `400 Bad Request`: Missing parameters

---

### `POST /logout` — User Logout

**Purpose:**
Terminates the current session and clears associated authentication tokens.

#### Behavior

* Invalidates the session (if it exists).
* Clears cookie `projectname-access-token[-tenantCodename]`.
* Returns a confirmation response (always `200 OK`).

#### Example

```js
axios.post("/logout", {}, {
  headers: { "Authorization": "Bearer your-jwt-token" }
});
```

#### Notes

* Can be called without a session (idempotent behavior).
* Works for both cookie-based and token-based sessions.

#### Success Response

```json
{ "status": "OK", "message": "User logged out successfully" }
```

### `GET /currentuser` — Current Session

**Purpose**
Returns the currently authenticated user’s session.

**Route Type**
`sessionInfo`

**Authentication**
Requires a valid access token (header or cookie).

#### Request

*No parameters.*

#### Example

```js
axios.get("/currentuser", {
  headers: { Authorization: "Bearer <jwt>" }
});
```

#### Success (200)

Returns the session object (identity, tenancy, token metadata):

```json
{
  "sessionId": "9cf23fa8-07d4-4e7c-80a6-ec6d6ac96bb9",
  "userId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  "email": "user@example.com",
  "fullname": "John Doe",
  "roleId": "user",
  "tenantId": "abc123",
  "accessToken": "jwt-token-string",
  "...": "..."
}
```

Note that the `currentuser` API returns a session object, so there is no `id` property, instead, the values for the user and session are exposed as `userId` and `sessionId`. The response is a mix of user and session information.

#### Errors

* **401 Unauthorized** — No active session/token

  ```json
  { "status": "ERR", "message": "No login found" }
  ```

**Notes**

* Commonly called by web/mobile clients after login to hydrate session state.
* Includes key identity/tenant fields and a token reference (if applicable).
* Ensure a valid token is supplied to receive a 200 response.


After you complete this first step, please ensure you have not made the following common mistakes:

1. When the application starts, please ensure that the `baseUrl` is set to the production server URL, and that the environment selector dropdown has the **Production** option selected by default.
2. Note that any api call to the application backend is based on a service base url, in this propmpt all auth apis should be called by `/auth-api` prefix after application's base url.
3. The `/currentuser` API returns a mix of session and user data. There is no `id` property —use `userId` and `sessionId`.
4. Please note that, the deployemnt environment selector will only be used in the home page. If any page is called directly bypassign home page, the page will use the stored or default environment.

**After this prompt, the user may give you new instructions to update your first output or provide subsequent prompts about the project.**

---

<a id="frontend-prompts-frontend-prompt-2-verification"></a>

## Verification Management



# **FINTRACK**

**FRONTEND GUIDE FOR AI CODING AGENTS - PART 2 - Verification Management**

This document is a part of a REST API guide for the fintrack project.
It is designed for AI agents that will generate frontend code to consume the project’s backend.

This document includes the verification processes for the autheitcation flow. Please read it carefully and implement all requirements described here.

The project has 1 auth service, 1 notification service, 1 BFF service, and 6 business services, plus other helper services such as bucket and realtime. In this document you will be informed only about the auth service. 

Each service is a separate microservice application and listens for HTTP requests at different service URLs.

Services may be deployed to the preview server, staging server, or production server. Therefore, each service has 3 access URLs.
The frontend application must support all deployment environments during development, and the user should be able to select the target API server on the home page.

## Accessing the backend

Each backend service has its own URL for each deployment environment. Users may want to test the frontend in one of the three deployments—preview, staging, or production. Please ensure that the home page includes a deployment server selection option so that, as the frontend coding agent, you can set the base URL for all services.

For the auth service, the base URLs are:

* **Preview:** `https://fintrack.prw.mindbricks.com/auth-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/auth-api`
* **Production:** `https://fintrack.mindbricks.co/auth-api`

Any request that requires login must include a valid token in the Bearer authorization header.



## Multi-Tenancy Management

**THIS APPLICATION IS MULTI-TENANT**

This application is mult-tanant, it means; as a SaaS application, it isolates each tenant-data from each other. The tenants are called `business` and a data object with the same name exist to store and manage the tenant information. The `business` data instances are referenced from other data objects or entities as `businessId`. Any data object which is in tenant level (some data objects may still stay in SaaS level) has a `businessId` property which attaches it to a `business` tenant. But this value is added to the data object instance in the time of creation by the system according to the current `business` user is navigating. 

For the human readability each `business` has also got a `businessCodename` which is a unique form of its name. Any api call to the application should claim its target `business` tenant, so it should provide `businessCodename` parameter at one of the following request locations.

```js
// In header with special header name
headers["mbx-business-codename"] = "babil",

// or in query with ( _business ) parameter

const url = `${serviceUrl}/v1/users/${userId}?_business=babil`

// or in post body with ( _business ) parameter
const body = {
  //...
  _business: "babil",
  //...
}
```

When no `businessCodename` is given in the related parameters, application will assume that the access targets the root target, the Saas level. The `businessCodename` of SaaS level is always `root`. When no `businessCodename` is specified, `root` is assumed as the current `businessCodename`.

Note that, logins and registrations are all tenant scoped. If any a tenant-lvel api is login-required then it will check for a `business` specific token according to the target `business` defined in a related parameter with its codename. The application creates the cookies with `businessCodename` prefixes but it is recommended for the frontend application to populate the bearer header with the user's `business` related token.

Not that all `business` tenants are managed in the same backend services, however a `business` tanant frontend should be specific to one `business`. Frontend should have a technical way to understand which `business` is targeted by the user, for production frontend application this should be managed by the subdomains that represents the codename of the business like,

````
https://babil.storeCreator.com
````

Using the subdomain, frontend will distinguish that the codename is `babil` and will atatch it to all tenant-level api calls.

The url may also be used for the SaaS directly with a more general wording like,

````
https://www.storeCreator.com
````

However, this subdomain management may not be handled easily in the AI frontend builders that they use their own preview urls, an other url structure should be handled to simulate the subdomain behaviour for tenant forwarding.

It may be like,

````
https://{somePreviewUrlOfABuilderPlatform}/babil/login
````

In some way, frontend should provide a simple and practical way to the user to target a specific tenant.

### Sample Business Tenant

The applcation backend also includes a sample tenant created with a sample tenant owner, who has the same email and password of the superadmin. This sample is created in the backend to be able to test the multi-tenant behaviour of the frontend at the beginning.

The sample business has a codename `babil` and can be targetd by attaching this codename to the API calls. So whwn the front end home page is built, homepages both for the SaaS and tenant shoul be created and ready to be tested.



## After User Registration
After a successful registration, the frontend code should handle any verification requirements. The registration response will include a `user` object in the root envelope; this object contains user information with an `id` field.
The user register response will include indicators for the frontend if any email or mobile verification is needed.

```json
{
  //....
  "emailVerificationNeeded": true,
  "mobileVerificationNeeded": true
}
```


## After User Registration

Frontend should also be aware of verification after any login attempt. 
The login request may return a 401 or 403 with the error codes that indicates the verification needs.

```json
{
  //...
  "errCode": "EmailVerificationNeeded",
  // or
  "errCode": "MobileVerificationNeeded",
}
```

## Email Verification

In the registration response, check the `emailVerificationNeeded` property in the response root. If it is `true`, start the email verification flow.

After the login process, if you receive an HTTP error and the response contains an `errCode` with the value `EmailVerificationNeeded`, start the email verification flow.

1. Call the email verification `start` route of the backend (described below) with the user’s email. The backend will send a secret code to the provided email address. **The backend can send the email if the architect has configured a real mail service or SMTP server. During development, the backend also returns the secret code to the frontend. You can read this code from the `secretCode` property of the response.**
2. The secret code in the email will be a 6-digit code. Provide an input page so the user can paste this code into the frontend application. Navigate to this input page after starting the verification process. **If the `secretCode` is sent to the frontend for testing, display it on the input page so the user can copy and paste it.**
3. The `start` response includes a `codeIndex` property. Display its value on the input page so the user can match the index in the message with the one on the screen.
4. When the user submits the code, complete the email verification using the `complete` route of the backend (described below) with the user’s email and the secret code.
5. After a successful email verification response, please check the response object to have the property 'mobileVerificationNeeded' as `true`, if so navigate to the mobile verification flow as described below. 
**If no mobile verification is needed then just navigate the login page.** 

Below are the `start` and `complete` routes for email verification. These are system routes and therefore are not versioned.

#### `POST /verification-services/email-verification/start`

**Purpose:**
Starts email verification by generating and sending a secret code.

| Parameter | Type   | Required | Description                    |
| --------- | ------ | -------- | ------------------------------ |
| `email`   | String | Yes      | User’s email address to verify |

**Example Request**

```json
{ "email": "user@example.com" }
```

**Success Response**

```json
{
  "status": "OK", 
  "codeIndex": 1,
  // timeStamp : Milliseconds since Jan 1, 1970, 00:00:00.000 GMT
  "timeStamp": 1784578660000,
  "date": "Mon Jul 20 2026 23:17:40 GMT+0300 (GMT+03:00)",
  // expireTime: in seconds
  "expireTime": 86400,
  "verificationType": "byLink",

  // in testMode
  "secretCode": "123456",
  "userId": "user-uuid"
}
```

> ⚠️ In production, `secretCode` is **not** returned — it is only sent via email.

**Error Responses**

* `400 Bad Request`: Already verified
* `403 Forbidden`: Too many attempts (rate limit)

---

#### `POST /verification-services/email-verification/complete`

**Purpose:**
Completes verification using the received code.

| Parameter    | Type   | Required | Description       |
| ------------ | ------ | -------- | ----------------- |
| `email`      | String | Yes      | User’s email      |
| `secretCode` | String | Yes      | Verification code |

**Success Response**

```json
{
  "status": "OK", 
  "isVerified": true,
  "email": "user@email.com",
  // in testMode
  "userId": "user-uuid"
}
```

**Error Responses**

* `403 Forbidden`: Code expired or mismatched
* `404 Not Found`: No verification in progress

---


## Mobile Verification

In the registration response, check the `mobileVerificationNeeded` property in the response root. If it is `true`, start the mobile verification flow.

After the login process, if you receive a 403 error and the response contains an `errCode` with the value `MobileVerificationNeeded`, start the mobile verification flow.

1. Call the mobile verification `start` route of the backend (described below) with the user’s email. The backend will send a secret code to the user’s mobile number. **If a real texting service is configured, the backend sends the SMS. During development, the backend also returns the secret code to the frontend in the `secretCode` property.**
2. The secret code in the SMS will be a 6-digit code. Provide an input page so the user can paste this code. Navigate to this input page after starting the verification process. **If the `secretCode` is returned for testing, display it on the input page for easy copy/paste.**
3. When the user submits the code, complete mobile verification using the `complete` route of the backend (described below) with the user’s email and the secret code.
4. The `start` response includes a `codeIndex` property. Display its value on the input page so the user can match the index shown in the message with the one on the screen.
5. After a successful mobile verification response, navigate to the login page.

**Verification Order**
If both `emailVerificationNeeded` and `mobileVerificationNeeded` are `true`, handle both verification flows in order. First complete email verification, then mobile verification.


Below are the `start` and `complete` routes for mobile verification. These are system routes and therefore are not versioned.

#### `POST /verification-services/mobile-verification/start`

| Parameter | Type   | Required | Description                          |
| --------- | ------ | -------- | ------------------------------------ |
| `email`   | String | Yes      | User’s email to locate mobile record |

**Success Response**

```json
{
  "status": "OK", 
  "codeIndex": 1,
  // timeStamp : Milliseconds since Jan 1, 1970, 00:00:00.000 GMT
  "timeStamp": 1784578660000,
  "date": "Mon Jul 20 2026 23:17:40 GMT+0300 (GMT+03:00)",
  // expireTime: in seconds
  "expireTime": 180,
  "verificationType": "byCode",

  // in testMode
  "secretCode": "123456",
  "userId": "user-uuid"
}
```

> ⚠️ `secretCode` is returned only in development.

**Errors**

* `400 Bad Request`: Already verified
* `403 Forbidden`: Rate-limited

---

#### `POST /verification-services/mobile-verification/complete`

| Parameter    | Type   | Required | Description           |
| ------------ | ------ | -------- | --------------------- |
| `email`      | String | Yes      | Associated email      |
| `secretCode` | String | Yes      | Code received via SMS |

**Success Response**

```json
{
  "status": "OK", 
  "isVerified": true,
  "mobile": "+1 333 ...",
  // in testMode
  "userId": "user-uuid"
}
```
---

## Resetting Password

Users can reset their forgotten passwords without a login required, through email and mobile verification.
To be able to start a password reset flow, users will click on the "Reset Password" link in the login page.

Since there are two verification methods, by email or by mobile, for password reset, when the reset password link is clicked, frontend should ask user if they want to make the verification through email of mobile. According to the users selection the frontend shoudl start the related flow as explaned below step by step.

## Password Reset By Email Flow

1. Call the password reset by email verification `start` route of the backend (described below) with the user’s email. The backend will send a secret code to the provided email address. **The backend can send the email if the architect has configured a real mail service or SMTP server. During development, the backend also returns the secret code to the frontend. You can read this code from the `secretCode` property of the response.**
2. The secret code in the email will be a 6-digit code. Provide an input page so the user can paste this code into the frontend application. Navigate to this input page after starting the verification process. **If the `secretCode` is sent to the frontend for testing, display it on the input page so the user can copy and paste it.**
3. The `start` response includes a `codeIndex` property. Display its value on the input page so the user can match the index in the message with the one on the screen.
4. The input page should also include a double input area for the user to enter and confirm their new password.
5. When the user submits the code and the new password, complete the password reset by email using the `complete` route of the backend (described below) with the user’s email , the secret code and new password.
6. After a successful verification response, navigate to the login page.

Below are the `start` and `complete` routes for password reset by email verification. These are system routes and therefore are not versioned.

#### POST `/verification-services/password-reset-by-email/start`
  
  **Purpose**:  
  Starts the password reset process by generating and sending a secret verification code.
  
  #### Request Body
  
  | Parameter | Type   | Required | Description                         |
  |-----------|--------|----------|-------------------------------------|
  | email     | String | Yes      | The email address of the user       |
  
  ```json
  {
    "email": "user@example.com"
  }
  ```
  
  **Success Response**
  
  Returns secret code details (only in development environment) and confirmation that the verification step has been started.
  
  ```json
  {
    "userId": "user-uuid",
    "email": "user@example.com",
    "codeIndex": 1,
    "secretCode": "123456", 
    "timeStamp": 1765484354,
    "expireTime": 86400,
    "date": "2024-04-29T10:00:00.000Z",
    "verificationType": "byLink",
  }
  ```
  
  ⚠️ In production, the secret code is only sent via email and not exposed in the API response.
  
  **Error Responses**
  
  - `401 NotAuthenticated`: Email address not found or not associated with a user.
  - `403 Forbidden`: Sending a code too frequently (spam prevention).
  
  ---
  
  #### POST `/verification-services/password-reset-by-email/complete`
  
  **Purpose**:  
  Completes the password reset process by validating the secret code and updating the user's password.
  
  #### Request Body
  
  | Parameter   | Type   | Required | Description                                  |
  |-------------|--------|----------|----------------------------------------------|
  | email       | String | Yes      | The email address of the user                |
  | secretCode  | String | Yes      | The code received via email                  |
  | password    | String | Yes      | The new password the user wants to set       |
  
  ```json
  {
    "email": "user@example.com",
    "secretCode": "123456",
    "password": "newSecurePassword123"
  }
  ```
  
  **Success Response**
  
  ```json
  {
    "userId": "user-uuid",
    "email": "user@example.com",
    "isVerified": true
  }
  ```
  
  **Error Responses**
  
  - `403 Forbidden`:  
    - Secret code mismatch  
    - Secret code expired  
    - No ongoing verification found  
  
  ---

## Password Reset By Mobile Flow
1. Call the password reset by mobile verification `start` route of the backend (described below) with the user’s email. The backend will send a secret code to the user’s mobile number. **If a real texting service is configured, the backend sends the SMS. During development, the backend also returns the secret code to the frontend in the `secretCode` property.**
2. The secret code in the SMS will be a 6-digit code. Provide an input page so the user can paste this code. Navigate to this input page after starting the verification process. **If the `secretCode` is returned for testing, display it on the input page for easy copy/paste.**
3. The `start` response includes a `codeIndex` property. Display its value on the input page so the user can match the index in the message with the one on the screen. Also display the half masked `mobile`number that comes in the response, to tell the user that their code is sent to this number.
4. The input page should also include a double input area for the user to enter and confirm their new password.
5. When the user submits the code, complete mobile verification using the `complete` route of the backend (described below) with the user’s email and the secret code.
6. After a successful mobile verification response, navigate to the login page.

Below are the `start` and `complete` routes for password reset by mobile verification. These are system routes and therefore are not versioned.

#### POST `/verification-services/password-reset-by-mobile/start`
  
  **Purpose**:  
  Initiates the mobile-based password reset by sending a verification code to the user's mobile.
  
  #### Request Body
  
  | Parameter | Type   | Required | Description                  |
  |-----------|--------|----------|------------------------------|
  | email     | String | Yes      | The email of the user that resets the pssword  |
  
  ```json
  {
    "email": "user@user.com"
  }
  ```
  
  ### Success Response
  
  Returns the verification context (code returned only in development):
  
  ```json
  {
    "status": "OK",
    "codeIndex": 1,
    timeStamp: 133241255,
    "mobile": "+905.....67",
    "secretCode": "123456", 
    "expireTime": 86400,
    "date": "2024-04-29T10:00:00.000Z",
    verificationType: "byLink"
  }
  ```
  
  ⚠️ In production, the `secretCode` is not included in the response and is only sent via SMS.
  
  ### Error Responses
  
  - **400 Bad Request**: Mobile already verified
  - **403 Forbidden**: Rate-limited (code already sent recently)
  - **404 Not Found**: User with provided mobile not found
  
  ---
  
  #### POST `/verification-services/password-reset-by-mobile/complete`
  
  **Purpose**:  
  Finalizes the password reset process by validating the received verification code and updating the user’s password.
  
  #### Request Body
  
  | Parameter   | Type   | Required | Description                                     |
  |-------------|--------|----------|-------------------------------------------------|
  | email       | String | Yes      | The email address of the user                   |
  | secretCode  | String | Yes      | The code received via SMS                       |
  | password    | String | Yes      | The new password to assign                      |
  
  ```json
  {
    "email": "user@example.com",
    "secretCode": "123456",
    "password": "NewSecurePassword123!"
  }
  ```
  
  ### Success Response
  
  ```json
  {
    "userId": "user-uuid",
    "isVerified": true
  }
  ```
  ---



## Navigating the Login Page
Please note that since this application is multitenant, the login page that will be navigated to after a verification process, should be aware of the tenant business. 
If this login navigate is after a user registration (or after a post-registration verification) to a business, then keep the active business as the original and navigate user to the selected business.
If this login navigate is after a business registration (or after a tenant post-registration verification), 
then you have a new business other than the `root` one, so you should make this new tenant as the selected one and navigate to its login page.
If this login is after a post-login verification, then keep the original business that the previous login attempt is made to and navigate to the same business either it is the `root` or andy registered `business`.
 


** Please dont forget to arrange the code to be able to navigate to the verification pages both after registrations and login attempts if verification is needed.**
  

**After this prompt, the user may give you new instructions to update your first output or provide subsequent prompts about the project.**

---

<a id="frontend-prompts-frontend-prompt-3-profile"></a>

## Profile Management



# **FINTRACK**

**FRONTEND GUIDE FOR AI CODING AGENTS - PART 3 - Profile Management**

This document is a part of a REST API guide for the fintrack project.
It is designed for AI agents that will generate frontend code to consume the project’s backend.

This document includes information and api descriptions about building a **profile page** in the frontend using the auth service profile api calls, and also in this document the bucket service will be introduced to manage the avatar.

The project has 1 auth service, 1 notification service, 1 BFF service, and 6 business services, plus other helper services such as bucket and realtime. In this document you will use the auth service and bucket service.

Each service is a separate microservice application and listens for HTTP requests at different service URLs.

Services may be deployed to the preview server, staging server, or production server. Therefore, each service has 3 access URLs.
The frontend application must support all deployment environments during development, and the user should be able to select the target API server on the home page.


## Accessing the backend

Each backend service has its own URL for each deployment environment. Users may want to test the frontend in one of the three deployments—preview, staging, or production. Please ensure that the register and login pages include a deployment server selection option so that, as the frontend coding agent, you can set the base URL for all services.

The base URL of the application in each environment is as follows:

* **Preview:** `https://fintrack.prw.mindbricks.com`
* **Staging:** `https://fintrack-stage.mindbricks.co`
* **Production:** `https://fintrack.mindbricks.co`

For the auth service, service urls are as follows:

* **Preview:** `https://fintrack.prw.mindbricks.com/auth-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/auth-api`
* **Production:** `https://fintrack.mindbricks.co/auth-api`

For each other service, the service URL will be given in the service sections.

Any request that requires login must include a valid token in the Bearer authorization header.


## Multi-Tenancy Management

**THIS APPLICATION IS MULTI-TENANT**

This application is mult-tanant, it means; as a SaaS application, it isolates each tenant-data from each other. The tenants are called `business` and a data object with the same name exist to store and manage the tenant information. The `business` data instances are referenced from other data objects or entities as `businessId`. Any data object which is in tenant level (some data objects may still stay in SaaS level) has a `businessId` property which attaches it to a `business` tenant. But this value is added to the data object instance in the time of creation by the system according to the current `business` user is navigating. 

For the human readability each `business` has also got a `businessCodename` which is a unique form of its name. Any api call to the application should claim its target `business` tenant, so it should provide `businessCodename` parameter at one of the following request locations.

```js
// In header with special header name
headers["mbx-business-codename"] = "babil",

// or in query with ( _business ) parameter

const url = `${serviceUrl}/v1/users/${userId}?_business=babil`

// or in post body with ( _business ) parameter
const body = {
  //...
  _business: "babil",
  //...
}
```

When no `businessCodename` is given in the related parameters, application will assume that the access targets the root target, the Saas level. The `businessCodename` of SaaS level is always `root`. When no `businessCodename` is specified, `root` is assumed as the current `businessCodename`.

Note that, logins and registrations are all tenant scoped. If any a tenant-lvel api is login-required then it will check for a `business` specific token according to the target `business` defined in a related parameter with its codename. The application creates the cookies with `businessCodename` prefixes but it is recommended for the frontend application to populate the bearer header with the user's `business` related token.

Not that all `business` tenants are managed in the same backend services, however a `business` tanant frontend should be specific to one `business`. Frontend should have a technical way to understand which `business` is targeted by the user, for production frontend application this should be managed by the subdomains that represents the codename of the business like,

````
https://babil.storeCreator.com
````

Using the subdomain, frontend will distinguish that the codename is `babil` and will atatch it to all tenant-level api calls.

The url may also be used for the SaaS directly with a more general wording like,

````
https://www.storeCreator.com
````

However, this subdomain management may not be handled easily in the AI frontend builders that they use their own preview urls, an other url structure should be handled to simulate the subdomain behaviour for tenant forwarding.

It may be like,

````
https://{somePreviewUrlOfABuilderPlatform}/babil/login
````

In some way, frontend should provide a simple and practical way to the user to target a specific tenant.

### Sample Business Tenant

The applcation backend also includes a sample tenant created with a sample tenant owner, who has the same email and password of the superadmin. This sample is created in the backend to be able to test the multi-tenant behaviour of the frontend at the beginning.

The sample business has a codename `babil` and can be targetd by attaching this codename to the API calls. So whwn the front end home page is built, homepages both for the SaaS and tenant shoul be created and ready to be tested.



## Bucket Management

This application has a bucket service used to store user files and other object-related files. The bucket service is login-agnostic, so for write operations or private reads, include a bucket token (provided by services) in the request’s Authorization header as a Bearer token.

Please note that all other business services require the access token in the Bearer header, while the bucket service expects a bucket token because it is login-agnostic. Ensure you manage the required token injection properly; any auth interceptor should not replace the bucket token with the access token.

To access the bucket service in each environement use the bucket service api urls below:

* **Preview:** `https://fintrack.prw.mindbricks.com/bucket`
* **Staging:** `https://fintrack-stage.mindbricks.co/bucket`
* **Production:** `https://fintrack.mindbricks.co/bucket`

**User Bucket**
This bucket stores public user files for each user.

When a user logs in—or in the `/currentuser` response—there is a `userBucketToken` to use when sending user-related public files to the bucket service.

```json
{
  //...
  "userBucketToken": "e56d...."
}
```

To upload a file

`POST {bucketServiceUrl}/upload`

The request body is form-data which includes the `bucketId` and the file binary in the `files` field.

```js
{
    bucketId: "{userId}-public-user-bucket",
    files: {binary}
}
```

Response status is 200 on success, e.g., body:

```json
{
    "success": true,
    "data": [
        {
            "fileId": "9da03f6d-0409-41ad-bb06-225a244ae408",
            "originalName": "test (10).png",
            "mimeType": "image/png",
            "size": 604063,
            "status": "uploaded",
            "bucketName": "f7103b85-fcda-4dec-92c6-c336f71fd3a2-public-user-bucket",
            "isPublic": true,
            "downloadUrl": "https://babilcom.mindbricks.co/bucket/download/9da03f6d-0409-41ad-bb06-225a244ae408"
        }
    ]
}
```

To download a file from the bucket, you need its `fileId`. If you upload an avatar or other asset, ensure the download URL or the `fileId` is stored in the backend.

Buckets are mostly used in object creations that require an additional file, such as a product image or user avatar. After uploading your image to the bucket, insert the returned download URL into the related property of the target object record.

**Application Bucket**

This Fintrack application also includes a common public bucket that anyone can read, but only users with the `superAdmin`, `admin`, or `saasAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `applicationBucketToken` field, which is used when uploading any file to the application bucket.

```json
{
  //...
  "applicationBucketToken": "e23fd...."
}
```

The common public application bucket ID is

`"fintrack-public-common-bucket"`

In certain admin areas—such as product management pages—since the user already has the application bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the application bucket using this bucket token whenever needed.



**Business Bucket (Tenant Bucket)**

This Fintrack application also includes a public bucket for each business that anyone can read, but only users with the `tenantOwner` or `tenantAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `tenantBucketToken` field, which is used when uploading any file to the tenant bucket.

```json
{
  //...
  "tenantBucketToken": "e23fd...."
}
```

The common public tenant bucket ID is

`"fintrack-{tenantCodename}-public-tenant-bucket"`

In certain admin areas—such as product management pages—since the user already has the tenant bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the tenant bucket using this bucket token whenever needed.



**Object Buckets**
Some objects may also return a bucket token for uploading or accessing files related to that object. For example, in a project management application, when you fetch a project’s data, a public or private bucket token may be provided to upload or download project-related files.

These buckets will be used as described in the relevant object definitions.


## Profile Page

Design a profile page to manage (view and edit) user information. The profile page should also be able to upload the user avatar to the user’s public bucket. For bucket information, see the Bucket Management section above.

On the profile page, you will need 4 business APIs: `getUser` , `updateProfile`, `updateUserPassword` and `archiveProfile`. Do not rely on the `/currentuser` response for profile data, because it contains session information. The most recent user data is in the user database and should be accessed via the `getUser` business API.

The `updateProfile`, `updateUserPassword` and `archiveProfile` api can only be called by the users themselves. They are designed specific to the profile page.

The avatar upload component should include an image-cropping component with zoom and pan capabilities. The frontend will send the image to the bucket after it is scaled and cropped.

Do not implement your own cropping component; instead, use the library component `react-easy-crop` by installing it.

**Note that the user cannot change/update their `email` or `roleId`.**

For password update you should make a separate block in the UI, so that user can enter old password, new password and confirm new password before calling the `updateUserPassword`.

Here are the 3 auth APIs—`getUser` , `updateProfile` and `updateUserPassword`— as follows:
You can access these APIs through the auth service base URL, `{appUrl}/auth-api`.


### `Get User` API
This api is used by admin roles or the users themselves to get the user profile information.


**Rest Route**

The `getUser` API REST controller can be triggered via the following route:

`/v1/users/:userId`


**Rest Request Parameters**


The `getUser` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| userId  | ID  | true | request.params?.["userId"] |
**userId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/users/:userId**
```js
  axios({
    method: 'GET',
    url: `/v1/users/${userId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "user",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"user": {
		"id": "ID",
		"email": "String",
		"password": "String",
		"fullname": "String",
		"avatar": "String",
		"roleId": "String",
		"emailVerified": "Boolean",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```



### `Update Profile` API
This route is used by users to update their profiles.


**Rest Route**

The `updateProfile` API REST controller can be triggered via the following route:

`/v1/profile/:userId`


**Rest Request Parameters**


The `updateProfile` api has got 3 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| userId  | ID  | true | request.params?.["userId"] |
| fullname  | String  | false | request.body?.["fullname"] |
| avatar  | String  | false | request.body?.["avatar"] |
**userId** : This id paremeter is used to select the required data object that will be updated
**fullname** : A string value to represent the fullname of the user
**avatar** : The avatar url of the user. A random avatar will be generated if not provided


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/profile/:userId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/profile/${userId}`,
    data: {
            fullname:"String",  
            avatar:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "user",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"user": {
		"id": "ID",
		"email": "String",
		"password": "String",
		"fullname": "String",
		"avatar": "String",
		"roleId": "String",
		"emailVerified": "Boolean",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```



### `Update Userpassword` API
This route is used to update the password of users in the profile page by users themselves


**Rest Route**

The `updateUserPassword` API REST controller can be triggered via the following route:

`/v1/userpassword/:userId`


**Rest Request Parameters**


The `updateUserPassword` api has got 3 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| userId  | ID  | true | request.params?.["userId"] |
| oldPassword  | String  | true | request.body?.["oldPassword"] |
| newPassword  | String  | true | request.body?.["newPassword"] |
**userId** : This id paremeter is used to select the required data object that will be updated
**oldPassword** : The old password of the user that will be overridden bu the new one. Send for double check.
**newPassword** : The new password of the user to be updated


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/userpassword/:userId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/userpassword/${userId}`,
    data: {
            oldPassword:"String",  
            newPassword:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "user",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"user": {
		"id": "ID",
		"email": "String",
		"password": "String",
		"fullname": "String",
		"avatar": "String",
		"roleId": "String",
		"emailVerified": "Boolean",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```


### Archiving A Profile

A user may want to archive their profile. So the profile page should include an archive section for the users to archive their accounts.
When an account is archived, it is marked as archived and an aarchiveDate is atteched to the profile. All user data is kept in the database for 1 month after user archived.
If user tries to login or register with the same email, the account will be activated again. But if no login or register occures in 1 month after archiving, the profile and its related data will be deleted permanenetly.
So in the profile page,

1. The arcihve options should be accepted after user writes a text like ("ARCHİVE MY ACCOUNT") to a confirmation dialog, so that frontend UX can ensure this is not an unconscious request.
2. The user should be warned about the process, that his account will be available for a restore for 1 month.

The archive api, can only be called by the users themselves and its used as follows.


### `Archive Profile` API
This api is used by users to archive their profiles.


**Rest Route**

The `archiveProfile` API REST controller can be triggered via the following route:

`/v1/archiveprofile/:userId`


**Rest Request Parameters**


The `archiveProfile` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| userId  | ID  | true | request.params?.["userId"] |
**userId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/archiveprofile/:userId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/archiveprofile/${userId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "user",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"user": {
		"id": "ID",
		"email": "String",
		"password": "String",
		"fullname": "String",
		"avatar": "String",
		"roleId": "String",
		"emailVerified": "Boolean",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```


---

After you complete this step, please ensure you have not made the following common mistakes:

1. The auth API and bucket API are different services, and both URLs should be set according to the selected environment (production, staging, preview).
2. Note that any api call to the application backend is based on a service base url, in this propmpt all auth apis should be called by `/auth-api` prefix after application's base url, and bucket apis should be called by `/bucket` prefix after base url.
3. The auth API and bucket API use different tokens. The auth API requires the `accessToken` in the Bearer header; the bucket API requires bucket-specific tokens such as `userBucketToken` or other application-specific bucket tokens. You may need two separate Axios clients: one for auth (always using the access token) and one for bucket operations (using the relevant bucket token).
4. On the profile page, fetch the latest user data from the service using `getUser`. The `/currentuser` API is session-stored data; the latest data is in the database.
5. When you upload the avatar image on the profile page, use the returned download URL as the user’s `avatar` property and update the user record when the Save button is clicked.

**After this prompt, the user may give you new instructions to update your first output or provide subsequent prompts about the project.**

---

<a id="frontend-prompts-frontend-prompt-4-usermanagement"></a>

## User Management



# **FINTRACK**

**FRONTEND GUIDE FOR AI CODING AGENTS - PART 4 - User Management**

This document is the 2nd part of a REST API guide for the fintrack project.
It is designed for AI agents that will generate frontend code to consume the project’s backend.

This document provides extensive instruction for administrative user management.

## Service Access

User management is handled through auth service again.

Auth service may be deployed to the preview server, staging server, or production server. Therefore,it has 3 access URLs.
The frontend application must support all deployment environments during development, and the user should be able to select the target API server on the login page (already handled in first part.).

For the auth service, the base URLs are:

* **Preview:** `https://fintrack.prw.mindbricks.com/auth-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/auth-api`
* **Production:** `https://fintrack.mindbricks.co/auth-api`

Please note that any feature in this document is open to admins only. When the user logins, the response includes a roleId field.

This roleId should one of these following admin roles. `superAdmin`, `saasAdmin`,   `tenantOwner`, `tenantAdmin`

## Scope

Auth service provides following feature for user management in fintrack application.

These features are already handled in the previous part.
1. User Registration
2. User Authentication
3. Password Reset
3. Email (and/or) Mobile Verification
4. Profile Management

These features will be handled in this part.
- User Management
- User Groups Management
- Permission Manageemnt

## API Structure

### Object Structure of a Successful Response

When the service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope includes the data and essential metadata such as configuration details and pagination information, providing context to the client.

**HTTP Status Codes:**

* **200 OK**: Returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request was processed successfully.
* **201 Created**: Returned for CREATE operations, indicating that the resource was created successfully.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling that the request executed successfully. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3,
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
```

* **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation.

### Additional Data

Each API may include additional data besides the main data object, depending on the business logic of the API. These will be provided in each API’s response signature.

### Error Response

If a request encounters an issue—whether due to a logical fault or a technical problem—the service responds with a standardized JSON error structure. The HTTP status code indicates the nature of the error, using commonly recognized codes for clarity:

* **400 Bad Request**: The request was improperly formatted or contained invalid parameters.
* **401 Unauthorized**: The request lacked a valid authentication token; login is required.
* **403 Forbidden**: The current token does not grant access to the requested resource.
* **404 Not Found**: The requested resource was not found on the server.
* **500 Internal Server Error**: The server encountered an unexpected condition.

Each error response is structured to provide meaningful insight into the problem, assisting in efficient diagnosis and resolution.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```

## User Management

User management will be one of the main parts of the administrative manageemnts, so there will be a minimal but fancy `users` page in the admin dashboard.

### User Roles

- `superadmin` : The first creator of the backend, the owner of the application, root user, has got an absolute authroization on all actions. It can not be assgined any other user. It can't be unassigned. Super admin user can not be deleted in any way.
- `saasAdmin` : The role that can be assigned to any user by the super admin. This role includes most permissions that super admin have, but admins can't assign admin roles, can't unassign an admin role, can't delete other users who have admin role. In addition to these limitations, some critical actions in the business services may also be open to only super admin.
  
- `tenantOwner` : The first creator of the business tenant. This user is automatically gets this role when they first created the tenant. They have all authroization in the scope of their business tenant. This role can't be assigned or unassgined. Tenant owner user can not be deleted unless the tenant is deleted. 
- `tenantAdmin` : The role that can be assigned to any user by the tenant owner. This role includes most permissions that tenant owner have, but tenant admins can't assign tenant admin roles, can't unassign tenant admin roles, can't delete other users who have tenant admin role. 
- `tenantUser` : The standard role that is assgined to every user when first created or registered. This role doesnt have any privilages and can access to their own data or public data. 


Along with the default roles, this project also configured to have the following roles:
`owner` `accountant` `user`
    

The roles object is a hardcoded object in the generated code, and it contains the following roles:
```json
{
  "superAdmin": "'superAdmin'",
  "saasAdmin": "'saasAdmin'",
  "tenantOwner": "'tenantOwner'",
  "tenantAdmin": "'tenantAdmin'",
  "tenantUser": "'tenantUser'",
  "owner": "'owner'",
  "accountant": "'accountant'",
  "user": "'user'"
}
```

Each user may have only one role, and it is given in `/login` , `/currentuser` or `/users/:userId`  response as follows

```json
{
  // ...
  "roleId":"superAdmin",
  // ...
}
```
  

## Listing Users

You can list users using the `listUsers` api. 

### `List Users` API
The list of users is filtered by the tenantId.


**Rest Route**

The `listUsers` API REST controller can be triggered via the following route:

`/v1/users`


**Rest Request Parameters**


**Filter Parameters**

The `listUsers` api supports 3 optional filter parameters for filtering list results:

**email** (`String`):  A string value to represent the user's email.

- Single (partial match, case-insensitive): `?email=<value>`
- Multiple: `?email=<value1>&email=<value2>`
- Null: `?email=null`


**fullname** (`String`): A string value to represent the fullname of the user

- Single (partial match, case-insensitive): `?fullname=<value>`
- Multiple: `?fullname=<value1>&fullname=<value2>`
- Null: `?fullname=null`


**roleId** (`String`): A string value to represent the roleId of the user.

- Single (partial match, case-insensitive): `?roleId=<value>`
- Multiple: `?roleId=<value1>&roleId=<value2>`
- Null: `?roleId=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/users**
```js
  axios({
    method: 'GET',
    url: '/v1/users',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // email: '<value>' // Filter by email
        // fullname: '<value>' // Filter by fullname
        // roleId: '<value>' // Filter by roleId
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "users",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"users": [
		{
			"id": "ID",
			"email": "String",
			"password": "String",
			"fullname": "String",
			"avatar": "String",
			"roleId": "String",
			"emailVerified": "Boolean",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID"
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
## Searching Users
You may search users with their full names and emails. The search is done in elasticsearch index of the user table so a fast response is provided by the backend. You can send search request on each character update in the search box but start searching after 3 chars.
The keyword parameter that is used in the business logic of the api, is read from the keyword query parameter.

eg: `GET /v1/searchusers?keyword=Joe`

When the user deletes the search keyword, use the `listUsers` api to get the full list again.

### `Search Users` API
The list of users is filtered by the tenantId.


**Rest Route**

The `searchUsers` API REST controller can be triggered via the following route:

`/v1/searchusers`


**Rest Request Parameters**


The `searchUsers` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| keyword  | String  | true | request.query?.["keyword"] |
**keyword** : 

**Filter Parameters**

The `searchUsers` api supports 1 optional filter parameter for filtering list results:

**roleId** (`String`): A string value to represent the roleId of the user.

- Single (partial match, case-insensitive): `?roleId=<value>`
- Multiple: `?roleId=<value1>&roleId=<value2>`
- Null: `?roleId=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/searchusers**
```js
  axios({
    method: 'GET',
    url: '/v1/searchusers',
    data: {
    
    },
    params: {
             keyword:'"String"',  
    
        // Filter parameters (see Filter Parameters section above)
        // roleId: '<value>' // Filter by roleId
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "users",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"users": [
		{
			"id": "ID",
			"email": "String",
			"password": "String",
			"fullname": "String",
			"avatar": "String",
			"roleId": "String",
			"emailVerified": "Boolean",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID"
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
#### Pagination
When you list the users please use pagination. To be able to use pagination you should provide a `pageNumber` paramater in the query. The default row count for one page is 25, add an option for user to change it to 50 or 100. You can provide this value to the api through the `pageRowCount` parameter;

`GET /users?pageNumber=1&pageRowCount=50`

## Creatng Users

The user management console in the admin dashboard should provide UX components for user creating by admins. When creating users, it should also be possible to upload user avatar. Note that when creating, updating users , admins can not set emailVerified (or mobileVerified if exists) as true, since it is a logical mechanism and should be verified only through verification processes. 

### `Create User` API
This api is used by admin roles to create a new user manually from admin panels


**Rest Route**

The `createUser` API REST controller can be triggered via the following route:

`/v1/users`


**Rest Request Parameters**


The `createUser` api has got 4 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| avatar  | String  | false | request.body?.["avatar"] |
| email  | String  | true | request.body?.["email"] |
| password  | String  | true | request.body?.["password"] |
| fullname  | String  | true | request.body?.["fullname"] |
**avatar** : The avatar url of the user. If not sent, a default random one will be generated.
**email** :  A string value to represent the user's email.
**password** :  A string value to represent the user's password. It will be stored as hashed.
**fullname** : A string value to represent the fullname of the user


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/users**
```js
  axios({
    method: 'POST',
    url: '/v1/users',
    data: {
            avatar:"String",  
            email:"String",  
            password:"String",  
            fullname:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "user",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"user": {
		"id": "ID",
		"email": "String",
		"password": "String",
		"fullname": "String",
		"avatar": "String",
		"roleId": "String",
		"emailVerified": "Boolean",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### Avatar Upload

In this user admin panel, if any avatar upload is needed, it should be uploaded to the application public bucket. To access this application bucket, the `applicationBucketToken` should be used in the bearer header, and the bucketId in the payload should be given as 
`"fintrack-public-common-bucket"` .


Note that since this application is mult-tenant the application bucket can only be used by saas-admins for the saas users. Tenant owners and tenant admins should use the tenant bucket with `tenantBucketToken`.
The tenant bucket id for a business is 
`"fintrack-{tenantCodename}-public-tenant-bucket"`


Before the avatar upload, a specific componenet from `react-easy-crop` lib should be used for zoom, pan and crop. This component also requested in the PART 1 prompt for profile page, so ensure taht you reuse the previous code if exists.

## Updating Users

User update is possible by `updateUser`api. However since this update api is also called by teh user themselves it is lmited with name and avatar change (or any other user related property). 
For roleId and password updates seperate apis are used. So arrange the user update UI as to update the user info, as to set roleId and as to update password. 

### `Update User` API
This route is used by admins to update user profiles.


**Rest Route**

The `updateUser` API REST controller can be triggered via the following route:

`/v1/users/:userId`


**Rest Request Parameters**


The `updateUser` api has got 3 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| userId  | ID  | true | request.params?.["userId"] |
| fullname  | String  | false | request.body?.["fullname"] |
| avatar  | String  | false | request.body?.["avatar"] |
**userId** : This id paremeter is used to select the required data object that will be updated
**fullname** : A string value to represent the fullname of the user
**avatar** : The avatar url of the user. A random avatar will be generated if not provided


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/users/:userId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/users/${userId}`,
    data: {
            fullname:"String",  
            avatar:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "user",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"user": {
		"id": "ID",
		"email": "String",
		"password": "String",
		"fullname": "String",
		"avatar": "String",
		"roleId": "String",
		"emailVerified": "Boolean",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
For role updates there are some rules.
1. Superadmin role can not be unassigned even by superadmin.
2. Admin roles can be assgined or unassgined only by superadmin.
3. All other roles can be assigned and unassgined by admins and superadmin.

For password updates there are some rules.
1. Superadmin and admin passwords can be updated only by superadmin. 
2. Admins can update only non-admin passwords.

### `Update Userrole` API
This route is used by admin roles to update the user role.The default role is tenantUser when a tenant user is registered. A tenant user's role can be updated by tenantAdmin / tenantOwner, while saas user's role is updated by superAdmin or saasAdmin


**Rest Route**

The `updateUserRole` API REST controller can be triggered via the following route:

`/v1/userrole/:userId`


**Rest Request Parameters**


The `updateUserRole` api has got 2 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| userId  | ID  | true | request.params?.["userId"] |
| roleId  | String  | true | request.body?.["roleId"] |
**userId** : This id paremeter is used to select the required data object that will be updated
**roleId** : The new roleId of the user to be updated


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/userrole/:userId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/userrole/${userId}`,
    data: {
            roleId:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "user",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"user": {
		"id": "ID",
		"email": "String",
		"password": "String",
		"fullname": "String",
		"avatar": "String",
		"roleId": "String",
		"emailVerified": "Boolean",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Update Userpasswordbyadmin` API
This route is used to change any user password by admins only. Superadmin can chnage all passwords, admins can change only nonadmin passwords


**Rest Route**

The `updateUserPasswordByAdmin` API REST controller can be triggered via the following route:

`/v1/userpasswordbyadmin/:userId`


**Rest Request Parameters**


The `updateUserPasswordByAdmin` api has got 2 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| userId  | ID  | true | request.params?.["userId"] |
| password  | String  | true | request.body?.["password"] |
**userId** : This id paremeter is used to select the required data object that will be updated
**password** : The new password of the user to be updated


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/userpasswordbyadmin/:userId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/userpasswordbyadmin/${userId}`,
    data: {
            password:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "user",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"user": {
		"id": "ID",
		"email": "String",
		"password": "String",
		"fullname": "String",
		"avatar": "String",
		"roleId": "String",
		"emailVerified": "Boolean",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### Deleting Users

Deleting users is possible in certain conditions.

1. SuperAdmin can not be deleted.
2. Admins can be deleted by only superadmin.
3. Users can be deleted by admins or superadmin.

### `Delete User` API
This api is used by admins to delete user profiles.


**Rest Route**

The `deleteUser` API REST controller can be triggered via the following route:

`/v1/users/:userId`


**Rest Request Parameters**


The `deleteUser` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| userId  | ID  | true | request.params?.["userId"] |
**userId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/users/:userId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/users/${userId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "user",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"user": {
		"id": "ID",
		"email": "String",
		"password": "String",
		"fullname": "String",
		"avatar": "String",
		"roleId": "String",
		"emailVerified": "Boolean",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
---


When you list user group members, a `user` object will also be inserted in each userGroupMember object, with fullname, avatar and email.

## Bucket Management

(This information is also given in PART 1 prompt.)

This application has a bucket service used to store user files and other object-related files. The bucket service is login-agnostic, so for write operations or private reads, include a bucket token (provided by services) in the request’s Authorization header as a Bearer token.

Please note that all other business services require the access token in the Bearer header, while the bucket service expects a bucket token because it is login-agnostic. Ensure you manage the required token injection properly; any auth interceptor should not replace the bucket token with the access token.

**User Bucket**
This bucket stores public user files for each user.

When a user logs in—or in the `/currentuser` response—there is a `userBucketToken` to use when sending user-related public files to the bucket service.

```json
{
  //...
  "userBucketToken": "e56d...."
}
```

To upload a file

`POST {baseUrl}/bucket/upload`

The request body is form-data which includes the `bucketId` and the file binary in the `files` field.

```js
{
    bucketId: "{userId}-public-user-bucket",
    files: {binary}
}
```

Response status is 200 on success, e.g., body:

```json
{
    "success": true,
    "data": [
        {
            "fileId": "9da03f6d-0409-41ad-bb06-225a244ae408",
            "originalName": "test (10).png",
            "mimeType": "image/png",
            "size": 604063,
            "status": "uploaded",
            "bucketName": "f7103b85-fcda-4dec-92c6-c336f71fd3a2-public-user-bucket",
            "isPublic": true,
            "downloadUrl": "https://babilcom.mindbricks.co/bucket/download/9da03f6d-0409-41ad-bb06-225a244ae408"
        }
    ]
}
```

To download a file from the bucket, you need its `fileId`. If you upload an avatar or other asset, ensure the download URL or the `fileId` is stored in the backend.

Buckets are mostly used in object creations that require an additional file, such as a product image or user avatar. After uploading your image to the bucket, insert the returned download URL into the related property of the target object record.

**Application Bucket**

This Fintrack application also includes a common public bucket that anyone can read, but only users with the `superAdmin`, `admin`, or `saasAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `applicationBucketToken` field, which is used when uploading any file to the application bucket.

```json
{
  //...
  "applicationBucketToken": "e23fd...."
}
```

The common public application bucket ID is

`"fintrack-public-common-bucket"`

In certain admin areas—such as product management pages—since the user already has the application bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the application bucket using this bucket token whenever needed.



**Business Bucket (Tenant Bucket)**

This Fintrack application also includes a public bucket for each business that anyone can read, but only users with the `tenantOwner` or `tenantAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `tenantBucketToken` field, which is used when uploading any file to the tenant bucket.

```json
{
  //...
  "tenantBucketToken": "e23fd...."
}
```

The common public tenant bucket ID is

`"fintrack-{tenantCodename}-public-tenant-bucket"`

In certain admin areas—such as product management pages—since the user already has the tenant bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the tenant bucket using this bucket token whenever needed.



**Object Buckets**
Some objects may also return a bucket token for uploading or accessing files related to that object. For example, in a project management application, when you fetch a project’s data, a public or private bucket token may be provided to upload or download project-related files.

These buckets will be used as described in the relevant object definitions.

**After this prompt, the user may give you new instructions to update the output of this prompt or provide subsequent prompts about the project.**

---

<a id="frontend-prompts-frontend-prompt-5-customermanagementservice"></a>

## CustomerManagement Service



# **FINTRACK**

**FRONTEND GUIDE FOR AI CODING AGENTS - PART 5 - CustomerManagement Service**

This document is a part of a REST API guide for the fintrack project.
It is designed for AI agents that will generate frontend code to consume the project’s backend.

This document provides extensive instruction for the usage of customerManagement

## Service Access

CustomerManagement service management is handled through service specific base urls.

CustomerManagement  service may be deployed to the preview server, staging server, or production server. Therefore,it has 3 access URLs.
The frontend application must support all deployment environments during development, and the user should be able to select the target API server on the login page (already handled in first part.).

For the customerManagement service, the base URLs are:

* **Preview:** `https://fintrack.prw.mindbricks.com/customermanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/customermanagement-api`
* **Production:** `https://fintrack.mindbricks.co/customermanagement-api`

## Scope

**CustomerManagement Service Description**

Handles all business-specific customer CRUD operations and exposes customer data for sales invoice and reporting workflows. Ensures strict tenant (business) isolation for all customer records and supports role-based access control per business context.

CustomerManagement service provides apis and business logic for following data objects in fintrack application. 
Each data object may be either a central domain of the application data structure or a related helper data object for a central concept.
Note that data object concept is equal to table concept in the database, in the service database each data object is represented as a db table scheme and the object instances as table rows.  


**`customer` Data Object**: Business customer/contact record, uniquely scoped to business. Contains info required for sales, invoicing, and reporting. Not shared across tenants.


## CustomerManagement Service Frontend Description By The Backend Architect

# Customer Management Service UI Behaviours
- Customer records are managed strictly within the logged-in user's business context. 
- All roles can view/search customers; Owners/Accountants can create/update/delete, Users can only create and view. 
- When listing customers, provide filtering by name, tax number, or contact info. 
- Present address/notes in multiline fields to allow full details.
- Provide clear indication of customer status (active/deleted if ever exposed).
- Customer data appears in dropdowns/selectors for invoices and reporting screens.

## API Structure

### Object Structure of a Successful Response

When the service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope includes the data and essential metadata such as configuration details and pagination information, providing context to the client.

**HTTP Status Codes:**

* **200 OK**: Returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request was processed successfully.
* **201 Created**: Returned for CREATE operations, indicating that the resource was created successfully.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling that the request executed successfully. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3,
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
```
* **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation.

### Additional Data

Each API may include additional data besides the main data object, depending on the business logic of the API. These will be provided in each API’s response signature.

### Error Response

If a request encounters an issue—whether due to a logical fault or a technical problem—the service responds with a standardized JSON error structure. The HTTP status code indicates the nature of the error, using commonly recognized codes for clarity:

* **400 Bad Request**: The request was improperly formatted or contained invalid parameters.
* **401 Unauthorized**: The request lacked a valid authentication token; login is required.
* **403 Forbidden**: The current token does not grant access to the requested resource.
* **404 Not Found**: The requested resource was not found on the server.
* **500 Internal Server Error**: The server encountered an unexpected condition.

Each error response is structured to provide meaningful insight into the problem, assisting in efficient diagnosis and resolution.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```

## Bucket Management

(This information is also given in PART 1 prompt.)

This application has a bucket service used to store user files and other object-related files. The bucket service is login-agnostic, so for write operations or private reads, include a bucket token (provided by services) in the request’s Authorization header as a Bearer token.

Please note that all other business services require the access token in the Bearer header, while the bucket service expects a bucket token because it is login-agnostic. Ensure you manage the required token injection properly; any auth interceptor should not replace the bucket token with the access token.

**User Bucket**
This bucket stores public user files for each user.

When a user logs in—or in the `/currentuser` response—there is a `userBucketToken` to use when sending user-related public files to the bucket service.

```json
{
  //...
  "userBucketToken": "e56d...."
}
```

To upload a file

`POST {baseUrl}/bucket/upload`

The request body is form-data which includes the `bucketId` and the file binary in the `files` field.

```js
{
    bucketId: "{userId}-public-user-bucket",
    files: {binary}
}
```

Response status is 200 on success, e.g., body:

```json
{
    "success": true,
    "data": [
        {
            "fileId": "9da03f6d-0409-41ad-bb06-225a244ae408",
            "originalName": "test (10).png",
            "mimeType": "image/png",
            "size": 604063,
            "status": "uploaded",
            "bucketName": "f7103b85-fcda-4dec-92c6-c336f71fd3a2-public-user-bucket",
            "isPublic": true,
            "downloadUrl": "https://babilcom.mindbricks.co/bucket/download/9da03f6d-0409-41ad-bb06-225a244ae408"
        }
    ]
}
```

To download a file from the bucket, you need its `fileId`. If you upload an avatar or other asset, ensure the download URL or the `fileId` is stored in the backend.

Buckets are mostly used in object creations that require an additional file, such as a product image or user avatar. After uploading your image to the bucket, insert the returned download URL into the related property of the target object record.

**Application Bucket**

This Fintrack application also includes a common public bucket that anyone can read, but only users with the `superAdmin`, `admin`, or `saasAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `applicationBucketToken` field, which is used when uploading any file to the application bucket.

```json
{
  //...
  "applicationBucketToken": "e23fd...."
}
```

The common public application bucket ID is

`"fintrack-public-common-bucket"`

In certain admin areas—such as product management pages—since the user already has the application bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the application bucket using this bucket token whenever needed.



**Business Bucket (Tenant Bucket)**

This Fintrack application also includes a public bucket for each business that anyone can read, but only users with the `tenantOwner` or `tenantAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `tenantBucketToken` field, which is used when uploading any file to the tenant bucket.

```json
{
  //...
  "tenantBucketToken": "e23fd...."
}
```

The common public tenant bucket ID is

`"fintrack-{tenantCodename}-public-tenant-bucket"`

In certain admin areas—such as product management pages—since the user already has the tenant bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the tenant bucket using this bucket token whenever needed.



**Object Buckets**
Some objects may also return a bucket token for uploading or accessing files related to that object. For example, in a project management application, when you fetch a project’s data, a public or private bucket token may be provided to upload or download project-related files.

These buckets will be used as described in the relevant object definitions.


## Customer Data Object

Business customer/contact record, uniquely scoped to business. Contains info required for sales, invoicing, and reporting. Not shared across tenants.

### Customer  Data Object Frontend Description By The Backend Architect

# Customer Object UX Prompt
- Allow creation and editing of customer with fields: Name (required), Tax Number, Contact Name, Contact Email, Phone, Address, Notes (all optional/multiline as needed).
- When displaying, show all details in view screen. 
- Address and Notes fields support Unicode and multiline entry/displays.
- Allow quick searching by name, tax number, or contact info.
- Customer is always linked to the current business (not visible across tenants).


### Customer Data Object Properties

Customer data object has got following properties that are represented as table fields in the database scheme. 
These properties don't stand just for data storage, but each may have different settings to manage the business logic. 

| Property | Type | IsArray | Required | Description |
|----------|------|---------|----------|-------------|
| `address` | Text | false | No | Full postal address, optional, multi-line, Unicode supported. |
| `contactEmail` | String | false | No | Primary contact's email address (optional, for notifications or info). |
| `contactName` | String | false | No | Primary contact person's name (optional, for individual or company). |
| `name` | String | false | Yes | Full customer display name (required). |
| `notes` | Text | false | No | Internal notes/comments about the customer, never public. |
| `phone` | String | false | No | Main phone number for contact (optional). |
| `taxNumber` | String | false | No | Tax/VAT identification number or code (optional). |
| `businessId` | ID | false | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value, formula or session bind is set.





### Filter Properties

`contactEmail` `contactName` `name` `phone` `taxNumber` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's.

- **contactEmail**: String  has a filter named `contactEmail`

- **contactName**: String  has a filter named `contactName`

- **name**: String  has a filter named `name`

- **phone**: String  has a filter named `phone`

- **taxNumber**: String  has a filter named `taxNumber`

- **businessId**: ID  has a filter named `businessId`



## API Reference

### `Create Customer` API
Create a new customer for the current business. Owners/Accountants/Users within the business can create; customers are private to tenant.

**API Frontend Description By The Backend Architect**

After create, new customer should be listed and available for invoice selections. Minimal required input: name. Optional: tax, contact, address, notes.

**Rest Route**

The `createCustomer` API REST controller can be triggered via the following route:

`/v1/customers`


**Rest Request Parameters**


The `createCustomer` api has got 7 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| address  | Text  | false | request.body?.["address"] |
| contactEmail  | String  | false | request.body?.["contactEmail"] |
| contactName  | String  | false | request.body?.["contactName"] |
| name  | String  | true | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| phone  | String  | false | request.body?.["phone"] |
| taxNumber  | String  | false | request.body?.["taxNumber"] |
**address** : Full postal address, optional, multi-line, Unicode supported.
**contactEmail** : Primary contact's email address (optional, for notifications or info).
**contactName** : Primary contact person's name (optional, for individual or company).
**name** : Full customer display name (required).
**notes** : Internal notes/comments about the customer, never public.
**phone** : Main phone number for contact (optional).
**taxNumber** : Tax/VAT identification number or code (optional).


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/customers**
```js
  axios({
    method: 'POST',
    url: '/v1/customers',
    data: {
            address:"Text",  
            contactEmail:"String",  
            contactName:"String",  
            name:"String",  
            notes:"Text",  
            phone:"String",  
            taxNumber:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Customer` API
Soft-delete (deactivate) a customer. Only Owner/Accountant may delete. Deleted customers are hidden in lists and searches but preserved for audit/history.

**API Frontend Description By The Backend Architect**

On delete, customer disappears from active lists and selectors but is preserved for history. Confirm via dialog.

**Rest Route**

The `deleteCustomer` API REST controller can be triggered via the following route:

`/v1/customers/:customerId`


**Rest Request Parameters**


The `deleteCustomer` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| customerId  | ID  | true | request.params?.["customerId"] |
**customerId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/customers/:customerId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/customers/${customerId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Customer` API
Get details of a specific customer by ID, for use in details screens or invoice selectors. All roles in the business may view.

**API Frontend Description By The Backend Architect**

Show all customer fields. Used on customer detail screen and as lookup for invoice or reporting.

**Rest Route**

The `getCustomer` API REST controller can be triggered via the following route:

`/v1/customers/:customerId`


**Rest Request Parameters**


The `getCustomer` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| customerId  | ID  | true | request.params?.["customerId"] |
**customerId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/customers/:customerId**
```js
  axios({
    method: 'GET',
    url: `/v1/customers/${customerId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `List Customers` API
List all customers for the current business. Any role can search/filter by name, tax number, or contact. Results are scoped to current tenant.

**API Frontend Description By The Backend Architect**

List screen allows filtering by name, tax, contact info. Table view recommended. Customers appear in invoice pickers and balance reports.

**Rest Route**

The `listCustomers` API REST controller can be triggered via the following route:

`/v1/customers`


**Rest Request Parameters**
The `listCustomers` api has got no request parameters.    



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/customers**
```js
  axios({
    method: 'GET',
    url: '/v1/customers',
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customers",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"customers": [
		{
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Customer` API
Update an existing customer. Owners/Accountants can update all fields; Users cannot update existing records.

**API Frontend Description By The Backend Architect**

Update screen shows all editable fields. Business/tenant context enforced. Record remains available for invoice selection if active.

**Rest Route**

The `updateCustomer` API REST controller can be triggered via the following route:

`/v1/customers/:customerId`


**Rest Request Parameters**


The `updateCustomer` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| customerId  | ID  | true | request.params?.["customerId"] |
| address  | Text  | false | request.body?.["address"] |
| contactEmail  | String  | false | request.body?.["contactEmail"] |
| contactName  | String  | false | request.body?.["contactName"] |
| name  | String  | false | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| phone  | String  | false | request.body?.["phone"] |
| taxNumber  | String  | false | request.body?.["taxNumber"] |
**customerId** : This id paremeter is used to select the required data object that will be updated
**address** : Full postal address, optional, multi-line, Unicode supported.
**contactEmail** : Primary contact's email address (optional, for notifications or info).
**contactName** : Primary contact person's name (optional, for individual or company).
**name** : Full customer display name (required).
**notes** : Internal notes/comments about the customer, never public.
**phone** : Main phone number for contact (optional).
**taxNumber** : Tax/VAT identification number or code (optional).


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/customers/:customerId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/customers/${customerId}`,
    data: {
            address:"Text",  
            contactEmail:"String",  
            contactName:"String",  
            name:"String",  
            notes:"Text",  
            phone:"String",  
            taxNumber:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `_fetch Listcustomer` API
System API to fetch list of customer records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListCustomer` API REST controller can be triggered via the following route:

`/v1/_fetchlistcustomer`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListCustomer` api supports 5 optional filter parameters for filtering list results:

**contactEmail** (`String`): Primary contact's email address (optional, for notifications or info).

- Single (partial match, case-insensitive): `?contactEmail=<value>`
- Multiple: `?contactEmail=<value1>&contactEmail=<value2>`
- Null: `?contactEmail=null`


**contactName** (`String`): Primary contact person's name (optional, for individual or company).

- Single (partial match, case-insensitive): `?contactName=<value>`
- Multiple: `?contactName=<value1>&contactName=<value2>`
- Null: `?contactName=null`


**name** (`String`): Full customer display name (required).

- Single (partial match, case-insensitive): `?name=<value>`
- Multiple: `?name=<value1>&name=<value2>`
- Null: `?name=null`


**phone** (`String`): Main phone number for contact (optional).

- Single (partial match, case-insensitive): `?phone=<value>`
- Multiple: `?phone=<value1>&phone=<value2>`
- Null: `?phone=null`


**taxNumber** (`String`): Tax/VAT identification number or code (optional).

- Single (partial match, case-insensitive): `?taxNumber=<value>`
- Multiple: `?taxNumber=<value1>&taxNumber=<value2>`
- Null: `?taxNumber=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistcustomer**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistcustomer',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // contactEmail: '<value>' // Filter by contactEmail
        // contactName: '<value>' // Filter by contactName
        // name: '<value>' // Filter by name
        // phone: '<value>' // Filter by phone
        // taxNumber: '<value>' // Filter by taxNumber
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customers",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"customers": [
		{
			"id": "ID",
			"address": "Text",
			"contactEmail": "String",
			"contactName": "String",
			"name": "String",
			"notes": "Text",
			"phone": "String",
			"taxNumber": "String",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID"
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```

**After this prompt, the user may give you new instructions to update the output of this prompt or provide subsequent prompts about the project.**




---

<a id="frontend-prompts-frontend-prompt-6-expensemanagementservice"></a>

## ExpenseManagement Service



# **FINTRACK**

**FRONTEND GUIDE FOR AI CODING AGENTS - PART 6 - ExpenseManagement Service**

This document is a part of a REST API guide for the fintrack project.
It is designed for AI agents that will generate frontend code to consume the project’s backend.

This document provides extensive instruction for the usage of expenseManagement

## Service Access

ExpenseManagement service management is handled through service specific base urls.

ExpenseManagement  service may be deployed to the preview server, staging server, or production server. Therefore,it has 3 access URLs.
The frontend application must support all deployment environments during development, and the user should be able to select the target API server on the login page (already handled in first part.).

For the expenseManagement service, the base URLs are:

* **Preview:** `https://fintrack.prw.mindbricks.com/expensemanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/expensemanagement-api`
* **Production:** `https://fintrack.mindbricks.co/expensemanagement-api`

## Scope

**ExpenseManagement Service Description**

Handles CRUD for general business expenses (not tied to invoices), enforcing per-business tenant isolation, enabling categorization and supporting future reporting/analytics. Part of the FinTrack financial management backend.

ExpenseManagement service provides apis and business logic for following data objects in fintrack application. 
Each data object may be either a central domain of the application data structure or a related helper data object for a central concept.
Note that data object concept is equal to table concept in the database, in the service database each data object is represented as a db table scheme and the object instances as table rows.  


**`expense` Data Object**: Represents a general expense not tied to any invoice, always scoped to a single business. Can be categorized, linked (optionally) to a supplier, and used in future financial analysis. All fields support Unicode, amount is always in business-relevant currency.


## ExpenseManagement Service Frontend Description By The Backend Architect

This service powers all UX related to general expenses (not directly tied to invoices). UX should allow listing, searching by date/category/supplier, easy entry UI for new expenses (date, amount, currency, category, description), and strict scoping per logged-in business. Owner/Accountant roles can create/edit/delete; Users have view-only access (for reference/reporting screens). All expense fields support Unicode. Supplier lookup should be autocomplete if supplierId is used; all filters (category/date range/supplier) should be present in expense search/filter UIs.

## API Structure

### Object Structure of a Successful Response

When the service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope includes the data and essential metadata such as configuration details and pagination information, providing context to the client.

**HTTP Status Codes:**

* **200 OK**: Returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request was processed successfully.
* **201 Created**: Returned for CREATE operations, indicating that the resource was created successfully.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling that the request executed successfully. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3,
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
```
* **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation.

### Additional Data

Each API may include additional data besides the main data object, depending on the business logic of the API. These will be provided in each API’s response signature.

### Error Response

If a request encounters an issue—whether due to a logical fault or a technical problem—the service responds with a standardized JSON error structure. The HTTP status code indicates the nature of the error, using commonly recognized codes for clarity:

* **400 Bad Request**: The request was improperly formatted or contained invalid parameters.
* **401 Unauthorized**: The request lacked a valid authentication token; login is required.
* **403 Forbidden**: The current token does not grant access to the requested resource.
* **404 Not Found**: The requested resource was not found on the server.
* **500 Internal Server Error**: The server encountered an unexpected condition.

Each error response is structured to provide meaningful insight into the problem, assisting in efficient diagnosis and resolution.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```

## Bucket Management

(This information is also given in PART 1 prompt.)

This application has a bucket service used to store user files and other object-related files. The bucket service is login-agnostic, so for write operations or private reads, include a bucket token (provided by services) in the request’s Authorization header as a Bearer token.

Please note that all other business services require the access token in the Bearer header, while the bucket service expects a bucket token because it is login-agnostic. Ensure you manage the required token injection properly; any auth interceptor should not replace the bucket token with the access token.

**User Bucket**
This bucket stores public user files for each user.

When a user logs in—or in the `/currentuser` response—there is a `userBucketToken` to use when sending user-related public files to the bucket service.

```json
{
  //...
  "userBucketToken": "e56d...."
}
```

To upload a file

`POST {baseUrl}/bucket/upload`

The request body is form-data which includes the `bucketId` and the file binary in the `files` field.

```js
{
    bucketId: "{userId}-public-user-bucket",
    files: {binary}
}
```

Response status is 200 on success, e.g., body:

```json
{
    "success": true,
    "data": [
        {
            "fileId": "9da03f6d-0409-41ad-bb06-225a244ae408",
            "originalName": "test (10).png",
            "mimeType": "image/png",
            "size": 604063,
            "status": "uploaded",
            "bucketName": "f7103b85-fcda-4dec-92c6-c336f71fd3a2-public-user-bucket",
            "isPublic": true,
            "downloadUrl": "https://babilcom.mindbricks.co/bucket/download/9da03f6d-0409-41ad-bb06-225a244ae408"
        }
    ]
}
```

To download a file from the bucket, you need its `fileId`. If you upload an avatar or other asset, ensure the download URL or the `fileId` is stored in the backend.

Buckets are mostly used in object creations that require an additional file, such as a product image or user avatar. After uploading your image to the bucket, insert the returned download URL into the related property of the target object record.

**Application Bucket**

This Fintrack application also includes a common public bucket that anyone can read, but only users with the `superAdmin`, `admin`, or `saasAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `applicationBucketToken` field, which is used when uploading any file to the application bucket.

```json
{
  //...
  "applicationBucketToken": "e23fd...."
}
```

The common public application bucket ID is

`"fintrack-public-common-bucket"`

In certain admin areas—such as product management pages—since the user already has the application bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the application bucket using this bucket token whenever needed.



**Business Bucket (Tenant Bucket)**

This Fintrack application also includes a public bucket for each business that anyone can read, but only users with the `tenantOwner` or `tenantAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `tenantBucketToken` field, which is used when uploading any file to the tenant bucket.

```json
{
  //...
  "tenantBucketToken": "e23fd...."
}
```

The common public tenant bucket ID is

`"fintrack-{tenantCodename}-public-tenant-bucket"`

In certain admin areas—such as product management pages—since the user already has the tenant bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the tenant bucket using this bucket token whenever needed.



**Object Buckets**
Some objects may also return a bucket token for uploading or accessing files related to that object. For example, in a project management application, when you fetch a project’s data, a public or private bucket token may be provided to upload or download project-related files.

These buckets will be used as described in the relevant object definitions.


## Expense Data Object

Represents a general expense not tied to any invoice, always scoped to a single business. Can be categorized, linked (optionally) to a supplier, and used in future financial analysis. All fields support Unicode, amount is always in business-relevant currency.

### Expense  Data Object Frontend Description By The Backend Architect

Each expense entry should be presented in UIs with clear fields: date, amount (+currency), category, and description. Notes are for internal staff/owner use (not public/customer facing). If supplier present, display supplier's name as a link. UX for entry and display should guide the user that not all expenses require a supplier, and strong category/filtering/search UX is recommended for reports. Data is never shared outside the business context, and no expense here is linked directly to any invoice.


### Expense Data Object Properties

Expense data object has got following properties that are represented as table fields in the database scheme. 
These properties don't stand just for data storage, but each may have different settings to manage the business logic. 

| Property | Type | IsArray | Required | Description |
|----------|------|---------|----------|-------------|
| `amount` | Double | false | Yes | Expense amount (must be positive, required). |
| `category` | String | false | Yes | Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future. |
| `currency` | String | false | Yes | ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support. |
| `date` | Date | false | Yes | Date the expense occurred. Required for reporting, sorting, and filtering. |
| `description` | String | false | Yes | Required human-readable description of the expense (e.g., purpose or detail). |
| `notes` | Text | false | No | Internal notes/justification—never exposed to public/customers. Optional. |
| `supplierId` | ID | false | No | Optional link to a known supplier. May be null/omitted for uncategorized/general expenses. |
| `businessId` | ID | false | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value, formula or session bind is set.




### Relation Properties

`supplierId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
The relations may reference to a data object either in this service or in another service. Id the reference is remote, backend handles the relations through service communication or elastic search.
These relations should be respected in the frontend so that instaead of showing the related objects id, the frontend should list human readable values from other data objects.
If the relation points to another service, frontend should use the referenced service api in case it needs related data.
The relation logic is montly handled in backend so the api responses feeds the frontend about the relational data. 
In mmost cases the api response will provide the relational data as well as the main one.

In frontend, please ensure that, 

1- instaead of these relational ids you show the main human readable field of the related target data (like name),
2- if this data object needs a user input of these relational ids, you should provide a combobox with the list of possible records or (a searchbox) to select with the realted target data object main human readable field.


- **supplierId**: ID
Relation to `supplier`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

Required: No


### Filter Properties

`amount` `category` `currency` `date` `description` `supplierId` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's.

- **amount**: Double  has a filter named `amount`

- **category**: String  has a filter named `category`

- **currency**: String  has a filter named `currency`

- **date**: Date  has a filter named `date`

- **description**: String  has a filter named `description`

- **supplierId**: ID  has a filter named `supplierId`

- **businessId**: ID  has a filter named `businessId`



## API Reference

### `Create Expense` API
Create a new expense entry for the current business. Owner/Accountant roles required. Inputs: date, amount, currency, category, description, optional supplierId, notes. Validates positivity. Returns created expense.

**API Frontend Description By The Backend Architect**

Provide an expense creation form with required fields (date, amount, currency, category, description), optional supplier search/link, and notes. Role-based access: only Owner/Accountant may create expenses. UX should validate positive amount and require fields before submit.

**Rest Route**

The `createExpense` API REST controller can be triggered via the following route:

`/v1/expenses`


**Rest Request Parameters**


The `createExpense` api has got 7 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| amount  | Double  | true | request.body?.["amount"] |
| category  | String  | true | request.body?.["category"] |
| currency  | String  | true | request.body?.["currency"] |
| date  | Date  | true | request.body?.["date"] |
| description  | String  | true | request.body?.["description"] |
| notes  | Text  | false | request.body?.["notes"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |
**amount** : Expense amount (must be positive, required).
**category** : Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future.
**currency** : ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support.
**date** : Date the expense occurred. Required for reporting, sorting, and filtering.
**description** : Required human-readable description of the expense (e.g., purpose or detail).
**notes** : Internal notes/justification—never exposed to public/customers. Optional.
**supplierId** : Optional link to a known supplier. May be null/omitted for uncategorized/general expenses.


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/expenses**
```js
  axios({
    method: 'POST',
    url: '/v1/expenses',
    data: {
            amount:"Double",  
            category:"String",  
            currency:"String",  
            date:"Date",  
            description:"String",  
            notes:"Text",  
            supplierId:"ID",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"id": "ID",
		"amount": "Double",
		"category": "String",
		"currency": "String",
		"date": "Date",
		"description": "String",
		"notes": "Text",
		"supplierId": "ID",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Expense` API
Soft delete an expense (mark as inactive). Only Owner/Accountant can delete. Expense remains for history/audit; not shown in default lists.

**API Frontend Description By The Backend Architect**

Delete operation is allowed for Owner/Accountant only (no UI access for Users). Deletion is always soft (isActive=false). Do not show deleted expenses in main lists or reports. UI should visually confirm before deletion.

**Rest Route**

The `deleteExpense` API REST controller can be triggered via the following route:

`/v1/expenses/:expenseId`


**Rest Request Parameters**


The `deleteExpense` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| expenseId  | ID  | true | request.params?.["expenseId"] |
**expenseId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/expenses/:expenseId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/expenses/${expenseId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"id": "ID",
		"amount": "Double",
		"category": "String",
		"currency": "String",
		"date": "Date",
		"description": "String",
		"notes": "Text",
		"supplierId": "ID",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Expense` API
Retrieve a single expense by ID, scoped to current business. Any business user (owner/accountant/user) can view details (for reporting, reference, etc).

**API Frontend Description By The Backend Architect**

Expense detail screens show all fields, supplier name if present (lookup), and notes where authorized. No editing possible for Users; view only. Owner/Accountant may then open update/delete screens from here. Supplier (if present) should present full supplier name/details in details UX.

**Rest Route**

The `getExpense` API REST controller can be triggered via the following route:

`/v1/expenses/:expenseId`


**Rest Request Parameters**


The `getExpense` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| expenseId  | ID  | true | request.params?.["expenseId"] |
**expenseId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/expenses/:expenseId**
```js
  axios({
    method: 'GET',
    url: `/v1/expenses/${expenseId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"supplier": {
			"address": "Text",
			"contactEmail": "String",
			"contactName": "String",
			"name": "String",
			"phone": "String",
			"taxNumber": "String"
		},
		"isActive": true
	}
}
```
### `List Expenses` API
List expenses for the current business; supports filtering by date range, amount, currency, category, description (search), and supplierId. View access for all business roles. Used for main expense table, reporting, and analysis.

**API Frontend Description By The Backend Architect**

Expense table/report views: allow filtering by date, category, supplier, currency, amount range, and fulltext search on description. Results strictly limited to the user's business. All logged-in business users can list expenses. Pagination and sorting as per UI needs. Export, analytics, and aggregation handled in reporting layer.

**Rest Route**

The `listExpenses` API REST controller can be triggered via the following route:

`/v1/expenses`


**Rest Request Parameters**
The `listExpenses` api has got no request parameters.    



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/expenses**
```js
  axios({
    method: 'GET',
    url: '/v1/expenses',
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expenses",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"expenses": [
		{
			"supplier": [
				{
					"name": "String"
				},
				{},
				{}
			],
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Expense` API
Update an existing expense for current business. Only Owner/Accountant may update. Amount must remain positive; supplier if (re)set, must exist. Returns updated expense.

**API Frontend Description By The Backend Architect**

Expense update form should prefill all fields, allow edit of any but auto restrict negative/empty requireds. Only Owner/Accountant can update expenses. Validate all new values client and server side; supplier link optional but validated if changed.

**Rest Route**

The `updateExpense` API REST controller can be triggered via the following route:

`/v1/expenses/:expenseId`


**Rest Request Parameters**


The `updateExpense` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| expenseId  | ID  | true | request.params?.["expenseId"] |
| amount  | Double  | false | request.body?.["amount"] |
| category  | String  | false | request.body?.["category"] |
| currency  | String  | false | request.body?.["currency"] |
| date  | Date  | false | request.body?.["date"] |
| description  | String  | false | request.body?.["description"] |
| notes  | Text  | false | request.body?.["notes"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |
**expenseId** : This id paremeter is used to select the required data object that will be updated
**amount** : Expense amount (must be positive, required).
**category** : Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future.
**currency** : ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support.
**date** : Date the expense occurred. Required for reporting, sorting, and filtering.
**description** : Required human-readable description of the expense (e.g., purpose or detail).
**notes** : Internal notes/justification—never exposed to public/customers. Optional.
**supplierId** : Optional link to a known supplier. May be null/omitted for uncategorized/general expenses.


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/expenses/:expenseId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/expenses/${expenseId}`,
    data: {
            amount:"Double",  
            category:"String",  
            currency:"String",  
            date:"Date",  
            description:"String",  
            notes:"Text",  
            supplierId:"ID",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"id": "ID",
		"amount": "Double",
		"category": "String",
		"currency": "String",
		"date": "Date",
		"description": "String",
		"notes": "Text",
		"supplierId": "ID",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `_fetch Listexpense` API
System API to fetch list of expense records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListExpense` API REST controller can be triggered via the following route:

`/v1/_fetchlistexpense`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListExpense` api supports 6 optional filter parameters for filtering list results:

**amount** (`Double`): Expense amount (must be positive, required).

- Single: `?amount=<value>`
- Multiple: `?amount=<value1>&amount=<value2>`
- Range: `?amount=$lt-<value>`, `$lte-`, `$gt-`, `$gte-`, `$btw-<min>-<max>`
- Null: `?amount=null`


**category** (`String`): Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future.

- Single (partial match, case-insensitive): `?category=<value>`
- Multiple: `?category=<value1>&category=<value2>`
- Null: `?category=null`


**currency** (`String`): ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support.

- Single (partial match, case-insensitive): `?currency=<value>`
- Multiple: `?currency=<value1>&currency=<value2>`
- Null: `?currency=null`


**date** (`Date`): Date the expense occurred. Required for reporting, sorting, and filtering.

- Single date: `?date=2024-01-15`
- Multiple dates: `?date=2024-01-15&date=2024-01-20`
- Special: `$today`, `$ltoday`, `$week`, `$lweek`, `$month`, `$leq-<date>`, `$lin-<date>`
- Null: `?date=null`


**description** (`String`): Required human-readable description of the expense (e.g., purpose or detail).

- Single (partial match, case-insensitive): `?description=<value>`
- Multiple: `?description=<value1>&description=<value2>`
- Null: `?description=null`


**supplierId** (`ID`): Optional link to a known supplier. May be null/omitted for uncategorized/general expenses.

- Single: `?supplierId=<value>`
- Multiple: `?supplierId=<value1>&supplierId=<value2>`
- Null: `?supplierId=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistexpense**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistexpense',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // amount: '<value>' // Filter by amount
        // category: '<value>' // Filter by category
        // currency: '<value>' // Filter by currency
        // date: '<value>' // Filter by date
        // description: '<value>' // Filter by description
        // supplierId: '<value>' // Filter by supplierId
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expenses",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"expenses": [
		{
			"id": "ID",
			"amount": "Double",
			"category": "String",
			"currency": "String",
			"date": "Date",
			"description": "String",
			"notes": "Text",
			"supplierId": "ID",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"supplier": [
				{
					"address": "Text",
					"contactEmail": "String",
					"contactName": "String",
					"name": "String",
					"notes": "Text",
					"phone": "String",
					"taxNumber": "String"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```

**After this prompt, the user may give you new instructions to update the output of this prompt or provide subsequent prompts about the project.**




---

<a id="frontend-prompts-frontend-prompt-7-invoicemanagementservice"></a>

## InvoiceManagement Service



# **FINTRACK**

**FRONTEND GUIDE FOR AI CODING AGENTS - PART 7 - InvoiceManagement Service**

This document is a part of a REST API guide for the fintrack project.
It is designed for AI agents that will generate frontend code to consume the project’s backend.

This document provides extensive instruction for the usage of invoiceManagement

## Service Access

InvoiceManagement service management is handled through service specific base urls.

InvoiceManagement  service may be deployed to the preview server, staging server, or production server. Therefore,it has 3 access URLs.
The frontend application must support all deployment environments during development, and the user should be able to select the target API server on the login page (already handled in first part.).

For the invoiceManagement service, the base URLs are:

* **Preview:** `https://fintrack.prw.mindbricks.com/invoicemanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/invoicemanagement-api`
* **Production:** `https://fintrack.mindbricks.co/invoicemanagement-api`

## Scope

**InvoiceManagement Service Description**

Handles creation and modification of all sales (outgoing) and purchase (incoming) invoices for FinTrack SMBs. Supports multi-item entry per invoice, VAT at item level, detailed filtering, and status calculation based on payments and due dates. Strictly scoped to a single business context.

InvoiceManagement service provides apis and business logic for following data objects in fintrack application. 
Each data object may be either a central domain of the application data structure or a related helper data object for a central concept.
Note that data object concept is equal to table concept in the database, in the service database each data object is represented as a db table scheme and the object instances as table rows.  


**`invoice` Data Object**: Represents a single sales or purchase invoice document for a business. Contains summary information, partner (customer/supplier), and status derived from payments and dates.

**`invoiceItem` Data Object**: Represents a single line item in an invoice, with product/service linkage, quantity, pricing, VAT, and per-line total.


## InvoiceManagement Service Frontend Description By The Backend Architect

This service is responsible for the entire invoice lifecycle in FinTrack. The frontend must support clear separation between sales (outgoing) and purchase (incoming) invoices, with dynamic fields for partner (customer/supplier) based on invoice type. Invoices require detailed line items (with product/service lookup and VAT per line). The UI should allow easy filtering/searching by type/status/date/partner and always synchronize status based on recent payments. All forms and views must enforce strict business scoping and granular access per user role.

## API Structure

### Object Structure of a Successful Response

When the service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope includes the data and essential metadata such as configuration details and pagination information, providing context to the client.

**HTTP Status Codes:**

* **200 OK**: Returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request was processed successfully.
* **201 Created**: Returned for CREATE operations, indicating that the resource was created successfully.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling that the request executed successfully. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3,
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
```
* **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation.

### Additional Data

Each API may include additional data besides the main data object, depending on the business logic of the API. These will be provided in each API’s response signature.

### Error Response

If a request encounters an issue—whether due to a logical fault or a technical problem—the service responds with a standardized JSON error structure. The HTTP status code indicates the nature of the error, using commonly recognized codes for clarity:

* **400 Bad Request**: The request was improperly formatted or contained invalid parameters.
* **401 Unauthorized**: The request lacked a valid authentication token; login is required.
* **403 Forbidden**: The current token does not grant access to the requested resource.
* **404 Not Found**: The requested resource was not found on the server.
* **500 Internal Server Error**: The server encountered an unexpected condition.

Each error response is structured to provide meaningful insight into the problem, assisting in efficient diagnosis and resolution.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```

## Bucket Management

(This information is also given in PART 1 prompt.)

This application has a bucket service used to store user files and other object-related files. The bucket service is login-agnostic, so for write operations or private reads, include a bucket token (provided by services) in the request’s Authorization header as a Bearer token.

Please note that all other business services require the access token in the Bearer header, while the bucket service expects a bucket token because it is login-agnostic. Ensure you manage the required token injection properly; any auth interceptor should not replace the bucket token with the access token.

**User Bucket**
This bucket stores public user files for each user.

When a user logs in—or in the `/currentuser` response—there is a `userBucketToken` to use when sending user-related public files to the bucket service.

```json
{
  //...
  "userBucketToken": "e56d...."
}
```

To upload a file

`POST {baseUrl}/bucket/upload`

The request body is form-data which includes the `bucketId` and the file binary in the `files` field.

```js
{
    bucketId: "{userId}-public-user-bucket",
    files: {binary}
}
```

Response status is 200 on success, e.g., body:

```json
{
    "success": true,
    "data": [
        {
            "fileId": "9da03f6d-0409-41ad-bb06-225a244ae408",
            "originalName": "test (10).png",
            "mimeType": "image/png",
            "size": 604063,
            "status": "uploaded",
            "bucketName": "f7103b85-fcda-4dec-92c6-c336f71fd3a2-public-user-bucket",
            "isPublic": true,
            "downloadUrl": "https://babilcom.mindbricks.co/bucket/download/9da03f6d-0409-41ad-bb06-225a244ae408"
        }
    ]
}
```

To download a file from the bucket, you need its `fileId`. If you upload an avatar or other asset, ensure the download URL or the `fileId` is stored in the backend.

Buckets are mostly used in object creations that require an additional file, such as a product image or user avatar. After uploading your image to the bucket, insert the returned download URL into the related property of the target object record.

**Application Bucket**

This Fintrack application also includes a common public bucket that anyone can read, but only users with the `superAdmin`, `admin`, or `saasAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `applicationBucketToken` field, which is used when uploading any file to the application bucket.

```json
{
  //...
  "applicationBucketToken": "e23fd...."
}
```

The common public application bucket ID is

`"fintrack-public-common-bucket"`

In certain admin areas—such as product management pages—since the user already has the application bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the application bucket using this bucket token whenever needed.



**Business Bucket (Tenant Bucket)**

This Fintrack application also includes a public bucket for each business that anyone can read, but only users with the `tenantOwner` or `tenantAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `tenantBucketToken` field, which is used when uploading any file to the tenant bucket.

```json
{
  //...
  "tenantBucketToken": "e23fd...."
}
```

The common public tenant bucket ID is

`"fintrack-{tenantCodename}-public-tenant-bucket"`

In certain admin areas—such as product management pages—since the user already has the tenant bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the tenant bucket using this bucket token whenever needed.



**Object Buckets**
Some objects may also return a bucket token for uploading or accessing files related to that object. For example, in a project management application, when you fetch a project’s data, a public or private bucket token may be provided to upload or download project-related files.

These buckets will be used as described in the relevant object definitions.


## Invoice Data Object

Represents a single sales or purchase invoice document for a business. Contains summary information, partner (customer/supplier), and status derived from payments and dates.

### Invoice  Data Object Frontend Description By The Backend Architect

Invoices are the core objects: always show invoice type (sales/purchase) clearly. Display customer (for sales) or supplier (for purchase) information. Status and total should always update based on items and payment history. Actions/buttons for creating payments and managing items are context-aware based on role and invoice type.


### Invoice Data Object Properties

Invoice data object has got following properties that are represented as table fields in the database scheme. 
These properties don't stand just for data storage, but each may have different settings to manage the business logic. 

| Property | Type | IsArray | Required | Description |
|----------|------|---------|----------|-------------|
| `currency` | String | false | Yes | Currency code for all values in invoice and its items (e.g., 'USD'). |
| `customerId` | ID | false | No | Referenced customer (for sales invoice; null for purchase invoice). |
| `dueDate` | Date | false | Yes | Date by which payment for this invoice is due. |
| `invoiceNumber` | String | false | Yes | A unique identifier (number/code) for this invoice within a business. |
| `issueDate` | Date | false | Yes | Date this invoice was issued. |
| `notes` | Text | false | No | Internal notes about the invoice, never publicly exposed. |
| `status` | Enum | false | Yes | Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate. |
| `supplierId` | ID | false | No | Referenced supplier (for purchase invoice; null for sales invoice). |
| `totalAmount` | Double | false | Yes | Grand total for invoice (sum of line item totals, including VAT). Calculated; always up-to-date. |
| `type` | Enum | false | Yes | Invoice nature; 'sales'=outgoing, 'purchase'=incoming. |
| `businessId` | ID | false | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value, formula or session bind is set.



### Enum Properties
Enum properties are defined with a set of allowed values, ensuring that only valid options can be assigned to them. 
The enum options value will be stored as strings in the database, 
but when a data object is created an additional property with the same name plus an idx suffix will be created, which will hold the index of the selected enum option.
You can use the {fieldName_idx} property to sort by the enum value or when your enum options represent a hiyerarchy of values.
In the frontend input components, enum type properties should only accept values from an option component that lists the enum options.

- **status**: [unpaid, partial, paid, overdue]

- **type**: [sales, purchase]


### Relation Properties

`customerId` `supplierId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
The relations may reference to a data object either in this service or in another service. Id the reference is remote, backend handles the relations through service communication or elastic search.
These relations should be respected in the frontend so that instaead of showing the related objects id, the frontend should list human readable values from other data objects.
If the relation points to another service, frontend should use the referenced service api in case it needs related data.
The relation logic is montly handled in backend so the api responses feeds the frontend about the relational data. 
In mmost cases the api response will provide the relational data as well as the main one.

In frontend, please ensure that, 

1- instaead of these relational ids you show the main human readable field of the related target data (like name),
2- if this data object needs a user input of these relational ids, you should provide a combobox with the list of possible records or (a searchbox) to select with the realted target data object main human readable field.


- **customerId**: ID
Relation to `customer`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

Required: No

- **supplierId**: ID
Relation to `supplier`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

Required: No


### Filter Properties

`customerId` `dueDate` `invoiceNumber` `issueDate` `status` `supplierId` `type` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's.

- **customerId**: ID  has a filter named `customerId`

- **dueDate**: Date  has a filter named `dueDate`

- **invoiceNumber**: String  has a filter named `invoiceNumber`

- **issueDate**: Date  has a filter named `issueDate`

- **status**: Enum  has a filter named `status`

- **supplierId**: ID  has a filter named `supplierId`

- **type**: Enum  has a filter named `type`

- **businessId**: ID  has a filter named `businessId`


## InvoiceItem Data Object

Represents a single line item in an invoice, with product/service linkage, quantity, pricing, VAT, and per-line total.

### InvoiceItem  Data Object Frontend Description By The Backend Architect

Invoice items must allow product/service lookup (with available data shown). Quantity, unit price, VAT entry are allowed, but VAT defaults from product config. Total and VAT are automatically calculated as properties. Items are only manageable by roles permitted to update their invoice.


### InvoiceItem Data Object Properties

InvoiceItem data object has got following properties that are represented as table fields in the database scheme. 
These properties don't stand just for data storage, but each may have different settings to manage the business logic. 

| Property | Type | IsArray | Required | Description |
|----------|------|---------|----------|-------------|
| `description` | String | false | No | Optional text/override for item description (default: product/service name). |
| `invoiceId` | ID | false | Yes | Reference to parent invoice (ensures item belongs to this invoice). |
| `productOrServiceId` | ID | false | Yes | Reference to product/service used in this line item. |
| `quantity` | Double | false | Yes | Quantity of product/service being invoiced. |
| `total` | Double | false | Yes | Line total (unit price * quantity + VAT Amount); calculated. |
| `unitPrice` | Double | false | Yes | The (net) unit price for this item (auto-fetched from product/service at time of insert, overridable). |
| `vatAmount` | Double | false | Yes | Computed VAT amount for this invoice item. |
| `vatRate` | Double | false | Yes | VAT rate (%) applied for this item (auto-fetched from product/service, overridable if allowed). |
| `businessId` | ID | false | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value, formula or session bind is set.




### Relation Properties

`invoiceId` `productOrServiceId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
The relations may reference to a data object either in this service or in another service. Id the reference is remote, backend handles the relations through service communication or elastic search.
These relations should be respected in the frontend so that instaead of showing the related objects id, the frontend should list human readable values from other data objects.
If the relation points to another service, frontend should use the referenced service api in case it needs related data.
The relation logic is montly handled in backend so the api responses feeds the frontend about the relational data. 
In mmost cases the api response will provide the relational data as well as the main one.

In frontend, please ensure that, 

1- instaead of these relational ids you show the main human readable field of the related target data (like name),
2- if this data object needs a user input of these relational ids, you should provide a combobox with the list of possible records or (a searchbox) to select with the realted target data object main human readable field.


- **invoiceId**: ID
Relation to `invoice`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

Required: Yes

- **productOrServiceId**: ID
Relation to `productOrService`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

Required: Yes


### Filter Properties

`invoiceId` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's.

- **invoiceId**: ID  has a filter named `invoiceId`

- **businessId**: ID  has a filter named `businessId`



## API Reference

### `Create Invoice` API
Create a new invoice (sales or purchase), require proper partner, auto-status, and initialize with/without items. Owner or Accountant only.

**API Frontend Description By The Backend Architect**

UI must prompt for invoice type first; if type=sales require customer; if type=purchase require supplier. Line items can be added inline or after main invoice save. Save triggers recalculation of total and default status to unpaid. Allow adding notes.

**Rest Route**

The `createInvoice` API REST controller can be triggered via the following route:

`/v1/invoices`


**Rest Request Parameters**


The `createInvoice` api has got 9 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| currency  | String  | true | request.body?.["currency"] |
| customerId  | ID  | false | request.body?.["customerId"] |
| dueDate  | Date  | true | request.body?.["dueDate"] |
| invoiceNumber  | String  | true | request.body?.["invoiceNumber"] |
| issueDate  | Date  | true | request.body?.["issueDate"] |
| notes  | Text  | false | request.body?.["notes"] |
| status  | Enum  | true | request.body?.["status"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |
| type  | Enum  | true | request.body?.["type"] |
**currency** : Currency code for all values in invoice and its items (e.g., 'USD').
**customerId** : Referenced customer (for sales invoice; null for purchase invoice).
**dueDate** : Date by which payment for this invoice is due.
**invoiceNumber** : A unique identifier (number/code) for this invoice within a business.
**issueDate** : Date this invoice was issued.
**notes** : Internal notes about the invoice, never publicly exposed.
**status** : Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate.
**supplierId** : Referenced supplier (for purchase invoice; null for sales invoice).
**type** : Invoice nature; 'sales'=outgoing, 'purchase'=incoming.


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/invoices**
```js
  axios({
    method: 'POST',
    url: '/v1/invoices',
    data: {
            currency:"String",  
            customerId:"ID",  
            dueDate:"Date",  
            invoiceNumber:"String",  
            issueDate:"Date",  
            notes:"Text",  
            status:"Enum",  
            supplierId:"ID",  
            type:"Enum",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Create Invoiceitem` API
Create a new line item for an invoice. Only permitted for Owner/Accountant or if user has edit rights for invoice.

**API Frontend Description By The Backend Architect**

Item is created within context of an invoice. Product/service lookup required. Quantity and price editable if business logic allows. VAT is defaulted/calculated and presented. Totals computed automatically.

**Rest Route**

The `createInvoiceItem` API REST controller can be triggered via the following route:

`/v1/invoiceitems`


**Rest Request Parameters**


The `createInvoiceItem` api has got 3 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.body?.["invoiceId"] |
| productOrServiceId  | ID  | true | request.body?.["productOrServiceId"] |
| quantity  | Double  | true | request.body?.["quantity"] |
**invoiceId** : Reference to parent invoice (ensures item belongs to this invoice).
**productOrServiceId** : Reference to product/service used in this line item.
**quantity** : Quantity of product/service being invoiced.


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/invoiceitems**
```js
  axios({
    method: 'POST',
    url: '/v1/invoiceitems',
    data: {
            invoiceId:"ID",  
            productOrServiceId:"ID",  
            quantity:"Double",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Invoice` API
Soft delete/deactivate an invoice (remains for audit/history, removes from normal use). Owner/Accountant only.

**API Frontend Description By The Backend Architect**

Allow delete/deactivation from invoice list/details. Deletion is always soft (record preserved).

**Rest Route**

The `deleteInvoice` API REST controller can be triggered via the following route:

`/v1/invoices/:invoiceId`


**Rest Request Parameters**


The `deleteInvoice` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.params?.["invoiceId"] |
**invoiceId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/invoices/:invoiceId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/invoices/${invoiceId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Invoiceitem` API
Remove an invoice line item. Soft delete by default. Only Owner/Accountant allowed; item remains for reporting/audit.

**API Frontend Description By The Backend Architect**

Delete removes item from invoice's current views but keeps for reporting/history. Adjust totals on invoice accordingly.

**Rest Route**

The `deleteInvoiceItem` API REST controller can be triggered via the following route:

`/v1/invoiceitems/:invoiceItemId`


**Rest Request Parameters**


The `deleteInvoiceItem` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceItemId  | ID  | true | request.params?.["invoiceItemId"] |
**invoiceItemId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/invoiceitems/:invoiceItemId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/invoiceitems/${invoiceItemId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Invoice` API
Fetch a detailed invoice by ID, including all items and partner details. All business users have read access within business context.

**API Frontend Description By The Backend Architect**

Display invoice header, itemized line items, customer (sales) or supplier (purchase) info, summary totals and auto-calculated status. Status should match payments up to the time of request.

**Rest Route**

The `getInvoice` API REST controller can be triggered via the following route:

`/v1/invoices/:invoiceId`


**Rest Request Parameters**


The `getInvoice` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.params?.["invoiceId"] |
**invoiceId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/invoices/:invoiceId**
```js
  axios({
    method: 'GET',
    url: `/v1/invoices/${invoiceId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID",
		"items": [
			{
				"description": "String",
				"quantity": "Double",
				"total": "Double",
				"unitPrice": "Double",
				"vatAmount": "Double",
				"vatRate": "Double"
			},
			{},
			{}
		],
		"customer": {
			"contactEmail": "String",
			"contactName": "String",
			"name": "String"
		},
		"supplier": {
			"contactEmail": "String",
			"contactName": "String",
			"name": "String"
		}
	}
}
```
### `Get Invoiceitem` API
Get details for a single invoice item (line details with product/service info). All business users have access within scope (for invoice display and workflows).

**API Frontend Description By The Backend Architect**

Show item description, product/service name, quantity, unit price, VAT, and subtotal/total (with calculations). Allow link to product/service catalog for further details.

**Rest Route**

The `getInvoiceItem` API REST controller can be triggered via the following route:

`/v1/invoiceitems/:invoiceItemId`


**Rest Request Parameters**


The `getInvoiceItem` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceItemId  | ID  | true | request.params?.["invoiceItemId"] |
**invoiceItemId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/invoiceitems/:invoiceItemId**
```js
  axios({
    method: 'GET',
    url: `/v1/invoiceitems/${invoiceItemId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID",
		"productOrService": {
			"currency": "String",
			"name": "String",
			"price": "Double",
			"sku": "String",
			"type": "Enum",
			"type_idx": "Integer",
			"vatRate": "Double"
		}
	}
}
```
### `List Invoiceitems` API
List all line items for given invoice or with filter. Used for invoice display, checks, audits. All business roles permitted to read within tenant scope.

**API Frontend Description By The Backend Architect**

Present all invoice items for invoice details screen, permit search by invoice, product/service or description; paginate for large sets. Enable inline item addition (if permitted).

**Rest Route**

The `listInvoiceItems` API REST controller can be triggered via the following route:

`/v1/invoiceitems`


**Rest Request Parameters**


**Filter Parameters**

The `listInvoiceItems` api supports 1 optional filter parameter for filtering list results:

**invoiceId** (`ID`): Reference to parent invoice (ensures item belongs to this invoice).

- Single: `?invoiceId=<value>`
- Multiple: `?invoiceId=<value1>&invoiceId=<value2>`
- Null: `?invoiceId=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/invoiceitems**
```js
  axios({
    method: 'GET',
    url: '/v1/invoiceitems',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // invoiceId: '<value>' // Filter by invoiceId
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItems",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoiceItems": [
		{
			"id": "ID",
			"description": "String",
			"invoiceId": "ID",
			"productOrServiceId": "ID",
			"quantity": "Double",
			"total": "Double",
			"unitPrice": "Double",
			"vatAmount": "Double",
			"vatRate": "Double",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"productOrService": [
				{
					"currency": "String",
					"name": "String",
					"price": "Double",
					"sku": "String",
					"type": "Enum",
					"type_idx": "Integer",
					"vatRate": "Double"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `List Invoices` API
List/search invoices for the current business, with filtering by type, date, partner, and status. All business users may view within context.

**API Frontend Description By The Backend Architect**

Show invoice list with filtering/search by type, partner, status, date range (on issueDate/dueDate). Display summary fields and enable quick navigation to invoice details or edit (if permitted).

**Rest Route**

The `listInvoices` API REST controller can be triggered via the following route:

`/v1/invoices`


**Rest Request Parameters**


**Filter Parameters**

The `listInvoices` api supports 7 optional filter parameters for filtering list results:

**customerId** (`ID`): Referenced customer (for sales invoice; null for purchase invoice).

- Single: `?customerId=<value>`
- Multiple: `?customerId=<value1>&customerId=<value2>`
- Null: `?customerId=null`


**dueDate** (`Date`): Date by which payment for this invoice is due.

- Single date: `?dueDate=2024-01-15`
- Multiple dates: `?dueDate=2024-01-15&dueDate=2024-01-20`
- Special: `$today`, `$ltoday`, `$week`, `$lweek`, `$month`, `$leq-<date>`, `$lin-<date>`
- Null: `?dueDate=null`


**invoiceNumber** (`String`): A unique identifier (number/code) for this invoice within a business.

- Single (partial match, case-insensitive): `?invoiceNumber=<value>`
- Multiple: `?invoiceNumber=<value1>&invoiceNumber=<value2>`
- Null: `?invoiceNumber=null`


**issueDate** (`Date`): Date this invoice was issued.

- Single date: `?issueDate=2024-01-15`
- Multiple dates: `?issueDate=2024-01-15&issueDate=2024-01-20`
- Special: `$today`, `$ltoday`, `$week`, `$lweek`, `$month`, `$leq-<date>`, `$lin-<date>`
- Null: `?issueDate=null`


**status** (`Enum`): Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate.

- Single: `?status=<value>` (case-insensitive)
- Multiple: `?status=<value1>&status=<value2>`
- Null: `?status=null`


**supplierId** (`ID`): Referenced supplier (for purchase invoice; null for sales invoice).

- Single: `?supplierId=<value>`
- Multiple: `?supplierId=<value1>&supplierId=<value2>`
- Null: `?supplierId=null`


**type** (`Enum`): Invoice nature; 'sales'=outgoing, 'purchase'=incoming.

- Single: `?type=<value>` (case-insensitive)
- Multiple: `?type=<value1>&type=<value2>`
- Null: `?type=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/invoices**
```js
  axios({
    method: 'GET',
    url: '/v1/invoices',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // customerId: '<value>' // Filter by customerId
        // dueDate: '<value>' // Filter by dueDate
        // invoiceNumber: '<value>' // Filter by invoiceNumber
        // issueDate: '<value>' // Filter by issueDate
        // status: '<value>' // Filter by status
        // supplierId: '<value>' // Filter by supplierId
        // type: '<value>' // Filter by type
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoices",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoices": [
		{
			"id": "ID",
			"currency": "String",
			"customerId": "ID",
			"dueDate": "Date",
			"invoiceNumber": "String",
			"issueDate": "Date",
			"notes": "Text",
			"status": "Enum",
			"status_idx": "Integer",
			"supplierId": "ID",
			"totalAmount": "Double",
			"type": "Enum",
			"type_idx": "Integer",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"items": [
				{
					"description": "String",
					"quantity": "Double",
					"total": "Double",
					"unitPrice": "Double",
					"vatAmount": "Double",
					"vatRate": "Double"
				},
				{},
				{}
			],
			"customer": [
				{
					"contactEmail": "String",
					"contactName": "String",
					"name": "String"
				},
				{},
				{}
			],
			"supplier": [
				{
					"contactEmail": "String",
					"contactName": "String",
					"name": "String"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Invoice` API
Update invoice details (e.g., dates, partner, notes); recalculate totals and enforce type/partner links. Owner/Accountant only.

**API Frontend Description By The Backend Architect**

Allow editing of fields except invoice type. Changing partner: must match rules (sales: customer; purchase: supplier). Totals always refresh after updating. No direct status edit; status recalculated on payment update.

**Rest Route**

The `updateInvoice` API REST controller can be triggered via the following route:

`/v1/invoices/:invoiceId`


**Rest Request Parameters**


The `updateInvoice` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.params?.["invoiceId"] |
| currency  | String  | true | request.body?.["currency"] |
| customerId  | ID  | false | request.body?.["customerId"] |
| dueDate  | Date  | true | request.body?.["dueDate"] |
| invoiceNumber  | String  | true | request.body?.["invoiceNumber"] |
| issueDate  | Date  | true | request.body?.["issueDate"] |
| notes  | Text  | false | request.body?.["notes"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |
**invoiceId** : This id paremeter is used to select the required data object that will be updated
**currency** : Currency code for all values in invoice and its items (e.g., 'USD').
**customerId** : Referenced customer (for sales invoice; null for purchase invoice).
**dueDate** : Date by which payment for this invoice is due.
**invoiceNumber** : A unique identifier (number/code) for this invoice within a business.
**issueDate** : Date this invoice was issued.
**notes** : Internal notes about the invoice, never publicly exposed.
**supplierId** : Referenced supplier (for purchase invoice; null for sales invoice).


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/invoices/:invoiceId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/invoices/${invoiceId}`,
    data: {
            currency:"String",  
            customerId:"ID",  
            dueDate:"Date",  
            invoiceNumber:"String",  
            issueDate:"Date",  
            notes:"Text",  
            supplierId:"ID",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Update Invoiceitem` API
Update an existing invoice line item (description, quantity, unit price, VAT). Owner/Accountant only.

**API Frontend Description By The Backend Architect**

Editable fields: description, quantity, unitPrice, vatRate. Totals/VAT recalc on any change. Editing productOrServiceId updates downstream values. UI should limit changes if invoice is paid/partial/overdue.

**Rest Route**

The `updateInvoiceItem` API REST controller can be triggered via the following route:

`/v1/invoiceitems/:invoiceItemId`


**Rest Request Parameters**


The `updateInvoiceItem` api has got 3 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceItemId  | ID  | true | request.params?.["invoiceItemId"] |
| productOrServiceId  | ID  | true | request.body?.["productOrServiceId"] |
| quantity  | Double  | true | request.body?.["quantity"] |
**invoiceItemId** : This id paremeter is used to select the required data object that will be updated
**productOrServiceId** : Reference to product/service used in this line item.
**quantity** : Quantity of product/service being invoiced.


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/invoiceitems/:invoiceItemId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/invoiceitems/${invoiceItemId}`,
    data: {
            productOrServiceId:"ID",  
            quantity:"Double",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `_fetch Listinvoice` API
System API to fetch list of invoice records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListInvoice` API REST controller can be triggered via the following route:

`/v1/_fetchlistinvoice`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListInvoice` api supports 7 optional filter parameters for filtering list results:

**customerId** (`ID`): Referenced customer (for sales invoice; null for purchase invoice).

- Single: `?customerId=<value>`
- Multiple: `?customerId=<value1>&customerId=<value2>`
- Null: `?customerId=null`


**dueDate** (`Date`): Date by which payment for this invoice is due.

- Single date: `?dueDate=2024-01-15`
- Multiple dates: `?dueDate=2024-01-15&dueDate=2024-01-20`
- Special: `$today`, `$ltoday`, `$week`, `$lweek`, `$month`, `$leq-<date>`, `$lin-<date>`
- Null: `?dueDate=null`


**invoiceNumber** (`String`): A unique identifier (number/code) for this invoice within a business.

- Single (partial match, case-insensitive): `?invoiceNumber=<value>`
- Multiple: `?invoiceNumber=<value1>&invoiceNumber=<value2>`
- Null: `?invoiceNumber=null`


**issueDate** (`Date`): Date this invoice was issued.

- Single date: `?issueDate=2024-01-15`
- Multiple dates: `?issueDate=2024-01-15&issueDate=2024-01-20`
- Special: `$today`, `$ltoday`, `$week`, `$lweek`, `$month`, `$leq-<date>`, `$lin-<date>`
- Null: `?issueDate=null`


**status** (`Enum`): Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate.

- Single: `?status=<value>` (case-insensitive)
- Multiple: `?status=<value1>&status=<value2>`
- Null: `?status=null`


**supplierId** (`ID`): Referenced supplier (for purchase invoice; null for sales invoice).

- Single: `?supplierId=<value>`
- Multiple: `?supplierId=<value1>&supplierId=<value2>`
- Null: `?supplierId=null`


**type** (`Enum`): Invoice nature; 'sales'=outgoing, 'purchase'=incoming.

- Single: `?type=<value>` (case-insensitive)
- Multiple: `?type=<value1>&type=<value2>`
- Null: `?type=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistinvoice**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistinvoice',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // customerId: '<value>' // Filter by customerId
        // dueDate: '<value>' // Filter by dueDate
        // invoiceNumber: '<value>' // Filter by invoiceNumber
        // issueDate: '<value>' // Filter by issueDate
        // status: '<value>' // Filter by status
        // supplierId: '<value>' // Filter by supplierId
        // type: '<value>' // Filter by type
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoices",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoices": [
		{
			"id": "ID",
			"currency": "String",
			"customerId": "ID",
			"dueDate": "Date",
			"invoiceNumber": "String",
			"issueDate": "Date",
			"notes": "Text",
			"status": "Enum",
			"status_idx": "Integer",
			"supplierId": "ID",
			"totalAmount": "Double",
			"type": "Enum",
			"type_idx": "Integer",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"customer": [
				{
					"address": "Text",
					"contactEmail": "String",
					"contactName": "String",
					"name": "String",
					"notes": "Text",
					"phone": "String",
					"taxNumber": "String",
					"businessId": "ID"
				},
				{},
				{}
			],
			"supplier": [
				{
					"address": "Text",
					"contactEmail": "String",
					"contactName": "String",
					"name": "String",
					"notes": "Text",
					"phone": "String",
					"taxNumber": "String"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `_fetch Listinvoiceitem` API
System API to fetch list of invoiceItem records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListInvoiceItem` API REST controller can be triggered via the following route:

`/v1/_fetchlistinvoiceitem`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListInvoiceItem` api supports 1 optional filter parameter for filtering list results:

**invoiceId** (`ID`): Reference to parent invoice (ensures item belongs to this invoice).

- Single: `?invoiceId=<value>`
- Multiple: `?invoiceId=<value1>&invoiceId=<value2>`
- Null: `?invoiceId=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistinvoiceitem**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistinvoiceitem',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // invoiceId: '<value>' // Filter by invoiceId
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItems",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoiceItems": [
		{
			"id": "ID",
			"description": "String",
			"invoiceId": "ID",
			"productOrServiceId": "ID",
			"quantity": "Double",
			"total": "Double",
			"unitPrice": "Double",
			"vatAmount": "Double",
			"vatRate": "Double",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"invoice": [
				{
					"currency": "String",
					"customerId": "ID",
					"dueDate": "Date",
					"invoiceNumber": "String",
					"issueDate": "Date",
					"notes": "Text",
					"status": "Enum",
					"status_idx": "Integer",
					"supplierId": "ID",
					"totalAmount": "Double",
					"type": "Enum",
					"type_idx": "Integer"
				},
				{},
				{}
			],
			"productOrService": [
				{
					"currency": "String",
					"description": "Text",
					"name": "String",
					"notes": "Text",
					"price": "Double",
					"sku": "String",
					"type": "Enum",
					"type_idx": "Integer",
					"vatRate": "Double"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```

**After this prompt, the user may give you new instructions to update the output of this prompt or provide subsequent prompts about the project.**




---

<a id="frontend-prompts-frontend-prompt-8-paymentmanagementservice"></a>

## PaymentManagement Service



# **FINTRACK**

**FRONTEND GUIDE FOR AI CODING AGENTS - PART 8 - PaymentManagement Service**

This document is a part of a REST API guide for the fintrack project.
It is designed for AI agents that will generate frontend code to consume the project’s backend.

This document provides extensive instruction for the usage of paymentManagement

## Service Access

PaymentManagement service management is handled through service specific base urls.

PaymentManagement  service may be deployed to the preview server, staging server, or production server. Therefore,it has 3 access URLs.
The frontend application must support all deployment environments during development, and the user should be able to select the target API server on the login page (already handled in first part.).

For the paymentManagement service, the base URLs are:

* **Preview:** `https://fintrack.prw.mindbricks.com/paymentmanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/paymentmanagement-api`
* **Production:** `https://fintrack.mindbricks.co/paymentmanagement-api`

## Scope

**PaymentManagement Service Description**

Handles recording and lifecycle management of payments for invoices or as general/unallocated entries. Ensures invoice payment state is synchronized after each payment operation, supports strict business (tenant) isolation, and underpins core financial workflows in FinTrack.

PaymentManagement service provides apis and business logic for following data objects in fintrack application. 
Each data object may be either a central domain of the application data structure or a related helper data object for a central concept.
Note that data object concept is equal to table concept in the database, in the service database each data object is represented as a db table scheme and the object instances as table rows.  


**`payment` Data Object**: Represents any payment (linked to an invoice or general/unallocated) made or received by the business. Tracks linkage, amount, method, payer, and reference. Tenant-isolated. Triggers invoice status recalculation on changes.


## PaymentManagement Service Frontend Description By The Backend Architect

# paymentManagement Service UX Guidance
- Payments are always scoped to a business. Never show, allow, or process payments outside user's business context.
- Creating a payment can optionally associate it with an invoice (for linked settlements) or leave it unassociated (advance/unlinked payment).
- After each payment is created, updated, or deleted, frontend should expect that related invoice status may change (e.g., become paid or partial)—refresh linked invoice views as needed.
- List and detail screens for payments should display invoice number and status if available, else indicate 'General Payment'.
- Payments should be filterable by date, amount, method, invoice/linkage, payer name, description/reference in frontend grids/reports.
- If payment is linked to invoice, show that context (customer/supplier, due date, etc). Allow drill-down from payment record to invoice detail where UX permits.
- Notes field can be multiline. Support for Unicode entry everywhere.


## API Structure

### Object Structure of a Successful Response

When the service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope includes the data and essential metadata such as configuration details and pagination information, providing context to the client.

**HTTP Status Codes:**

* **200 OK**: Returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request was processed successfully.
* **201 Created**: Returned for CREATE operations, indicating that the resource was created successfully.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling that the request executed successfully. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3,
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
```
* **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation.

### Additional Data

Each API may include additional data besides the main data object, depending on the business logic of the API. These will be provided in each API’s response signature.

### Error Response

If a request encounters an issue—whether due to a logical fault or a technical problem—the service responds with a standardized JSON error structure. The HTTP status code indicates the nature of the error, using commonly recognized codes for clarity:

* **400 Bad Request**: The request was improperly formatted or contained invalid parameters.
* **401 Unauthorized**: The request lacked a valid authentication token; login is required.
* **403 Forbidden**: The current token does not grant access to the requested resource.
* **404 Not Found**: The requested resource was not found on the server.
* **500 Internal Server Error**: The server encountered an unexpected condition.

Each error response is structured to provide meaningful insight into the problem, assisting in efficient diagnosis and resolution.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```

## Bucket Management

(This information is also given in PART 1 prompt.)

This application has a bucket service used to store user files and other object-related files. The bucket service is login-agnostic, so for write operations or private reads, include a bucket token (provided by services) in the request’s Authorization header as a Bearer token.

Please note that all other business services require the access token in the Bearer header, while the bucket service expects a bucket token because it is login-agnostic. Ensure you manage the required token injection properly; any auth interceptor should not replace the bucket token with the access token.

**User Bucket**
This bucket stores public user files for each user.

When a user logs in—or in the `/currentuser` response—there is a `userBucketToken` to use when sending user-related public files to the bucket service.

```json
{
  //...
  "userBucketToken": "e56d...."
}
```

To upload a file

`POST {baseUrl}/bucket/upload`

The request body is form-data which includes the `bucketId` and the file binary in the `files` field.

```js
{
    bucketId: "{userId}-public-user-bucket",
    files: {binary}
}
```

Response status is 200 on success, e.g., body:

```json
{
    "success": true,
    "data": [
        {
            "fileId": "9da03f6d-0409-41ad-bb06-225a244ae408",
            "originalName": "test (10).png",
            "mimeType": "image/png",
            "size": 604063,
            "status": "uploaded",
            "bucketName": "f7103b85-fcda-4dec-92c6-c336f71fd3a2-public-user-bucket",
            "isPublic": true,
            "downloadUrl": "https://babilcom.mindbricks.co/bucket/download/9da03f6d-0409-41ad-bb06-225a244ae408"
        }
    ]
}
```

To download a file from the bucket, you need its `fileId`. If you upload an avatar or other asset, ensure the download URL or the `fileId` is stored in the backend.

Buckets are mostly used in object creations that require an additional file, such as a product image or user avatar. After uploading your image to the bucket, insert the returned download URL into the related property of the target object record.

**Application Bucket**

This Fintrack application also includes a common public bucket that anyone can read, but only users with the `superAdmin`, `admin`, or `saasAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `applicationBucketToken` field, which is used when uploading any file to the application bucket.

```json
{
  //...
  "applicationBucketToken": "e23fd...."
}
```

The common public application bucket ID is

`"fintrack-public-common-bucket"`

In certain admin areas—such as product management pages—since the user already has the application bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the application bucket using this bucket token whenever needed.



**Business Bucket (Tenant Bucket)**

This Fintrack application also includes a public bucket for each business that anyone can read, but only users with the `tenantOwner` or `tenantAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `tenantBucketToken` field, which is used when uploading any file to the tenant bucket.

```json
{
  //...
  "tenantBucketToken": "e23fd...."
}
```

The common public tenant bucket ID is

`"fintrack-{tenantCodename}-public-tenant-bucket"`

In certain admin areas—such as product management pages—since the user already has the tenant bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the tenant bucket using this bucket token whenever needed.



**Object Buckets**
Some objects may also return a bucket token for uploading or accessing files related to that object. For example, in a project management application, when you fetch a project’s data, a public or private bucket token may be provided to upload or download project-related files.

These buckets will be used as described in the relevant object definitions.


## Payment Data Object

Represents any payment (linked to an invoice or general/unallocated) made or received by the business. Tracks linkage, amount, method, payer, and reference. Tenant-isolated. Triggers invoice status recalculation on changes.

### Payment  Data Object Frontend Description By The Backend Architect

# payment Data Object - UX Guidance
- UI forms for payment creation may default date to today.
- Invoice linkage optional. If none, payment is 'General'; if present, must display invoice number in UI.
- Amount/currency always required. Method, payerName, reference, and notes aid reconciliation (can be optional).
- User can only create or view payments within their business scope. Deleted records hidden in standard UIs.
- Notes field can be used for operator details or clarifications.



### Payment Data Object Properties

Payment data object has got following properties that are represented as table fields in the database scheme. 
These properties don't stand just for data storage, but each may have different settings to manage the business logic. 

| Property | Type | IsArray | Required | Description |
|----------|------|---------|----------|-------------|
| `amount` | Double | false | Yes | The amount of the payment, in invoice or business operating currency. Must be positive and required. |
| `currency` | String | false | Yes | ISO currency code (e.g., 'USD', 'EUR') used for this payment. Must match business or invoice. Required. |
| `date` | Date | false | Yes | Date the payment was recorded. Used for reporting, filtering, and cash flow tracking. Required. |
| `invoiceId` | ID | false | No | Reference to the associated invoice (if payment is linked); null for general/unallocated payment. |
| `method` | String | false | No | Payment method (e.g., bank transfer, cash, card, cheque, online, etc). Free text; used for reporting/reconciliation. Optional. |
| `notes` | Text | false | No | Internal comments (operator notes, clarifications, etc.). Optional. |
| `payerName` | String | false | No | Name of the payer or payee (customer, vendor, or other party). Useful for general/unlinked payments. Optional, for tracking. |
| `reference` | String | false | No | Payment reference or transaction ID (for reconciliation with bank/etc). Optional. |
| `businessId` | ID | false | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value, formula or session bind is set.




### Relation Properties

`invoiceId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
The relations may reference to a data object either in this service or in another service. Id the reference is remote, backend handles the relations through service communication or elastic search.
These relations should be respected in the frontend so that instaead of showing the related objects id, the frontend should list human readable values from other data objects.
If the relation points to another service, frontend should use the referenced service api in case it needs related data.
The relation logic is montly handled in backend so the api responses feeds the frontend about the relational data. 
In mmost cases the api response will provide the relational data as well as the main one.

In frontend, please ensure that, 

1- instaead of these relational ids you show the main human readable field of the related target data (like name),
2- if this data object needs a user input of these relational ids, you should provide a combobox with the list of possible records or (a searchbox) to select with the realted target data object main human readable field.


- **invoiceId**: ID
Relation to `invoice`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

Required: No


### Filter Properties

`amount` `currency` `date` `invoiceId` `method` `reference` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's.

- **amount**: Double  has a filter named `amount`

- **currency**: String  has a filter named `currency`

- **date**: Date  has a filter named `date`

- **invoiceId**: ID  has a filter named `invoiceId`

- **method**: String  has a filter named `method`

- **reference**: String  has a filter named `reference`

- **businessId**: ID  has a filter named `businessId`



## API Reference

### `Create Payment` API
Record a new payment optionally linked to an invoice. Triggers invoice status update if linked. Only owner/accountant roles can create payments.

**API Frontend Description By The Backend Architect**

When a payment is created in the UI, if linked to an invoice, the UI should refresh invoice status after API success. Payment amount/date/currency must be validated before submit. Confirmations may be shown for large payments or if an overpayment is being attempted.

**Rest Route**

The `createPayment` API REST controller can be triggered via the following route:

`/v1/payments`


**Rest Request Parameters**


The `createPayment` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| amount  | Double  | true | request.body?.["amount"] |
| currency  | String  | true | request.body?.["currency"] |
| date  | Date  | true | request.body?.["date"] |
| invoiceId  | ID  | false | request.body?.["invoiceId"] |
| method  | String  | false | request.body?.["method"] |
| notes  | Text  | false | request.body?.["notes"] |
| payerName  | String  | false | request.body?.["payerName"] |
| reference  | String  | false | request.body?.["reference"] |
**amount** : The amount of the payment, in invoice or business operating currency. Must be positive and required.
**currency** : ISO currency code (e.g., 'USD', 'EUR') used for this payment. Must match business or invoice. Required.
**date** : Date the payment was recorded. Used for reporting, filtering, and cash flow tracking. Required.
**invoiceId** : Reference to the associated invoice (if payment is linked); null for general/unallocated payment.
**method** : Payment method (e.g., bank transfer, cash, card, cheque, online, etc). Free text; used for reporting/reconciliation. Optional.
**notes** : Internal comments (operator notes, clarifications, etc.). Optional.
**payerName** : Name of the payer or payee (customer, vendor, or other party). Useful for general/unlinked payments. Optional, for tracking.
**reference** : Payment reference or transaction ID (for reconciliation with bank/etc). Optional.


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/payments**
```js
  axios({
    method: 'POST',
    url: '/v1/payments',
    data: {
            amount:"Double",  
            currency:"String",  
            date:"Date",  
            invoiceId:"ID",  
            method:"String",  
            notes:"Text",  
            payerName:"String",  
            reference:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"id": "ID",
		"amount": "Double",
		"currency": "String",
		"date": "Date",
		"invoiceId": "ID",
		"method": "String",
		"notes": "Text",
		"payerName": "String",
		"reference": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Payment` API
Delete (soft-delete) a payment entry. If linked to invoice, recalculates and updates invoice status afterwards. Restricted to owner/accountant.

**API Frontend Description By The Backend Architect**

UI should warn/confirm before deletion, as deletion can change linked invoice status. Deleted payments hidden in UI and reporting by default. After delete, reload linked invoice(s) as needed in app.

**Rest Route**

The `deletePayment` API REST controller can be triggered via the following route:

`/v1/payments/:paymentId`


**Rest Request Parameters**


The `deletePayment` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| paymentId  | ID  | true | request.params?.["paymentId"] |
**paymentId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/payments/:paymentId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/payments/${paymentId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"id": "ID",
		"amount": "Double",
		"currency": "String",
		"date": "Date",
		"invoiceId": "ID",
		"method": "String",
		"notes": "Text",
		"payerName": "String",
		"reference": "String",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Payment` API
Retrieve a single payment (by ID) belonging to business. Enriches response with invoice number and status if linked. Any business user may view.

**API Frontend Description By The Backend Architect**

Payment detail view should display invoice info (number, status, amount) if linked, else indicate 'General Payment.' For audit, can show create/update timestamps.

**Rest Route**

The `getPayment` API REST controller can be triggered via the following route:

`/v1/payments/:paymentId`


**Rest Request Parameters**


The `getPayment` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| paymentId  | ID  | true | request.params?.["paymentId"] |
**paymentId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/payments/:paymentId**
```js
  axios({
    method: 'GET',
    url: `/v1/payments/${paymentId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"invoice": {
			"dueDate": "Date",
			"invoiceNumber": "String",
			"status": "Enum",
			"status_idx": "Integer",
			"totalAmount": "Double",
			"type": "Enum",
			"type_idx": "Integer"
		},
		"isActive": true
	}
}
```
### `List Payments` API
List all payments, filterable by date, amount, method, invoice linkage, or reference for business. Can include invoice number/status via join for display/reporting. All roles with business login.

**API Frontend Description By The Backend Architect**

List all payments in business. Allow grid filter/search by date, method, amount, invoice number, and reference. Totals and exports can filter by time period in UI. Invoice columns optional if linked. Row click may open payment detail or associated invoice.

**Rest Route**

The `listPayments` API REST controller can be triggered via the following route:

`/v1/payments`


**Rest Request Parameters**
The `listPayments` api has got no request parameters.    



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/payments**
```js
  axios({
    method: 'GET',
    url: '/v1/payments',
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payments",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"payments": [
		{
			"invoice": [
				{
					"dueDate": "Date",
					"invoiceNumber": "String",
					"status": "Enum",
					"status_idx": "Integer",
					"totalAmount": "Double",
					"type": "Enum",
					"type_idx": "Integer"
				},
				{},
				{}
			],
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Payment` API
Update a payment record. If linked to invoice, recalculates total payments and updates status. Owners/Accountants only.

**API Frontend Description By The Backend Architect**

Payment may be updated in UI grid or detail form. Changing invoice link or amount/date triggers invoice status update for previous and/or new invoice link. UI should handle complex update scenarios consultatively.

**Rest Route**

The `updatePayment` API REST controller can be triggered via the following route:

`/v1/payments/:paymentId`


**Rest Request Parameters**


The `updatePayment` api has got 9 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| paymentId  | ID  | true | request.params?.["paymentId"] |
| amount  | Double  | false | request.body?.["amount"] |
| currency  | String  | false | request.body?.["currency"] |
| date  | Date  | false | request.body?.["date"] |
| invoiceId  | ID  | false | request.body?.["invoiceId"] |
| method  | String  | false | request.body?.["method"] |
| notes  | Text  | false | request.body?.["notes"] |
| payerName  | String  | false | request.body?.["payerName"] |
| reference  | String  | false | request.body?.["reference"] |
**paymentId** : This id paremeter is used to select the required data object that will be updated
**amount** : The amount of the payment, in invoice or business operating currency. Must be positive and required.
**currency** : ISO currency code (e.g., 'USD', 'EUR') used for this payment. Must match business or invoice. Required.
**date** : Date the payment was recorded. Used for reporting, filtering, and cash flow tracking. Required.
**invoiceId** : Reference to the associated invoice (if payment is linked); null for general/unallocated payment.
**method** : Payment method (e.g., bank transfer, cash, card, cheque, online, etc). Free text; used for reporting/reconciliation. Optional.
**notes** : Internal comments (operator notes, clarifications, etc.). Optional.
**payerName** : Name of the payer or payee (customer, vendor, or other party). Useful for general/unlinked payments. Optional, for tracking.
**reference** : Payment reference or transaction ID (for reconciliation with bank/etc). Optional.


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/payments/:paymentId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/payments/${paymentId}`,
    data: {
            amount:"Double",  
            currency:"String",  
            date:"Date",  
            invoiceId:"ID",  
            method:"String",  
            notes:"Text",  
            payerName:"String",  
            reference:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"id": "ID",
		"amount": "Double",
		"currency": "String",
		"date": "Date",
		"invoiceId": "ID",
		"method": "String",
		"notes": "Text",
		"payerName": "String",
		"reference": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```

**After this prompt, the user may give you new instructions to update the output of this prompt or provide subsequent prompts about the project.**




---

<a id="frontend-prompts-frontend-prompt-9-productcatalogservice"></a>

## ProductCatalog Service



# **FINTRACK**

**FRONTEND GUIDE FOR AI CODING AGENTS - PART 9 - ProductCatalog Service**

This document is a part of a REST API guide for the fintrack project.
It is designed for AI agents that will generate frontend code to consume the project’s backend.

This document provides extensive instruction for the usage of productCatalog

## Service Access

ProductCatalog service management is handled through service specific base urls.

ProductCatalog  service may be deployed to the preview server, staging server, or production server. Therefore,it has 3 access URLs.
The frontend application must support all deployment environments during development, and the user should be able to select the target API server on the login page (already handled in first part.).

For the productCatalog service, the base URLs are:

* **Preview:** `https://fintrack.prw.mindbricks.com/productcatalog-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/productcatalog-api`
* **Production:** `https://fintrack.mindbricks.co/productcatalog-api`

## Scope

**ProductCatalog Service Description**

Handles CRUD operations for products and services offered by the business. Makes products/services available for invoice itemization and supports future extensions (e.g., category, inventory, VAT config).

ProductCatalog service provides apis and business logic for following data objects in fintrack application. 
Each data object may be either a central domain of the application data structure or a related helper data object for a central concept.
Note that data object concept is equal to table concept in the database, in the service database each data object is represented as a db table scheme and the object instances as table rows.  


**`productOrService` Data Object**: Represents a business-specific product or service available for use in invoices. Each entry is owned/scoped exclusively by one business (tenant) and can be searched, filtered, or extended as needed.


## ProductCatalog Service Frontend Description By The Backend Architect

# Product Catalog Service – FinTrack\n\nThis service provides the UX logic for managing products and services in the business context.\n- Users should only interact with products/services that belong to their current business.\n- Allow catalog search/filter by name, SKU, and type (product/service).\n- When selecting products/services for invoices, provide type and VAT info alongside name/price for clarity.\n- Owners/Accountants can add, edit, deactivate (soft-delete), or remove catalog entries; Users have read-only access for selection.\n- Catalog management screens may show indicators for inactive (archived) items and allow reactivation if appropriate.\n- Future UX may support product/service categorization, VAT templates, and validation for unique SKUs within a business.

## API Structure

### Object Structure of a Successful Response

When the service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope includes the data and essential metadata such as configuration details and pagination information, providing context to the client.

**HTTP Status Codes:**

* **200 OK**: Returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request was processed successfully.
* **201 Created**: Returned for CREATE operations, indicating that the resource was created successfully.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling that the request executed successfully. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3,
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
```
* **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation.

### Additional Data

Each API may include additional data besides the main data object, depending on the business logic of the API. These will be provided in each API’s response signature.

### Error Response

If a request encounters an issue—whether due to a logical fault or a technical problem—the service responds with a standardized JSON error structure. The HTTP status code indicates the nature of the error, using commonly recognized codes for clarity:

* **400 Bad Request**: The request was improperly formatted or contained invalid parameters.
* **401 Unauthorized**: The request lacked a valid authentication token; login is required.
* **403 Forbidden**: The current token does not grant access to the requested resource.
* **404 Not Found**: The requested resource was not found on the server.
* **500 Internal Server Error**: The server encountered an unexpected condition.

Each error response is structured to provide meaningful insight into the problem, assisting in efficient diagnosis and resolution.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```

## Bucket Management

(This information is also given in PART 1 prompt.)

This application has a bucket service used to store user files and other object-related files. The bucket service is login-agnostic, so for write operations or private reads, include a bucket token (provided by services) in the request’s Authorization header as a Bearer token.

Please note that all other business services require the access token in the Bearer header, while the bucket service expects a bucket token because it is login-agnostic. Ensure you manage the required token injection properly; any auth interceptor should not replace the bucket token with the access token.

**User Bucket**
This bucket stores public user files for each user.

When a user logs in—or in the `/currentuser` response—there is a `userBucketToken` to use when sending user-related public files to the bucket service.

```json
{
  //...
  "userBucketToken": "e56d...."
}
```

To upload a file

`POST {baseUrl}/bucket/upload`

The request body is form-data which includes the `bucketId` and the file binary in the `files` field.

```js
{
    bucketId: "{userId}-public-user-bucket",
    files: {binary}
}
```

Response status is 200 on success, e.g., body:

```json
{
    "success": true,
    "data": [
        {
            "fileId": "9da03f6d-0409-41ad-bb06-225a244ae408",
            "originalName": "test (10).png",
            "mimeType": "image/png",
            "size": 604063,
            "status": "uploaded",
            "bucketName": "f7103b85-fcda-4dec-92c6-c336f71fd3a2-public-user-bucket",
            "isPublic": true,
            "downloadUrl": "https://babilcom.mindbricks.co/bucket/download/9da03f6d-0409-41ad-bb06-225a244ae408"
        }
    ]
}
```

To download a file from the bucket, you need its `fileId`. If you upload an avatar or other asset, ensure the download URL or the `fileId` is stored in the backend.

Buckets are mostly used in object creations that require an additional file, such as a product image or user avatar. After uploading your image to the bucket, insert the returned download URL into the related property of the target object record.

**Application Bucket**

This Fintrack application also includes a common public bucket that anyone can read, but only users with the `superAdmin`, `admin`, or `saasAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `applicationBucketToken` field, which is used when uploading any file to the application bucket.

```json
{
  //...
  "applicationBucketToken": "e23fd...."
}
```

The common public application bucket ID is

`"fintrack-public-common-bucket"`

In certain admin areas—such as product management pages—since the user already has the application bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the application bucket using this bucket token whenever needed.



**Business Bucket (Tenant Bucket)**

This Fintrack application also includes a public bucket for each business that anyone can read, but only users with the `tenantOwner` or `tenantAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `tenantBucketToken` field, which is used when uploading any file to the tenant bucket.

```json
{
  //...
  "tenantBucketToken": "e23fd...."
}
```

The common public tenant bucket ID is

`"fintrack-{tenantCodename}-public-tenant-bucket"`

In certain admin areas—such as product management pages—since the user already has the tenant bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the tenant bucket using this bucket token whenever needed.



**Object Buckets**
Some objects may also return a bucket token for uploading or accessing files related to that object. For example, in a project management application, when you fetch a project’s data, a public or private bucket token may be provided to upload or download project-related files.

These buckets will be used as described in the relevant object definitions.


## ProductOrService Data Object

Represents a business-specific product or service available for use in invoices. Each entry is owned/scoped exclusively by one business (tenant) and can be searched, filtered, or extended as needed.

### ProductOrService  Data Object Frontend Description By The Backend Architect

- Product/service entries are managed per business; only Owner/Accountant can edit or create entries.\n- Name, SKU, price, currency, and VAT rate should be clearly visible.\n- SKU must be unique within a business and is used for rapid lookup in invoice workflows.\n- Users may only select active items for invoice itemization.\n- Items can be archived (soft deleted); they will not appear in normal selection but remain available for reporting/history.


### ProductOrService Data Object Properties

ProductOrService data object has got following properties that are represented as table fields in the database scheme. 
These properties don't stand just for data storage, but each may have different settings to manage the business logic. 

| Property | Type | IsArray | Required | Description |
|----------|------|---------|----------|-------------|
| `currency` | String | false | Yes | The ISO currency code (e.g., 'USD', 'EUR', 'GBP'). Every item must be priced in a defined currency; business default applies for new entries. |
| `description` | Text | false | No | Detailed or extended description for internal use and clarity in catalog and invoice dialogs. |
| `name` | String | false | Yes | Product or service display name, visible in invoice selection and catalog. |
| `notes` | Text | false | No | Internal notes and comments for this product/service, not exposed to external partners or customers. |
| `price` | Double | false | Yes | Unit price/cost for the product or service (decimal). |
| `sku` | String | false | Yes | Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection. |
| `type` | Enum | false | Yes | Specifies whether the entry is a product (physical good) or a service (intangible). |
| `vatRate` | Double | false | Yes | VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%). |
| `businessId` | ID | false | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value, formula or session bind is set.



### Enum Properties
Enum properties are defined with a set of allowed values, ensuring that only valid options can be assigned to them. 
The enum options value will be stored as strings in the database, 
but when a data object is created an additional property with the same name plus an idx suffix will be created, which will hold the index of the selected enum option.
You can use the {fieldName_idx} property to sort by the enum value or when your enum options represent a hiyerarchy of values.
In the frontend input components, enum type properties should only accept values from an option component that lists the enum options.

- **type**: [product, service]



### Filter Properties

`currency` `name` `price` `sku` `type` `vatRate` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's.

- **currency**: String  has a filter named `currency`

- **name**: String  has a filter named `name`

- **price**: Double  has a filter named `price`

- **sku**: String  has a filter named `sku`

- **type**: Enum  has a filter named `type`

- **vatRate**: Double  has a filter named `vatRate`

- **businessId**: ID  has a filter named `businessId`



## API Reference

### `Create Productorservice` API
Create a new product or service entry scoped to the current business. Only Owner/Accountant may create.

**API Frontend Description By The Backend Architect**

- Only Owners and Accountants can add new products/services via this API.\n- Input must specify all required product fields: type, name, sku (unique in business), price, currency, and VAT rate.\n- SKU is checked for uniqueness within business context before creation.\n- On success, product/service is added and available for invoice selection; frontends may refresh catalog views automatically.\n- If SKU conflict, API returns error highlighting duplication.

**Rest Route**

The `createProductOrService` API REST controller can be triggered via the following route:

`/v1/productorservices`


**Rest Request Parameters**


The `createProductOrService` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| currency  | String  | true | request.body?.["currency"] |
| description  | Text  | false | request.body?.["description"] |
| name  | String  | true | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| price  | Double  | true | request.body?.["price"] |
| sku  | String  | true | request.body?.["sku"] |
| type  | Enum  | true | request.body?.["type"] |
| vatRate  | Double  | true | request.body?.["vatRate"] |
**currency** : The ISO currency code (e.g., 'USD', 'EUR', 'GBP'). Every item must be priced in a defined currency; business default applies for new entries.
**description** : Detailed or extended description for internal use and clarity in catalog and invoice dialogs.
**name** : Product or service display name, visible in invoice selection and catalog.
**notes** : Internal notes and comments for this product/service, not exposed to external partners or customers.
**price** : Unit price/cost for the product or service (decimal).
**sku** : Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection.
**type** : Specifies whether the entry is a product (physical good) or a service (intangible).
**vatRate** : VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%).


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/productorservices**
```js
  axios({
    method: 'POST',
    url: '/v1/productorservices',
    data: {
            currency:"String",  
            description:"Text",  
            name:"String",  
            notes:"Text",  
            price:"Double",  
            sku:"String",  
            type:"Enum",  
            vatRate:"Double",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrService",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"productOrService": {
		"id": "ID",
		"currency": "String",
		"description": "Text",
		"name": "String",
		"notes": "Text",
		"price": "Double",
		"sku": "String",
		"type": "Enum",
		"type_idx": "Integer",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Productorservice` API
Soft-delete (deactivate) a product or service. Only Owner/Accountant can delete within their business. Deleted (inactive) products are not offered for new invoices but remain for history/reporting.

**API Frontend Description By The Backend Architect**

- Soft delete: product/service is marked inactive ('archived'), not physically removed.\n- Only Owner/Accountant can delete.\n- Deleted items no longer appear in normal selection for invoices, but can be viewed in an 'archived' filter/state in management UI.\n- No delete allowed across business or by unauthorized roles.

**Rest Route**

The `deleteProductOrService` API REST controller can be triggered via the following route:

`/v1/productorservices/:productOrServiceId`


**Rest Request Parameters**


The `deleteProductOrService` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| productOrServiceId  | ID  | true | request.params?.["productOrServiceId"] |
**productOrServiceId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/productorservices/:productOrServiceId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/productorservices/${productOrServiceId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrService",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"productOrService": {
		"id": "ID",
		"currency": "String",
		"description": "Text",
		"name": "String",
		"notes": "Text",
		"price": "Double",
		"sku": "String",
		"type": "Enum",
		"type_idx": "Integer",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Productorservice` API
Get details of a single product or service by ID within the current business. All roles can view details for selection or management as allowed.

**API Frontend Description By The Backend Architect**

- Any authenticated business role can view details of a product/service in their business.\n- Product/service data is used for invoice itemization screens, catalog drilldown, edit panes, etc.

**Rest Route**

The `getProductOrService` API REST controller can be triggered via the following route:

`/v1/productorservices/:productOrServiceId`


**Rest Request Parameters**


The `getProductOrService` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| productOrServiceId  | ID  | true | request.params?.["productOrServiceId"] |
**productOrServiceId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/productorservices/:productOrServiceId**
```js
  axios({
    method: 'GET',
    url: `/v1/productorservices/${productOrServiceId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrService",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"productOrService": {
		"isActive": true
	}
}
```
### `List Productorservices` API
List all products and services in the current business. Supports filter/search by name, type, SKU. All roles within business may view and select for invoice workflows.

**API Frontend Description By The Backend Architect**

- Product/service catalog is presented in tabular/grid with filters for name, type (product/service), and SKU.\n- 'Inactive' or soft-deleted items may be hidden by default, surfaced when needed.\n- VAT rate, price, and currency columns support invoice UI and reporting.\n- All data is scoped to current business, never shown across tenants.

**Rest Route**

The `listProductOrServices` API REST controller can be triggered via the following route:

`/v1/productorservices`


**Rest Request Parameters**
The `listProductOrServices` api has got no request parameters.    



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/productorservices**
```js
  axios({
    method: 'GET',
    url: '/v1/productorservices',
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrServices",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"productOrServices": [
		{
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Productorservice` API
Update an existing product/service. Owners and Accountants (and only those within the business) can modify. SKU is validated for uniqueness per business.

**API Frontend Description By The Backend Architect**

- Only Owner/Accountant can update catalog entries.\n- Updates are restricted to product/service records belonging to current business.\n- SKU cannot be set to a value that duplicates another active product for this business.\n- Updated entries remain immediately available for invoice selection; edits reflected in search/filter UI.\n- If conflicting update (e.g., SKU duplicate), clear error is provided for frontend handling.

**Rest Route**

The `updateProductOrService` API REST controller can be triggered via the following route:

`/v1/productorservices/:productOrServiceId`


**Rest Request Parameters**


The `updateProductOrService` api has got 9 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| productOrServiceId  | ID  | true | request.params?.["productOrServiceId"] |
| currency  | String  | false | request.body?.["currency"] |
| description  | Text  | false | request.body?.["description"] |
| name  | String  | false | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| price  | Double  | false | request.body?.["price"] |
| sku  | String  | false | request.body?.["sku"] |
| type  | Enum  | false | request.body?.["type"] |
| vatRate  | Double  | false | request.body?.["vatRate"] |
**productOrServiceId** : This id paremeter is used to select the required data object that will be updated
**currency** : The ISO currency code (e.g., 'USD', 'EUR', 'GBP'). Every item must be priced in a defined currency; business default applies for new entries.
**description** : Detailed or extended description for internal use and clarity in catalog and invoice dialogs.
**name** : Product or service display name, visible in invoice selection and catalog.
**notes** : Internal notes and comments for this product/service, not exposed to external partners or customers.
**price** : Unit price/cost for the product or service (decimal).
**sku** : Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection.
**type** : Specifies whether the entry is a product (physical good) or a service (intangible).
**vatRate** : VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%).


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/productorservices/:productOrServiceId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/productorservices/${productOrServiceId}`,
    data: {
            currency:"String",  
            description:"Text",  
            name:"String",  
            notes:"Text",  
            price:"Double",  
            sku:"String",  
            type:"Enum",  
            vatRate:"Double",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrService",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"productOrService": {
		"id": "ID",
		"currency": "String",
		"description": "Text",
		"name": "String",
		"notes": "Text",
		"price": "Double",
		"sku": "String",
		"type": "Enum",
		"type_idx": "Integer",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `_fetch Listproductorservice` API
System API to fetch list of productOrService records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListProductOrService` API REST controller can be triggered via the following route:

`/v1/_fetchlistproductorservice`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListProductOrService` api supports 6 optional filter parameters for filtering list results:

**currency** (`String`): The ISO currency code (e.g., 'USD', 'EUR', 'GBP'). Every item must be priced in a defined currency; business default applies for new entries.

- Single (partial match, case-insensitive): `?currency=<value>`
- Multiple: `?currency=<value1>&currency=<value2>`
- Null: `?currency=null`


**name** (`String`): Product or service display name, visible in invoice selection and catalog.

- Single (partial match, case-insensitive): `?name=<value>`
- Multiple: `?name=<value1>&name=<value2>`
- Null: `?name=null`


**price** (`Double`): Unit price/cost for the product or service (decimal).

- Single: `?price=<value>`
- Multiple: `?price=<value1>&price=<value2>`
- Range: `?price=$lt-<value>`, `$lte-`, `$gt-`, `$gte-`, `$btw-<min>-<max>`
- Null: `?price=null`


**sku** (`String`): Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection.

- Single (partial match, case-insensitive): `?sku=<value>`
- Multiple: `?sku=<value1>&sku=<value2>`
- Null: `?sku=null`


**type** (`Enum`): Specifies whether the entry is a product (physical good) or a service (intangible).

- Single: `?type=<value>` (case-insensitive)
- Multiple: `?type=<value1>&type=<value2>`
- Null: `?type=null`


**vatRate** (`Double`): VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%).

- Single: `?vatRate=<value>`
- Multiple: `?vatRate=<value1>&vatRate=<value2>`
- Range: `?vatRate=$lt-<value>`, `$lte-`, `$gt-`, `$gte-`, `$btw-<min>-<max>`
- Null: `?vatRate=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistproductorservice**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistproductorservice',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // currency: '<value>' // Filter by currency
        // name: '<value>' // Filter by name
        // price: '<value>' // Filter by price
        // sku: '<value>' // Filter by sku
        // type: '<value>' // Filter by type
        // vatRate: '<value>' // Filter by vatRate
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrServices",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"productOrServices": [
		{
			"id": "ID",
			"currency": "String",
			"description": "Text",
			"name": "String",
			"notes": "Text",
			"price": "Double",
			"sku": "String",
			"type": "Enum",
			"type_idx": "Integer",
			"vatRate": "Double",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID"
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```

**After this prompt, the user may give you new instructions to update the output of this prompt or provide subsequent prompts about the project.**




---

<a id="frontend-prompts-frontend-prompt-10-suppliermanagementservice"></a>

## SupplierManagement Service



# **FINTRACK**

**FRONTEND GUIDE FOR AI CODING AGENTS - PART 10 - SupplierManagement Service**

This document is a part of a REST API guide for the fintrack project.
It is designed for AI agents that will generate frontend code to consume the project’s backend.

This document provides extensive instruction for the usage of supplierManagement

## Service Access

SupplierManagement service management is handled through service specific base urls.

SupplierManagement  service may be deployed to the preview server, staging server, or production server. Therefore,it has 3 access URLs.
The frontend application must support all deployment environments during development, and the user should be able to select the target API server on the login page (already handled in first part.).

For the supplierManagement service, the base URLs are:

* **Preview:** `https://fintrack.prw.mindbricks.com/suppliermanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/suppliermanagement-api`
* **Production:** `https://fintrack.mindbricks.co/suppliermanagement-api`

## Scope

**SupplierManagement Service Description**

Handles all business-specific supplier CRUD operations and exposes supplier data for invoice and reporting workflows. Ensures strict tenant (business) isolation for all supplier records and supports all roles per business context.

SupplierManagement service provides apis and business logic for following data objects in fintrack application. 
Each data object may be either a central domain of the application data structure or a related helper data object for a central concept.
Note that data object concept is equal to table concept in the database, in the service database each data object is represented as a db table scheme and the object instances as table rows.  


**`supplier` Data Object**: Represents a business-specific supplier. Each supplier is associated with a single business (tenant) and includes identification, contact, and optional notes for use in purchase workflows and reporting.


## SupplierManagement Service Frontend Description By The Backend Architect

Suppliers are always listed in the context of the user's active business. CRUD forms allow creating, viewing, editing, and deleting suppliers. Supplier data is required to be present for creating purchase invoices (picked via selector). Note fields should display as multi-line rich text areas. Deletion is soft by default—removal deactivates supplier in list but keeps record for audit/history. Search and filter options are available by supplier name, tax number, and contact info in supplier lists for rapid lookup in UIs. Integrations with invoice entry dialogs as supplier selectors are expected.

## API Structure

### Object Structure of a Successful Response

When the service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope includes the data and essential metadata such as configuration details and pagination information, providing context to the client.

**HTTP Status Codes:**

* **200 OK**: Returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request was processed successfully.
* **201 Created**: Returned for CREATE operations, indicating that the resource was created successfully.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling that the request executed successfully. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3,
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
```
* **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation.

### Additional Data

Each API may include additional data besides the main data object, depending on the business logic of the API. These will be provided in each API’s response signature.

### Error Response

If a request encounters an issue—whether due to a logical fault or a technical problem—the service responds with a standardized JSON error structure. The HTTP status code indicates the nature of the error, using commonly recognized codes for clarity:

* **400 Bad Request**: The request was improperly formatted or contained invalid parameters.
* **401 Unauthorized**: The request lacked a valid authentication token; login is required.
* **403 Forbidden**: The current token does not grant access to the requested resource.
* **404 Not Found**: The requested resource was not found on the server.
* **500 Internal Server Error**: The server encountered an unexpected condition.

Each error response is structured to provide meaningful insight into the problem, assisting in efficient diagnosis and resolution.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```

## Bucket Management

(This information is also given in PART 1 prompt.)

This application has a bucket service used to store user files and other object-related files. The bucket service is login-agnostic, so for write operations or private reads, include a bucket token (provided by services) in the request’s Authorization header as a Bearer token.

Please note that all other business services require the access token in the Bearer header, while the bucket service expects a bucket token because it is login-agnostic. Ensure you manage the required token injection properly; any auth interceptor should not replace the bucket token with the access token.

**User Bucket**
This bucket stores public user files for each user.

When a user logs in—or in the `/currentuser` response—there is a `userBucketToken` to use when sending user-related public files to the bucket service.

```json
{
  //...
  "userBucketToken": "e56d...."
}
```

To upload a file

`POST {baseUrl}/bucket/upload`

The request body is form-data which includes the `bucketId` and the file binary in the `files` field.

```js
{
    bucketId: "{userId}-public-user-bucket",
    files: {binary}
}
```

Response status is 200 on success, e.g., body:

```json
{
    "success": true,
    "data": [
        {
            "fileId": "9da03f6d-0409-41ad-bb06-225a244ae408",
            "originalName": "test (10).png",
            "mimeType": "image/png",
            "size": 604063,
            "status": "uploaded",
            "bucketName": "f7103b85-fcda-4dec-92c6-c336f71fd3a2-public-user-bucket",
            "isPublic": true,
            "downloadUrl": "https://babilcom.mindbricks.co/bucket/download/9da03f6d-0409-41ad-bb06-225a244ae408"
        }
    ]
}
```

To download a file from the bucket, you need its `fileId`. If you upload an avatar or other asset, ensure the download URL or the `fileId` is stored in the backend.

Buckets are mostly used in object creations that require an additional file, such as a product image or user avatar. After uploading your image to the bucket, insert the returned download URL into the related property of the target object record.

**Application Bucket**

This Fintrack application also includes a common public bucket that anyone can read, but only users with the `superAdmin`, `admin`, or `saasAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `applicationBucketToken` field, which is used when uploading any file to the application bucket.

```json
{
  //...
  "applicationBucketToken": "e23fd...."
}
```

The common public application bucket ID is

`"fintrack-public-common-bucket"`

In certain admin areas—such as product management pages—since the user already has the application bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the application bucket using this bucket token whenever needed.



**Business Bucket (Tenant Bucket)**

This Fintrack application also includes a public bucket for each business that anyone can read, but only users with the `tenantOwner` or `tenantAdmin` roles can write (upload) to it.

When a user with one of these admin roles is logged in, the `/login` response or the `/currentuser` response also returns an `tenantBucketToken` field, which is used when uploading any file to the tenant bucket.

```json
{
  //...
  "tenantBucketToken": "e23fd...."
}
```

The common public tenant bucket ID is

`"fintrack-{tenantCodename}-public-tenant-bucket"`

In certain admin areas—such as product management pages—since the user already has the tenant bucket token, they will be able to upload related object images.

Please configure your UI to upload files to the tenant bucket using this bucket token whenever needed.



**Object Buckets**
Some objects may also return a bucket token for uploading or accessing files related to that object. For example, in a project management application, when you fetch a project’s data, a public or private bucket token may be provided to upload or download project-related files.

These buckets will be used as described in the relevant object definitions.


## Supplier Data Object

Represents a business-specific supplier. Each supplier is associated with a single business (tenant) and includes identification, contact, and optional notes for use in purchase workflows and reporting.

### Supplier  Data Object Frontend Description By The Backend Architect

Supplier forms require name, tax number, contact info, and address. All fields are editable by Owner or Accountant; viewable by User. Notes may be used for comments about the supplier relationship. In selection dialogs for purchase invoices, show: name, contactName, and taxNumber prominently. Deactivation means supplier cannot be selected on new invoices, but remains in history. Address is a free text (multi-line) field supporting international addresses.


### Supplier Data Object Properties

Supplier data object has got following properties that are represented as table fields in the database scheme. 
These properties don't stand just for data storage, but each may have different settings to manage the business logic. 

| Property | Type | IsArray | Required | Description |
|----------|------|---------|----------|-------------|
| `address` | Text | false | No | Supplier's legal or correspondence address (may include free formatting; recommended multi-line) |
| `contactEmail` | String | false | No | Contact person's email address at the supplier |
| `contactName` | String | false | No | Primary contact's name at the supplier organization |
| `name` | String | false | Yes | Supplier's official (display) name |
| `notes` | Text | false | No | Internal notes/comments about the supplier; not normally exposed outside the business |
| `phone` | String | false | No | Main phone number for supplier or contact person |
| `taxNumber` | String | false | No | Tax/VAT identification number for the supplier, if applicable |
| `businessId` | ID | false | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value, formula or session bind is set.





### Filter Properties

`contactEmail` `contactName` `name` `phone` `taxNumber` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's.

- **contactEmail**: String  has a filter named `contactEmail`

- **contactName**: String  has a filter named `contactName`

- **name**: String  has a filter named `name`

- **phone**: String  has a filter named `phone`

- **taxNumber**: String  has a filter named `taxNumber`

- **businessId**: ID  has a filter named `businessId`



## API Reference

### `Create Supplier` API
Create a new supplier scoped to the current business. Owner/Accountant roles can create; input required: supplier name, optional tax, contact, and address fields.

**API Frontend Description By The Backend Architect**

Create supplier form requires supplier name; contact, address, and notes are optional. Created supplier instantly available for invoice workflow.

**Rest Route**

The `createSupplier` API REST controller can be triggered via the following route:

`/v1/suppliers`


**Rest Request Parameters**


The `createSupplier` api has got 7 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| address  | Text  | false | request.body?.["address"] |
| contactEmail  | String  | false | request.body?.["contactEmail"] |
| contactName  | String  | false | request.body?.["contactName"] |
| name  | String  | true | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| phone  | String  | false | request.body?.["phone"] |
| taxNumber  | String  | false | request.body?.["taxNumber"] |
**address** : Supplier's legal or correspondence address (may include free formatting; recommended multi-line)
**contactEmail** : Contact person's email address at the supplier
**contactName** : Primary contact's name at the supplier organization
**name** : Supplier's official (display) name
**notes** : Internal notes/comments about the supplier; not normally exposed outside the business
**phone** : Main phone number for supplier or contact person
**taxNumber** : Tax/VAT identification number for the supplier, if applicable


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/suppliers**
```js
  axios({
    method: 'POST',
    url: '/v1/suppliers',
    data: {
            address:"Text",  
            contactEmail:"String",  
            contactName:"String",  
            name:"String",  
            notes:"Text",  
            phone:"String",  
            taxNumber:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "supplier",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"supplier": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Supplier` API
Soft delete (deactivate) a supplier from the current business. Only Owner/Accountant can delete. Deleted suppliers are hidden in normal searches but remain for audit/history.

**API Frontend Description By The Backend Architect**

Delete button soft-removes the supplier. Confirm dialog warns impact on active invoices. Cannot delete suppliers referenced by active invoices, enforce in future update.

**Rest Route**

The `deleteSupplier` API REST controller can be triggered via the following route:

`/v1/suppliers/:supplierId`


**Rest Request Parameters**


The `deleteSupplier` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| supplierId  | ID  | true | request.params?.["supplierId"] |
**supplierId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/suppliers/:supplierId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/suppliers/${supplierId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "supplier",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"supplier": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Supplier` API
Fetch details of a supplier by ID in the current business. Any user role can view within their business. Used for supplier details screens or invoice selectors.

**API Frontend Description By The Backend Architect**

Fetch and display supplier details. Data shown: name, contact, address, notes. If inactive, warn on usage in new records.

**Rest Route**

The `getSupplier` API REST controller can be triggered via the following route:

`/v1/suppliers/:supplierId`


**Rest Request Parameters**


The `getSupplier` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| supplierId  | ID  | true | request.params?.["supplierId"] |
**supplierId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/suppliers/:supplierId**
```js
  axios({
    method: 'GET',
    url: `/v1/suppliers/${supplierId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "supplier",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"supplier": {
		"isActive": true
	}
}
```
### `List Suppliers` API
List all suppliers for the current business, with filter/search by name, tax number, contact info. All user roles in business can view.

**API Frontend Description By The Backend Architect**

Supplier list allows searching and filtering by main info columns (name, tax number, contact, phone). Sort by name or created date. Multi-select for bulk actions (future enhancement). Paging enabled for large lists.

**Rest Route**

The `listSuppliers` API REST controller can be triggered via the following route:

`/v1/suppliers`


**Rest Request Parameters**
The `listSuppliers` api has got no request parameters.    



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/suppliers**
```js
  axios({
    method: 'GET',
    url: '/v1/suppliers',
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "suppliers",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"suppliers": [
		{
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Supplier` API
Update supplier fields for the current business. Owner and Accountant roles can modify. Supplier ID and business isolation enforced. Soft delete applies to deactivation.

**API Frontend Description By The Backend Architect**

Update dialog allows editing all supplier fields for Owner/Accountant. Soft delete toggles active status rather than physical removal.

**Rest Route**

The `updateSupplier` API REST controller can be triggered via the following route:

`/v1/suppliers/:supplierId`


**Rest Request Parameters**


The `updateSupplier` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| supplierId  | ID  | true | request.params?.["supplierId"] |
| address  | Text  | false | request.body?.["address"] |
| contactEmail  | String  | false | request.body?.["contactEmail"] |
| contactName  | String  | false | request.body?.["contactName"] |
| name  | String  | false | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| phone  | String  | false | request.body?.["phone"] |
| taxNumber  | String  | false | request.body?.["taxNumber"] |
**supplierId** : This id paremeter is used to select the required data object that will be updated
**address** : Supplier's legal or correspondence address (may include free formatting; recommended multi-line)
**contactEmail** : Contact person's email address at the supplier
**contactName** : Primary contact's name at the supplier organization
**name** : Supplier's official (display) name
**notes** : Internal notes/comments about the supplier; not normally exposed outside the business
**phone** : Main phone number for supplier or contact person
**taxNumber** : Tax/VAT identification number for the supplier, if applicable


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/suppliers/:supplierId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/suppliers/${supplierId}`,
    data: {
            address:"Text",  
            contactEmail:"String",  
            contactName:"String",  
            name:"String",  
            notes:"Text",  
            phone:"String",  
            taxNumber:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "supplier",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"supplier": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `_fetch Listsupplier` API
System API to fetch list of supplier records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListSupplier` API REST controller can be triggered via the following route:

`/v1/_fetchlistsupplier`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListSupplier` api supports 5 optional filter parameters for filtering list results:

**contactEmail** (`String`): Contact person's email address at the supplier

- Single (partial match, case-insensitive): `?contactEmail=<value>`
- Multiple: `?contactEmail=<value1>&contactEmail=<value2>`
- Null: `?contactEmail=null`


**contactName** (`String`): Primary contact's name at the supplier organization

- Single (partial match, case-insensitive): `?contactName=<value>`
- Multiple: `?contactName=<value1>&contactName=<value2>`
- Null: `?contactName=null`


**name** (`String`): Supplier's official (display) name

- Single (partial match, case-insensitive): `?name=<value>`
- Multiple: `?name=<value1>&name=<value2>`
- Null: `?name=null`


**phone** (`String`): Main phone number for supplier or contact person

- Single (partial match, case-insensitive): `?phone=<value>`
- Multiple: `?phone=<value1>&phone=<value2>`
- Null: `?phone=null`


**taxNumber** (`String`): Tax/VAT identification number for the supplier, if applicable

- Single (partial match, case-insensitive): `?taxNumber=<value>`
- Multiple: `?taxNumber=<value1>&taxNumber=<value2>`
- Null: `?taxNumber=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistsupplier**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistsupplier',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // contactEmail: '<value>' // Filter by contactEmail
        // contactName: '<value>' // Filter by contactName
        // name: '<value>' // Filter by name
        // phone: '<value>' // Filter by phone
        // taxNumber: '<value>' // Filter by taxNumber
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "suppliers",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"suppliers": [
		{
			"id": "ID",
			"address": "Text",
			"contactEmail": "String",
			"contactName": "String",
			"name": "String",
			"notes": "Text",
			"phone": "String",
			"taxNumber": "String",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID"
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```

**After this prompt, the user may give you new instructions to update the output of this prompt or provide subsequent prompts about the project.**




---

# CustomerManagement Service

<a id="customermanagement-service-service-design"></a>

## Service Design Specification



# Service Design Specification
**fintrack-customermanagement-service** documentation
**Version:** `1.0.1`

## Scope

This document provides a structured architectural overview of the `customerManagement` microservice, detailing its configuration, data model, authorization logic, business rules, and API design. It has been automatically generated based on the service definition within Mindbricks, ensuring that the information reflects the source of truth used during code generation and deployment.

The document is intended to serve multiple audiences:

* **Service architects** can use it to validate design decisions and ensure alignment with broader architectural goals.
* **Developers and maintainers** will find it useful for understanding the structure and behavior of the service, facilitating easier debugging, feature extension, and integration with other systems.
* **Stakeholders and reviewers** can use it to gain a clear understanding of the service's capabilities and domain logic.

> **Note for Frontend Developers**: While this document is valuable for understanding business logic and data interactions, please refer to the [Service API Documentation](#) for endpoint-level specifications and integration details.

> **Note for Backend Developers**: Since the code for this service is automatically generated by Mindbricks, you typically won't need to implement or modify it manually. However, this document is especially valuable when you're building other services—whether within Mindbricks or externally—that need to interact with or depend on this service. It provides a clear reference to the service's data contracts, business rules, and API structure, helping ensure compatibility and correct integration.



## `CustomerManagement` Service Settings [**Edit**](customermanagement/serviceSettings)

Handles all business-specific customer CRUD operations and exposes customer data for sales invoice and reporting workflows. Ensures strict tenant (business) isolation for all customer records and supports role-based access control per business context.

### Service Overview

This service is configured to listen for HTTP requests on port `3001`, 
serving both the main API interface and default administrative endpoints.

The following routes are available by default:

* **API Test Interface (API Face):** `/`
* **Swagger Documentation:** `/swagger`
* **Postman Collection Download:** `/getPostmanCollection`
* **Health Checks:** `/health` and `/admin/health`
* **Current Session Info:** `/currentuser`
* **Favicon:** `/favicon.ico`

The service uses a **PostgreSQL** database for data storage, with the database name set to `fintrack-customermanagement-service`.

This service is accessible via the following environment-specific URLs:

* **Preview:** `https://fintrack.prw.mindbricks.com/customermanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/customermanagement-api`
* **Production:** `https://fintrack.mindbricks.co/customermanagement-api`

                                 

### Authentication & Security
- **Login Required**: Yes

This service requires user authentication for access. It supports both JWT and RSA-based authentication mechanisms, ensuring secure user sessions and data integrity.
If a crud route also is configured to require login, 
it will check a valid JWT token in the request query/header/bearer/cookie. If the token is valid, it will extract the user information from the token and make the fetched session data available in the request context.

  
### Service Data Objects
The service uses a **PostgreSQL** database for data storage, with the database name set to `fintrack-customermanagement-service`.

Data deletion is managed using a **soft delete** strategy. Instead of removing records from the database, they are flagged as inactive by setting the `isActive` field to `false`.



| Object Name | Description | Public Access | Tenant Level  | 
|-------------|-------------|---------------| --------------| 
| `customer` | Business customer/contact record, uniquely scoped to business. Contains info required for sales, invoicing, and reporting. Not shared across tenants. | accessProtected |  Yes | 




## customer Data Object

### Object Overview
**Description:** Business customer/contact record, uniquely scoped to business. Contains info required for sales, invoicing, and reporting. Not shared across tenants.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessProtected — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.








### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `address` | Text | No | Full postal address, optional, multi-line, Unicode supported. |
| `contactEmail` | String | No | Primary contact&#39;s email address (optional, for notifications or info). |
| `contactName` | String | No | Primary contact person&#39;s name (optional, for individual or company). |
| `name` | String | Yes | Full customer display name (required). |
| `notes` | Text | No | Internal notes/comments about the customer, never public. |
| `phone` | String | No | Main phone number for contact (optional). |
| `taxNumber` | String | No | Tax/VAT identification number or code (optional). |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **name**: 'default'
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`address` `contactEmail` `contactName` `name` `notes` `phone` `taxNumber`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

 

 

### Elastic Search Indexing

`address` `contactEmail` `contactName` `name` `phone` `taxNumber` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`name` `taxNumber` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.





### Secondary Key Properties

`businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.






### Filter Properties

`contactEmail` `contactName` `name` `phone` `taxNumber` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **contactEmail**: String  has a filter named `contactEmail`

- **contactName**: String  has a filter named `contactName`

- **name**: String  has a filter named `name`

- **phone**: String  has a filter named `phone`

- **taxNumber**: String  has a filter named `taxNumber`

- **businessId**: ID  has a filter named `businessId`







## Business Logic


customerManagement has got 6 Business APIs to manage its internal and crud logic. 
For the details of each business API refer to its chapter.

* [Create Customer](/businessLogic/createcustomer)

* [Delete Customer](/businessLogic/deletecustomer)

* [Get Customer](/businessLogic/getcustomer)

* [List Customers](/businessLogic/listcustomers)

* [Update Customer](/businessLogic/updatecustomer)

* [_fetch Listcustomer](/businessLogic/_fetchlistcustomer)



## Edge Controllers



### m2mCreateCustomer

**Configuration:**
- **Function Name**: `m2mCreateCustomer`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/customer/create`
- **Method**: 

---

### m2mBulkCreateCustomer

**Configuration:**
- **Function Name**: `m2mBulkCreateCustomer`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/customer/bulk-create`
- **Method**: 

---

### m2mUpdateCustomerById

**Configuration:**
- **Function Name**: `m2mUpdateCustomerById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/customer/update/:id`
- **Method**: 

---

### m2mDeleteCustomerById

**Configuration:**
- **Function Name**: `m2mDeleteCustomerById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/customer/delete/:id`
- **Method**: 

---

### m2mUpdateCustomerByQuery

**Configuration:**
- **Function Name**: `m2mUpdateCustomerByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/customer/update-by-query`
- **Method**: 

---

### m2mDeleteCustomerByQuery

**Configuration:**
- **Function Name**: `m2mDeleteCustomerByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/customer/delete-by-query`
- **Method**: 

---

### m2mUpdateCustomerByIdList

**Configuration:**
- **Function Name**: `m2mUpdateCustomerByIdList`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/customer/update-by-id-list`
- **Method**: 

---



---

## Service Library


### Functions

No general functions defined.


### Hook Functions

No hook functions defined.


### Edge Functions


#### m2mCreateCustomer.js
```js
module.exports = async (request) => {
        const { createCustomer } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const data = request.body?.data || request.data || request;
        const result = await createCustomer(data, context);
        return { status: 200, content: result };
      }
```

#### m2mBulkCreateCustomer.js
```js
module.exports = async (request) => {
        const { createBulkCustomer } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataList = request.body?.dataList || request.dataList || (Array.isArray(request.body) ? request.body : [request.body]);
        if (!Array.isArray(dataList) || dataList.length === 0) {
          return { status: 400, message: "dataList must be a non-empty array" };
        }
        const result = await createBulkCustomer(dataList, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateCustomerById.js
```js
module.exports = async (request) => {
        const { updateCustomerById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.id) delete dataClause.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await updateCustomerById(id, dataClause, context);
        return { status: 200, content: result };
      }
```

#### m2mDeleteCustomerById.js
```js
module.exports = async (request) => {
        const { deleteCustomerById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await deleteCustomerById(id, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateCustomerByQuery.js
```js
module.exports = async (request) => {
        const { updateCustomerByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await updateCustomerByQuery(dataClause, query, context);
        return { status: 200, content: result };
      }
```

#### m2mDeleteCustomerByQuery.js
```js
module.exports = async (request) => {
        const { deleteCustomerByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await deleteCustomerByQuery(query, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateCustomerByIdList.js
```js
module.exports = async (request) => {
        const { updateCustomerByIdList } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const idList = request.body?.idList || request.idList || [];
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.idList) delete dataClause.idList;
        if (!Array.isArray(idList) || idList.length === 0) {
          return { status: 400, message: "idList must be a non-empty array" };
        }
        const result = await updateCustomerByIdList(idList, dataClause, context);
        return { status: 200, content: result };
      }
```



### Templates

No templates defined.


### Assets

No assets defined.


### Public Assets

No public assets defined.



---




### Event Emission


---

## Integration Patterns

## Deployment Considerations

### Environment Configuration
- **HTTP Port**: `3001`
- **Database Type**: MongoDB
- **Global Soft Delete**: Enabled




## Implementation Guidelines

### Development Workflow
1. **Data Model Implementation**: Generate database schema from data object definitions
2. **CRUD Route Generation**: Implement auto-generated routes with custom logic
3. **Custom Logic Integration**: Implement hook functions and edge functions
4. **Authentication Integration**: Configure with project-level authentication
5. **Testing**: Unit and integration testing for all components

### Code Generation Expectations
- **Database Schema**: Auto-generated from data objects and relationships
- **API Routes**: REST endpoints with customizable behavior
- **Validation Logic**: Input validation from property definitions
- **Access Control**: Authentication and authorization middleware

### Custom Code Integration Points
- **Hook Functions**: Lifecycle-specific custom logic
- **Edge Functions**: Full request/response control
- **Library Functions**: Reusable business logic
- **Templates**: Dynamic content rendering

### Testing Strategy

#### Unit Testing
- Test all custom library functions
- Test validation logic and business rules
- Test hook function implementations

#### Integration Testing
- Test API endpoints with authentication scenarios
- Test database operations and transactions
- Test external integrations
- Test event emission and Kafka integration

#### Performance Testing
- Load test high-traffic endpoints
- Test caching effectiveness
- Monitor database query performance
- Test scalability under load

---

## Appendices

### Data Type Reference
| Type | Description | Storage |
|------|-------------|---------|
| ID | Unique identifier | UUID (SQL) / ObjectID (NoSQL) |
| String | Short text (≤255 chars) | VARCHAR |
| Text | Long-form text | TEXT |
| Integer | 32-bit whole numbers | INT |
| Boolean | True/false values | BOOLEAN |
| Double | 64-bit floating point | DOUBLE |
| Float | 32-bit floating point | FLOAT |
| Short | 16-bit integers | SMALLINT |
| Object | JSON object | JSONB (PostgreSQL) / Object (MongoDB) |
| Date | ISO 8601 timestamp | TIMESTAMP |
| Enum | Fixed numeric values | SMALLINT with lookup |

### Enum Value Mappings

#### Request Locations
- `0`: Bearer token in Authorization header
- `1`: Cookie value
- `2`: Custom HTTP header
- `3`: Query parameter
- `4`: Request body property
- `5`: URL path parameter
- `6`: Session data
- `7`: Root request object

#### HTTP Methods
- `0`: GET
- `1`: POST
- `2`: PUT
- `3`: PATCH
- `4`: DELETE


### Edge Function Signature
```javascript
async function edgeFunction(request) {
  // Custom request processing
  // Return response object or throw error
  return {
    data: {},
    status: 200,
    message: "Success"
  };
}
```

---

*This document was generated from the service architecture definition and should be kept in sync with implementation changes.*

---

<a id="customermanagement-service-rest-api-guide"></a>

## REST API GUIDE 

 

# REST API GUIDE 
## fintrack-customermanagement-service
**Version:** `1.0.1`

Handles all business-specific customer CRUD operations and exposes customer data for sales invoice and reporting workflows. Ensures strict tenant (business) isolation for all customer records and supports role-based access control per business context.

## Architectural Design Credit and Contact Information

The architectural design of this microservice is credited to . 
For inquiries, feedback, or further information regarding the architecture, please direct your communication to:

Email: 

We encourage open communication and welcome any questions or discussions related to the architectural aspects of this microservice.

## Documentation Scope

Welcome to the official documentation for the CustomerManagement Service's REST API. This document is designed to provide a comprehensive guide to interfacing with our CustomerManagement Service exclusively through RESTful API endpoints.

**Intended Audience**

This documentation is intended for developers and integrators who are looking to interact with the CustomerManagement Service via HTTP requests for purposes such as creating, updating, deleting and querying CustomerManagement objects.

**Overview**

Within these pages, you will find detailed information on how to effectively utilize the REST API, including authentication methods, request and response formats, endpoint descriptions, and examples of common use cases.

Beyond REST
It's important to note that the CustomerManagement Service also supports alternative methods of interaction, such as gRPC and messaging via a Message Broker. These communication methods are beyond the scope of this document. For information regarding these protocols, please refer to their respective documentation.

## Authentication And Authorization

To ensure secure access to the CustomerManagement service's protected endpoints, a project-wide access token is required. This token serves as the primary method for authenticating requests to our service. However, it's important to note that access control varies across different routes:

**Protected API**: 
Certain API (routes) require specific authorization levels. Access to these routes is contingent upon the possession of a valid access token that meets the route-specific authorization criteria. Unauthorized requests to these routes will be rejected.

**Public API **: 
The service also includes public API (routes) that are accessible without authentication. These public endpoints are designed for open access and do not require an access token.

### Token Locations
When including your access token in a request, ensure it is placed in one of the following specified locations. The service will sequentially search these locations for the token, utilizing the first one it encounters.

| Location               | Token Name / Param Name      |
| ---------------------- | ---------------------------- |
| Query                  | access_token                 |
| Authorization Header   | Bearer                       |
| Header                 | fintrack-access-token|
| Header                 | fintrack-access-token-{businessCodename}|
| Cookie                 | fintrack-access-token-{businessCodename}|


Please ensure the token is correctly placed in one of these locations, using the appropriate label as indicated. The service prioritizes these locations in the order listed, processing the first token it successfully identifies.


## Api Definitions
This section outlines the API endpoints available within the CustomerManagement service. Each endpoint can receive parameters through various methods, meticulously described in the following definitions. It's important to understand the flexibility in how parameters can be included in requests to effectively interact with the CustomerManagement service.

This service is configured to listen for HTTP requests on port `3001`, 
serving both the main API interface and default administrative endpoints.

The following routes are available by default:

* **API Test Interface (API Face):** `/`
* **Swagger Documentation:** `/swagger`
* **Postman Collection Download:** `/getPostmanCollection`
* **Health Checks:** `/health` and `/admin/health`
* **Current Session Info:** `/currentuser`
* **Favicon:** `/favicon.ico`

This service is accessible via the following environment-specific URLs:

* **Preview:** `https://fintrack.prw.mindbricks.com/customermanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/customermanagement-api`
* **Production:** `https://fintrack.mindbricks.co/customermanagement-api`

**Parameter Inclusion Methods:**
Parameters can be incorporated into API requests in several ways, each with its designated location. Understanding these methods is crucial for correctly constructing your requests:

**Query Parameters:** Included directly in the URL's query string.

**Path Parameters:** Embedded within the URL's path.

**Body Parameters:** Sent within the JSON body of the request.

**Session Parameters:** Automatically read from the session object. This method is used for parameters that are intrinsic to the user's session, such as userId. When using an API that involves session parameters, you can omit these from your request. The service will automatically bind them to the API layer, provided that a session is associated with your request.

**Note on Session Parameters:**
Session parameters represent a unique method of parameter inclusion, relying on the context of the user's session. A common example of a session parameter is userId, which the service automatically associates with your request when a session exists. This feature ensures seamless integration of user-specific data without manual input for each request.

By adhering to the specified parameter inclusion methods, you can effectively utilize the CustomerManagement service's API endpoints. For detailed information on each endpoint, including required parameters and their accepted locations, refer to the individual API definitions below.

### Common Parameters

The `CustomerManagement` service's business API support several common parameters designed to modify and enhance the behavior of API requests. These parameters are not individually listed in the API route definitions to avoid repetition. Instead, refer to this section to understand how to leverage these common behaviors across different routes. Note that all common parameters should be included in the query part of the URL.

### Supported Common Parameters:

- **getJoins (BOOLEAN)**: Controls whether to retrieve associated objects along with the main object. By default, `getJoins` is assumed to be `true`. Set it to `false` if you prefer to receive only the main fields of an object, excluding its associations.

- **excludeCQRS (BOOLEAN)**: Applicable only when `getJoins` is `true`. By default, `excludeCQRS` is set to `false`. Enabling this parameter (`true`) omits non-local associations, which are typically more resource-intensive as they require querying external services like ElasticSearch for additional information. Use this to optimize response times and resource usage.

- **requestId (String)**: Identifies a request to enable tracking through the service's log chain. A random hex string of 32 characters is assigned by default. If you wish to use a custom `requestId`, simply include it in your query parameters.

- **caching (BOOLEAN)**: Determines the use of caching for query API. By default, caching is enabled (`true`). To ensure the freshest data directly from the database, set this parameter to `false`, bypassing the cache.

- **cacheTTL (Integer)**: Specifies the Time-To-Live (TTL) for query caching, in seconds. This is particularly useful for adjusting the default caching duration (5 minutes) for `get list` queries. Setting a custom `cacheTTL` allows you to fine-tune the cache lifespan to meet your needs.

- **pageNumber (Integer)**: For paginated `get list` API's, this parameter selects which page of results to retrieve. The default is `1`, indicating the first page. To disable pagination and retrieve all results, set `pageNumber` to `0`.

- **pageRowCount (Integer)**: In conjunction with paginated API's, this parameter defines the number of records per page. The default value is `25`. Adjusting `pageRowCount` allows you to control the volume of data returned in a single request.

By utilizing these common parameters, you can tailor the behavior of API requests to suit your specific requirements, ensuring optimal performance and usability of the `CustomerManagement` service.


  ### Multi Tenant Architecture

  The `CustomerManagement` service operates within a multi tenant architecture.
  The service is designed to support multiple tenants, each with its distinct data and configuration. This architecture ensures that data is securely isolated between tenants, preventing unauthorized access and maintaining data integrity.
  The service tenant is called `business` and identified as `businessId`.
  Other than platform users like superAdmin, saasAdmin and saasUser that belong to the root tenant, the tenant creators(owners) and users will all be associated with an business tenant.
  When users login their scope will be isolated only to include one tenant data they below. So user may acces only this logined tennat through out the session. After loging in to e specific tenant, users should include the tenant id in their request to access the tenant data. In each request they may access different tenant data if they belong them. 


  #### Key Points:
  
  - **Tenant-Specific Requests**: It is imperative that each request specifies the tenant it pertains to. This is crucial because most API's are designed to interact exclusively with objects that are part of the specified tenant sandbox.
  - **User Distinction**: The requesting user must have a registration for that tenant. The service searches for a `business` specific token (cookie or bearer) using the provided `business`Id in the request header. Note that to be able to login and use multiple tenant's sites a user must register for them all.
  - **Request Header Parameter**: When making a request, include the desired `businessId` in the request header using the parameter name ``. This signals to the service which domain context to apply for the request processing. Alternatively, you can include the tenant id in the query parameters with the name `businessId`.
  - **Root Tenant**: As all multi tenant architectures this application also has a default root tenant which created automatically. If there is no tenant mark for the request, the request are assumed as to the root tenant. Root tenant is also the hub for registering tenant creating and their owner users. When users register themselves in the root tenant, an (business) will alos be created with the given data in the request body and the user will be asssociated with this new tenant record as the `tenantAdmin`. 
  - **Superadmin account**: A super admin account is created with the given credentials in the design so that there is an absolute user which has all rights in the root tenant and other tenants. This account is used to create and manage all other tenants in the system. 
    - **Tenant Registration**: The `CustomerManagement` service allows for the creation of new tenants only through admin account of the root tenant. So if a new business record is needed, the superadmin or admin roles of the root should create then new tenant and assign any user as the owner of it.
  
  #### Implementation:

  When the user logins there may be few ways for Mindbricks to recognize and set the tenant id in the session.
  1. Mindbricks will check the url of the login request if it matches tenant url.
  2. Mindbricks will check the `` has the tenant id.
  3. Mindbricks will check if the user is associated with a `business` in the data model.
  After you login a tenant successfully, ensure that your requests accurately target objects that fall within the tenant scope set during the login session.
  Ensure your requests are correctly formatted to include the domain sandbox information in the header. This enables the `CustomerManagement` service to accurately identify the domain context, facilitating proper access control and data management based on the user's permissions and the specified domain.  
  ```js
  axios({
    method: 'GET',
    headers: {
      '': 'Your-businessId-here'
    }
    url: "/someroutepath",
    data: {
      "someData":"someData"
    },
    params: {
      "aParam":"aParam"
    }
  });
  ````     
  By adhering to this domain sandbox model, the `CustomerManagement` service maintains a secure and organized structure for handling requests across different domains, ensuring that operations are performed within the correct contextual boundaries.

### Error Response

If a request encounters an issue, whether due to a logical fault or a technical problem, the service responds with a standardized JSON error structure. The HTTP status code within this response indicates the nature of the error, utilizing commonly recognized codes for clarity:

- **400 Bad Request**: The request was improperly formatted or contained invalid parameters, preventing the server from processing it.
- **401 Unauthorized**: The request lacked valid authentication credentials or the credentials provided do not grant access to the requested resource.
- **404 Not Found**: The requested resource was not found on the server.
- **500 Internal Server Error**: The server encountered an unexpected condition that prevented it from fulfilling the request.

Each error response is structured to provide meaningful insight into the problem, assisting in diagnosing and resolving issues efficiently.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```` 

### Object Structure of a Successfull Response

When the `CustomerManagement` service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope not only contains the data but also includes essential metadata, such as configuration details and pagination information, to enrich the response and provide context to the client.

**Key Characteristics of the Response Envelope:**

- **Data Presentation**: Depending on the nature of the request, the service returns either a single data object or an array of objects encapsulated within the JSON envelope.
  - **Creation and Update API**: These API routes return the unmodified (pure) form of the data object(s), without any associations to other data objects.
  - **Delete API**: Even though the data is removed from the database, the last known state of the data object(s) is returned in its pure form.
  - **Get Requests**: A single data object is returned in JSON format.
  - **Get List Requests**: An array of data objects is provided, reflecting a collection of resources.

- **Data Structure and Joins**: The complexity of the data structure in the response can vary based on the API's architectural design and the join options specified in the request. The architecture might inherently limit join operations, or they might be dynamically controlled through query parameters.
  - **Pure Data Forms**: In some cases, the response mirrors the exact structure found in the primary data table, without extensions.
  - **Extended Data Forms**: Alternatively, responses might include data extended through joins with tables within the same service or aggregated from external sources, such as ElasticSearch indices related to other services.
  - **Join Varieties**: The extensions might involve one-to-one joins, resulting in single object associations, or one-to-many joins, leading to an array of objects. In certain instances, the data might even feature nested inclusions from other data objects.

**Design Considerations**: The structure of a API's response data is meticulously crafted during the service's architectural planning. This design ensures that responses adequately reflect the intended data relationships and service logic, providing clients with rich and meaningful information.

**Brief Data**: Certain API's return a condensed version of the object data, intentionally selecting only specific fields deemed useful for that request. In such instances, the API documentation will detail the properties included in the response, guiding developers on what to expect.

### API Response Structure

The API utilizes a standardized JSON envelope to encapsulate responses. This envelope is designed to consistently deliver both the requested data and essential metadata, ensuring that clients can efficiently interpret and utilize the response.

**HTTP Status Codes:**

- **200 OK**: This status code is returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request has been processed successfully.
- **201 Created**: This status code is specific to CREATE operations, signifying that the requested resource has been successfully created.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling the successful execution of the request. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
````

- **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation performed.

**Handling Errors:**

For details on handling error scenarios and understanding the structure of error responses, please refer to the "Error Response" section provided earlier in this documentation. It outlines how error conditions are communicated, including the use of HTTP status codes and standardized JSON structures for error messages.

## Resources 
CustomerManagement service provides the following resources which are stored in its own database as a data object. Note that a resource for an api access is a data object for the service.

### Customer resource

*Resource Definition* : Business customer/contact record, uniquely scoped to business. Contains info required for sales, invoicing, and reporting. Not shared across tenants.
*Customer Resource Properties* 
| Name | Type | Required | Default | Definition | 
| ---- | ---- | -------- | ------- | ---------- |
| **address** | Text |  |  | *Full postal address, optional, multi-line, Unicode supported.* |
| **contactEmail** | String |  |  | *Primary contact&#39;s email address (optional, for notifications or info).* |
| **contactName** | String |  |  | *Primary contact person&#39;s name (optional, for individual or company).* |
| **name** | String |  |  | *Full customer display name (required).* |
| **notes** | Text |  |  | *Internal notes/comments about the customer, never public.* |
| **phone** | String |  |  | *Main phone number for contact (optional).* |
| **taxNumber** | String |  |  | *Tax/VAT identification number or code (optional).* |
| **businessId** | ID |  |  | *An ID value to represent the tenant id of the business* |
## Business Api
### `Create Customer` API
Create a new customer for the current business. Owners/Accountants/Users within the business can create; customers are private to tenant.

**API Frontend Description By The Backend Architect**

After create, new customer should be listed and available for invoice selections. Minimal required input: name. Optional: tax, contact, address, notes.

**Rest Route**

The `createCustomer` API REST controller can be triggered via the following route:

`/v1/customers`


**Rest Request Parameters**


The `createCustomer` api has got 7 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| address  | Text  | false | request.body?.["address"] |
| contactEmail  | String  | false | request.body?.["contactEmail"] |
| contactName  | String  | false | request.body?.["contactName"] |
| name  | String  | true | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| phone  | String  | false | request.body?.["phone"] |
| taxNumber  | String  | false | request.body?.["taxNumber"] |
**address** : Full postal address, optional, multi-line, Unicode supported.
**contactEmail** : Primary contact's email address (optional, for notifications or info).
**contactName** : Primary contact person's name (optional, for individual or company).
**name** : Full customer display name (required).
**notes** : Internal notes/comments about the customer, never public.
**phone** : Main phone number for contact (optional).
**taxNumber** : Tax/VAT identification number or code (optional).


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/customers**
```js
  axios({
    method: 'POST',
    url: '/v1/customers',
    data: {
            address:"Text",  
            contactEmail:"String",  
            contactName:"String",  
            name:"String",  
            notes:"Text",  
            phone:"String",  
            taxNumber:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Customer` API
Soft-delete (deactivate) a customer. Only Owner/Accountant may delete. Deleted customers are hidden in lists and searches but preserved for audit/history.

**API Frontend Description By The Backend Architect**

On delete, customer disappears from active lists and selectors but is preserved for history. Confirm via dialog.

**Rest Route**

The `deleteCustomer` API REST controller can be triggered via the following route:

`/v1/customers/:customerId`


**Rest Request Parameters**


The `deleteCustomer` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| customerId  | ID  | true | request.params?.["customerId"] |
**customerId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/customers/:customerId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/customers/${customerId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Customer` API
Get details of a specific customer by ID, for use in details screens or invoice selectors. All roles in the business may view.

**API Frontend Description By The Backend Architect**

Show all customer fields. Used on customer detail screen and as lookup for invoice or reporting.

**Rest Route**

The `getCustomer` API REST controller can be triggered via the following route:

`/v1/customers/:customerId`


**Rest Request Parameters**


The `getCustomer` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| customerId  | ID  | true | request.params?.["customerId"] |
**customerId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/customers/:customerId**
```js
  axios({
    method: 'GET',
    url: `/v1/customers/${customerId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `List Customers` API
List all customers for the current business. Any role can search/filter by name, tax number, or contact. Results are scoped to current tenant.

**API Frontend Description By The Backend Architect**

List screen allows filtering by name, tax, contact info. Table view recommended. Customers appear in invoice pickers and balance reports.

**Rest Route**

The `listCustomers` API REST controller can be triggered via the following route:

`/v1/customers`


**Rest Request Parameters**
The `listCustomers` api has got no request parameters.    



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/customers**
```js
  axios({
    method: 'GET',
    url: '/v1/customers',
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customers",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"customers": [
		{
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Customer` API
Update an existing customer. Owners/Accountants can update all fields; Users cannot update existing records.

**API Frontend Description By The Backend Architect**

Update screen shows all editable fields. Business/tenant context enforced. Record remains available for invoice selection if active.

**Rest Route**

The `updateCustomer` API REST controller can be triggered via the following route:

`/v1/customers/:customerId`


**Rest Request Parameters**


The `updateCustomer` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| customerId  | ID  | true | request.params?.["customerId"] |
| address  | Text  | false | request.body?.["address"] |
| contactEmail  | String  | false | request.body?.["contactEmail"] |
| contactName  | String  | false | request.body?.["contactName"] |
| name  | String  | false | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| phone  | String  | false | request.body?.["phone"] |
| taxNumber  | String  | false | request.body?.["taxNumber"] |
**customerId** : This id paremeter is used to select the required data object that will be updated
**address** : Full postal address, optional, multi-line, Unicode supported.
**contactEmail** : Primary contact's email address (optional, for notifications or info).
**contactName** : Primary contact person's name (optional, for individual or company).
**name** : Full customer display name (required).
**notes** : Internal notes/comments about the customer, never public.
**phone** : Main phone number for contact (optional).
**taxNumber** : Tax/VAT identification number or code (optional).


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/customers/:customerId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/customers/${customerId}`,
    data: {
            address:"Text",  
            contactEmail:"String",  
            contactName:"String",  
            name:"String",  
            notes:"Text",  
            phone:"String",  
            taxNumber:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `_fetch Listcustomer` API
System API to fetch list of customer records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListCustomer` API REST controller can be triggered via the following route:

`/v1/_fetchlistcustomer`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListCustomer` api supports 5 optional filter parameters for filtering list results:

**contactEmail** (`String`): Primary contact's email address (optional, for notifications or info).

- Single (partial match, case-insensitive): `?contactEmail=<value>`
- Multiple: `?contactEmail=<value1>&contactEmail=<value2>`
- Null: `?contactEmail=null`


**contactName** (`String`): Primary contact person's name (optional, for individual or company).

- Single (partial match, case-insensitive): `?contactName=<value>`
- Multiple: `?contactName=<value1>&contactName=<value2>`
- Null: `?contactName=null`


**name** (`String`): Full customer display name (required).

- Single (partial match, case-insensitive): `?name=<value>`
- Multiple: `?name=<value1>&name=<value2>`
- Null: `?name=null`


**phone** (`String`): Main phone number for contact (optional).

- Single (partial match, case-insensitive): `?phone=<value>`
- Multiple: `?phone=<value1>&phone=<value2>`
- Null: `?phone=null`


**taxNumber** (`String`): Tax/VAT identification number or code (optional).

- Single (partial match, case-insensitive): `?taxNumber=<value>`
- Multiple: `?taxNumber=<value1>&taxNumber=<value2>`
- Null: `?taxNumber=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistcustomer**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistcustomer',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // contactEmail: '<value>' // Filter by contactEmail
        // contactName: '<value>' // Filter by contactName
        // name: '<value>' // Filter by name
        // phone: '<value>' // Filter by phone
        // taxNumber: '<value>' // Filter by taxNumber
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customers",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"customers": [
		{
			"id": "ID",
			"address": "Text",
			"contactEmail": "String",
			"contactName": "String",
			"name": "String",
			"notes": "Text",
			"phone": "String",
			"taxNumber": "String",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID"
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```


### Authentication Specific Routes



### Common Routes

### Route: currentuser

*Route Definition*: Retrieves the currently authenticated user's session information.

*Route Type*: sessionInfo

*Access Route*: `GET /currentuser`

#### Parameters

This route does **not** require any request parameters.

#### Behavior

- Returns the authenticated session object associated with the current access token.
- If no valid session exists, responds with a 401 Unauthorized.

```js
// Sample GET /currentuser call
axios.get("/currentuser", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````
**Success Response**
Returns the session object, including user-related data and token information.
````
{
  "sessionId": "9cf23fa8-07d4-4e7c-80a6-ec6d6ac96bb9",
  "userId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  "email": "user@example.com",
  "fullname": "John Doe",
  "roleId": "user",
  "tenantId": "abc123",
  "accessToken": "jwt-token-string",
  ...
}
````
**Error Response**
**401 Unauthorized:** No active session found.
````
{
  "status": "ERR",
  "message": "No login found"
}
````

**Notes**
* This route is typically used by frontend or mobile applications to fetch the current session state after login.
* The returned session includes key user identity fields, tenant information (if applicable), and the access token for further authenticated requests.
* Always ensure a valid access token is provided in the request to retrieve the session.

### Route: permissions

`*Route Definition*`: Retrieves all effective permission records assigned to the currently authenticated user.

`*Route Type*`: permissionFetch

*Access Route*: `GET /permissions`

#### Parameters

This route does **not** require any request parameters.

#### Behavior

- Fetches all active permission records (`givenPermissions` entries) associated with the current user session.
- Returns a full array of permission objects.
- Requires a valid session (`access token`) to be available.

```js
// Sample GET /permissions call
axios.get("/permissions", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````
**Success Response**

Returns an array of permission objects.
```json
[
  {
    "id": "perm1",
    "permissionName": "adminPanel.access",
    "roleId": "admin",
    "subjectUserId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
    "subjectUserGroupId": null,
    "objectId": null,
    "canDo": true,
    "tenantCodename": "store123"
  },
  {
    "id": "perm2",
    "permissionName": "orders.manage",
    "roleId": null,
    "subjectUserId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
    "subjectUserGroupId": null,
    "objectId": null,
    "canDo": true,
    "tenantCodename": "store123"
  }
]
````
Each object reflects a single permission grant, aligned with the givenPermissions model:

- `**permissionName**`: The permission the user has.
- `**roleId**`: If the permission was granted through a role.
-` **subjectUserId**`: If directly granted to the user.
- `**subjectUserGroupId**`: If granted through a group.
- `**objectId**`: If tied to a specific object (OBAC).
- `**canDo**`: True or false flag to represent if permission is active or restricted.

**Error Responses**
* **401 Unauthorized**: No active session found.
```json
{
  "status": "ERR",
  "message": "No login found"
}
````
* **500 Internal Server Error**: Unexpected error fetching permissions.

**Notes**
* The /permissions route is available across all backend services generated by Mindbricks, not just the auth service.
* Auth service: Fetches permissions freshly from the live database (givenPermissions table).
* Other services: Typically use a cached or projected view of permissions stored in a common ElasticSearch store, optimized for faster authorization checks.

> **Tip**:
> Applications can cache permission results client-side or server-side, but should occasionally refresh by calling this endpoint, especially after login or permission-changing operations.

### Route: permissions/:permissionName

*Route Definition*: Checks whether the current user has access to a specific permission, and provides a list of scoped object exceptions or inclusions.

*Route Type*: permissionScopeCheck

*Access Route*: `GET /permissions/:permissionName`

#### Parameters

| Parameter         | Type   | Required | Population             |
|------------------|--------|----------|------------------------|
| permissionName   | String | Yes      | `request.params.permissionName` |

#### Behavior

- Evaluates whether the current user **has access** to the given `permissionName`.
- Returns a structured object indicating:
  - Whether the permission is generally granted (`canDo`)
  - Which object IDs are explicitly included or excluded from access (`exceptions`)
- Requires a valid session (`access token`).

```js
// Sample GET /permissions/orders.manage
axios.get("/permissions/orders.manage", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````

**Success Response**

```json
{
  "canDo": true,
  "exceptions": [
    "a1f2e3d4-xxxx-yyyy-zzzz-object1",
    "b2c3d4e5-xxxx-yyyy-zzzz-object2"
  ]
}
````

* If `canDo` is `true`, the user generally has the permission, but not for the objects listed in `exceptions` (i.e., restrictions).
* If `canDo` is `false`, the user does not have the permission by default — but only for the objects in `exceptions`, they do have permission (i.e., selective overrides).
* The exceptions array contains valid **UUID strings**, each corresponding to an object ID (typically from the data model targeted by the permission).

## Copyright
All sources, documents and other digital materials are copyright of .

## About Us
For more information please visit our website: .

.
.


---

<a id="customermanagement-service-event-guide"></a>

## EVENT GUIDE

# EVENT GUIDE
## fintrack-customermanagement-service

Handles all business-specific customer CRUD operations and exposes customer data for sales invoice and reporting workflows. Ensures strict tenant (business) isolation for all customer records and supports role-based access control per business context.

## Architectural Design Credit and Contact Information

The architectural design of this microservice is credited to . For inquiries, feedback, or further information regarding the architecture, please direct your communication to:

Email: 

We encourage open communication and welcome any questions or discussions related to the architectural aspects of this microservice.

# Documentation Scope

Welcome to the official documentation for the `CustomerManagement` Service Event descriptions. This guide is dedicated to detailing how to subscribe to and listen for state changes within the `CustomerManagement` Service, offering an exclusive focus on event subscription mechanisms.

**Intended Audience**

This documentation is aimed at developers and integrators looking to monitor `CustomerManagement` Service state changes. It is especially relevant for those wishing to implement or enhance business logic based on interactions with `CustomerManagement` objects.

**Overview**

This section provides detailed instructions on monitoring service events, covering payload structures and demonstrating typical use cases through examples.

# Authentication and Authorization

Access to the `CustomerManagement` service's events is facilitated through the project's Kafka server, which is not accessible to the public. Subscription to a Kafka topic requires being on the same network and possessing valid Kafka user credentials.  This document presupposes that readers have existing access to the Kafka server.

Additionally, the service offers a public subscription option via REST for real-time data management in frontend applications, secured through REST API authentication and authorization mechanisms. To subscribe to service events via the REST API, please consult the Realtime REST API Guide.

# Database Events

Database events are triggered at the database layer, automatically and atomically, in response to any modifications at the data level. These events serve to notify subscribers about the creation, update, or deletion of objects within the database, distinct from any overarching business logic. 

Listening to database events is particularly beneficial for those focused on tracking changes at the database level. A typical use case for subscribing to database events is to replicate the data store of one service within another service's scope, ensuring data consistency and syncronization across services.

For example, while a business operation such as "approve membership" might generate a high-level business event like `membership-approved`, the underlying database changes could involve multiple state updates to different entities. These might be published as separate events, such as `dbevent-member-updated` and `dbevent-user-updated`, reflecting the granular changes at the database level.

Such detailed eventing provides a robust foundation for building responsive, data-driven applications, enabling fine-grained observability and reaction to the dynamics of the data landscape. It also facilitates the architectural pattern of event sourcing, where state changes are captured as a sequence of events, allowing for high-fidelity data replication and history replay for analytical or auditing purposes.

## DbEvent customer-created

**Event topic**: `fintrack-customermanagement-service-dbevent-customer-created`

This event is triggered upon the creation of a `customer` data object in the database. The event payload encompasses the newly created data, encapsulated within the root of the paylod.

**Event payload**: 
```json
{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  
## DbEvent customer-updated

**Event topic**: `fintrack-customermanagement-service-dbevent-customer-updated`

Activation of this event follows the update of a `customer` data object. The payload contains the updated information under the `customer` attribute, along with the original data prior to update, labeled as `old_customer` and also you can find the old and new versions of updated-only portion of the data..

**Event payload**: 
```json
{
old_customer:{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
customer:{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
oldDataValues,
newDataValues
}
``` 
## DbEvent customer-deleted

**Event topic**: `fintrack-customermanagement-service-dbevent-customer-deleted`

This event announces the deletion of a `customer` data object, covering both hard deletions (permanent removal) and soft deletions (where the `isActive` attribute is set to false). Regardless of the deletion type, the event payload will present the data as it was immediately before deletion, highlighting an `isActive` status of false for soft deletions.

**Event payload**: 
```json
{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  


# ElasticSearch Index Events

Within the `CustomerManagement` service, most data objects are mirrored in ElasticSearch indices, ensuring these indices remain syncronized with their database counterparts through creation, updates, and deletions. These indices serve dual purposes: they act as a data source for external services and furnish aggregated data tailored to enhance frontend user experiences. Consequently, an ElasticSearch index might encapsulate data in its original form or aggregate additional information from other data objects. 

These aggregations can include both one-to-one and one-to-many relationships not only with database objects within the same service but also across different services. This capability allows developers to access comprehensive, aggregated data efficiently. By subscribing to ElasticSearch index events, developers are notified when an index is updated and can directly obtain the aggregated entity within the event payload, bypassing the need for separate ElasticSearch queries.

It's noteworthy that some services may augment another service's index by appending to the entity’s `extends` object. In such scenarios, an `*-extended` event will contain only the newly added data. Should you require the complete dataset, you would need to retrieve the full ElasticSearch index entity using the provided ID.

This approach to indexing and event handling facilitates a modular, interconnected architecture where services can seamlessly integrate and react to changes, enriching the overall data ecosystem and enabling more dynamic, responsive applications.



## Index Event customer-created

**Event topic**: `elastic-index-fintrack_customer-created`

**Event payload**:
```json
{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event customer-updated

**Event topic**: `elastic-index-fintrack_customer-created`

**Event payload**:
```json
{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event customer-deleted

**Event topic**: `elastic-index-fintrack_customer-deleted`

**Event payload**:
```json
{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event customer-extended

**Event topic**: `elastic-index-fintrack_customer-extended`

**Event payload**:
```js
{
  id: id,
  extends: {
    [extendName]: "Object",
    [extendName + "_count"]: "Number",
  },
}
``` 

# Route Events

Route events are emitted following the successful execution of a route. While most routes perform CRUD (Create, Read, Update, Delete) operations on data objects, resulting in route events that closely resemble database events, there are distinctions worth noting. A single route execution might trigger multiple CRUD actions and ElasticSearch indexing operations. However, for those primarily concerned with the overarching business logic and its outcomes, listening to the consolidated route event, published once at the conclusion of the route's execution, is more pertinent.

Moreover, routes often deliver aggregated data beyond the primary database object, catering to specific client needs. For instance, creating a data object via a route might not only return the entity's data but also route-specific metrics, such as the executing user's permissions related to the entity. Alternatively, a route might automatically generate default child entities following the creation of a parent object. Consequently, the route event encapsulates a unified dataset encompassing both the parent and its children, in contrast to individual events triggered for each entity created. Therefore, subscribing to route events can offer a richer, more contextually relevant set of information aligned with business logic.

The payload of a route event mirrors the REST response JSON of the route, providing a direct and comprehensive reflection of the data and metadata communicated to the client. This ensures that subscribers to route events receive a payload that encapsulates both the primary data involved and any additional information deemed significant at the business level, facilitating a deeper understanding and integration of the service's functional outcomes.


## Route Event customer-created

**Event topic** : `fintrack-customermanagement-service-customer-created`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `customer` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`customer`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"201","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"customer","method":"POST","action":"create","appVersion":"Version","rowCount":1,"customer":{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event customer-deleted

**Event topic** : `fintrack-customermanagement-service-customer-deleted`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `customer` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`customer`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"customer","method":"DELETE","action":"delete","appVersion":"Version","rowCount":1,"customer":{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event customer-retrived

**Event topic** : `fintrack-customermanagement-service-customer-retrived`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `customer` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`customer`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"customer","method":"GET","action":"get","appVersion":"Version","rowCount":1,"customer":{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event customers-listed

**Event topic** : `fintrack-customermanagement-service-customers-listed`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `customers` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`customers`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"customers","method":"GET","action":"list","appVersion":"Version","rowCount":"\"Number\"","customers":[{"isActive":true},{},{}],"paging":{"pageNumber":"Number","pageRowCount":"NUmber","totalRowCount":"Number","pageCount":"Number"},"filters":[],"uiPermissions":[]}
```  
## Route Event customer-updated

**Event topic** : `fintrack-customermanagement-service-customer-updated`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `customer` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`customer`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"customer","method":"PATCH","action":"update","appVersion":"Version","rowCount":1,"customer":{"id":"ID","address":"Text","contactEmail":"String","contactName":"String","name":"String","notes":"Text","phone":"String","taxNumber":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  




# Copyright
All sources, documents and other digital materials are copyright of .

# About Us
For more information please visit our website: .

.
.


---

## Data Objects

<a id="customermanagement-service-customer-design"></a>

### Service Design Specification - Object Design for customer

# Service Design Specification - Object Design for customer
**fintrack-customermanagement-service** documentation

## Document Overview
This document outlines the object design for the `customer` model in our application. It includes details about the model's attributes, relationships, and any specific validation or business logic that applies.

## customer Data Object

### Object Overview
**Description:** Business customer/contact record, uniquely scoped to business. Contains info required for sales, invoicing, and reporting. Not shared across tenants.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessProtected — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.








### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `address` | Text | No | Full postal address, optional, multi-line, Unicode supported. |
| `contactEmail` | String | No | Primary contact&#39;s email address (optional, for notifications or info). |
| `contactName` | String | No | Primary contact person&#39;s name (optional, for individual or company). |
| `name` | String | Yes | Full customer display name (required). |
| `notes` | Text | No | Internal notes/comments about the customer, never public. |
| `phone` | String | No | Main phone number for contact (optional). |
| `taxNumber` | String | No | Tax/VAT identification number or code (optional). |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **name**: 'default'
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`address` `contactEmail` `contactName` `name` `notes` `phone` `taxNumber`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

 

 

### Elastic Search Indexing

`address` `contactEmail` `contactName` `name` `phone` `taxNumber` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`name` `taxNumber` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.





### Secondary Key Properties

`businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.






### Filter Properties

`contactEmail` `contactName` `name` `phone` `taxNumber` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **contactEmail**: String  has a filter named `contactEmail`

- **contactName**: String  has a filter named `contactName`

- **name**: String  has a filter named `name`

- **phone**: String  has a filter named `phone`

- **taxNumber**: String  has a filter named `taxNumber`

- **businessId**: ID  has a filter named `businessId`



  

---

## Business APIs

<a id="customermanagement-service-business-api-createcustomer-api-design"></a>

### Business API Design Specification - `Create Customer`


# Business API Design Specification - `Create Customer`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `createCustomer` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `createCustomer` Business API is designed to handle a `create` operation on the `Customer` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Create a new customer for the current business. Owners/Accountants/Users within the business can create; customers are private to tenant.

## API Frontend Description By The Backend Architect

After create, new customer should be listed and available for invoice selections. Minimal required input: name. Optional: tax, contact, address, notes.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `customer-created` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `createCustomer` Business API includes a REST controller that can be triggered via the following route:

`/v1/customers`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `createCustomer` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `createCustomer` Business API has 8 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `customerId`                             | `ID`   | `No` | `-` | `body` | `customerId` |
| **Description:**                                | This id paremeter is used to create the data object with a given specific id. Leave null for automatic id. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `address`                             | `Text`   | `No` | `-` | `body` | `address` |
| **Description:**                                | Full postal address, optional, multi-line, Unicode supported. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `contactEmail`                             | `String`   | `No` | `-` | `body` | `contactEmail` |
| **Description:**                                | Primary contact's email address (optional, for notifications or info). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `contactName`                             | `String`   | `No` | `-` | `body` | `contactName` |
| **Description:**                                | Primary contact person's name (optional, for individual or company). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `name`                             | `String`   | `Yes` | `-` | `body` | `name` |
| **Description:**                                | Full customer display name (required). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `notes`                             | `Text`   | `No` | `-` | `body` | `notes` |
| **Description:**                                | Internal notes/comments about the customer, never public. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `phone`                             | `String`   | `No` | `-` | `body` | `phone` |
| **Description:**                                | Main phone number for contact (optional). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `taxNumber`                             | `String`   | `No` | `-` | `body` | `taxNumber` |
| **Description:**                                | Tax/VAT identification number or code (optional). |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `createCustomer` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[user]`




---





## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 



**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  id: this.customerId,
  businessId: this.businessId,
  address: this.address,
  contactEmail: this.contactEmail,
  contactName: this.contactName,
  name: this.name,
  notes: this.notes,
  phone: this.phone,
  taxNumber: this.taxNumber,
  isActive: true,
  _archivedAt: null,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, populates session and request objects, prepares internal structures for parameter handling and workflow execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads input parameters, normalizes missing values, applies default type casting, and stores them in the API context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager transforms parameters, computes derived values, flattens or remaps arrays/objects, and adjusts formats for downstream processing.


---




### [4] Step : checkParameters

Manager executes built-in validations: required field checks, type enforcement, and basic business rules. Prevents operation if validation fails.


---




### [5] Step : checkBasicAuth

Manager performs authentication and authorization checks: verifies session, user roles, permissions, and tenant restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildDataClause

Manager constructs the final data object for creation, fills auto-generated fields (IDs, timestamps, owner fields), and ensures schema consistency.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [7] Step : mainCreateOperation

Manager executes the database insert operation, updates indexes/caches, and triggers internal post-processing like linked default records.


---




### [8] Step : buildOutput

Manager shapes the response: masks sensitive fields, resolves linked references, and formats output according to API contract.


---




### [9] Step : sendResponse

Manager sends the response to the client and finalizes internal tasks like flushing logs or updating session state.


---




### [10] Step : raiseApiEvent

Manager triggers API-level events (Kafka, WebSocket, async workflows) as the final internal step.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `createCustomer` api has got 7 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| address  | Text  | false | request.body?.["address"] |
| contactEmail  | String  | false | request.body?.["contactEmail"] |
| contactName  | String  | false | request.body?.["contactName"] |
| name  | String  | true | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| phone  | String  | false | request.body?.["phone"] |
| taxNumber  | String  | false | request.body?.["taxNumber"] |

### REST Request
To access the api you can use the **REST** controller with the path **POST  /v1/customers**
```js
  axios({
    method: 'POST',
    url: '/v1/customers',
    data: {
            address:"Text",  
            contactEmail:"String",  
            contactName:"String",  
            name:"String",  
            notes:"Text",  
            phone:"String",  
            taxNumber:"String",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`customer`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="customermanagement-service-business-api-deletecustomer-api-design"></a>

### Business API Design Specification - `Delete Customer`


# Business API Design Specification - `Delete Customer`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `deleteCustomer` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `deleteCustomer` Business API is designed to handle a `delete` operation on the `Customer` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Soft-delete (deactivate) a customer. Only Owner/Accountant may delete. Deleted customers are hidden in lists and searches but preserved for audit/history.

## API Frontend Description By The Backend Architect

On delete, customer disappears from active lists and selectors but is preserved for history. Confirm via dialog.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `customer-deleted` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `deleteCustomer` Business API includes a REST controller that can be triggered via the following route:

`/v1/customers/:customerId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `deleteCustomer` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `deleteCustomer` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `customerId`                             | `ID`   | `Yes` | `-` | `urlpath` | `customerId` |
| **Description:**                                | This id paremeter is used to select the required data object that will be deleted |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `deleteCustomer` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`






---



## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.customerId},{businessId:this.businessId,isActive:true}]}
```





## Delete Options
Use these options to set `delete` specific settings.

**useSoftDelete**: true
If true, the record will be marked as deleted `(isActive: false)` instead of removed. The implementation depends on the data object’s soft delete configuration.





   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, prepares request/session objects, and sets up internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads and normalizes parameters, applies defaults, and stores them in the context for downstream steps.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager executes parameter transform scripts, computes derived values, and remaps objects or arrays as needed for later processing.


---




### [4] Step : checkParameters

Manager runs built-in validations including required field checks, type enforcement, and deletion preconditions. Stops execution if validation fails.


---




### [5] Step : checkBasicAuth

Manager validates session, user roles, permissions, and tenant-specific access rules to enforce basic auth restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Manager generates the query conditions, applies ownership and parent checks, and ensures the clause is correct for the delete operation.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : fetchInstance

Manager fetches the target record, applies filters from WHERE clause, and writes the instance to the context for further checks.


---




### [8] Step : checkInstance

Manager performs object-level validations such as lock status, soft-delete eligibility, and multi-step approval enforcement.


---




### [9] Step : mainDeleteOperation

Manager executes the delete query, updates related indexes/caches, and handles soft/hard delete logic according to configuration.


You can use the following settings to change some behavior of this step.
`deleteOptions`
---




### [10] Step : buildOutput

Manager shapes the response payload, masks sensitive fields, and formats related cleanup results for output.


---




### [11] Step : sendResponse

Manager delivers the response to the client and finalizes any temporary internal structures.


---




### [12] Step : raiseApiEvent

Manager triggers asynchronous API events, notifies queues or streams, and performs final cleanup for the workflow.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `deleteCustomer` api has got 1 regular client parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| customerId  | ID  | true | request.params?.["customerId"] |

### REST Request
To access the api you can use the **REST** controller with the path **DELETE  /v1/customers/:customerId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/customers/${customerId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`customer`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="customermanagement-service-business-api-getcustomer-api-design"></a>

### Business API Design Specification - `Get Customer`


# Business API Design Specification - `Get Customer`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `getCustomer` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `getCustomer` Business API is designed to handle a `get` operation on the `Customer` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Get details of a specific customer by ID, for use in details screens or invoice selectors. All roles in the business may view.

## API Frontend Description By The Backend Architect

Show all customer fields. Used on customer detail screen and as lookup for invoice or reporting.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `customer-retrived` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `getCustomer` Business API includes a REST controller that can be triggered via the following route:

`/v1/customers/:customerId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `getCustomer` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `getCustomer` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `customerId`                             | `ID`   | `Yes` | `-` | `urlpath` | `customerId` |
| **Description:**                                | This id paremeter is used to query the required data object. |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `getCustomer` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, user, tenantOwner, superAdmin]`






---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

``


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.customerId},{businessId:this.businessId,isActive:true}]}
```







## Get Options
Use these options to set `get` specific settings.

**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.





   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Extracts parameters from request and Redis, applies defaults, and writes them to context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Executes parameter transformation scripts, applies type coercion, merges derived values, and reshapes inputs for downstream milestones.


---




### [4] Step : checkParameters

Validates required and custom parameters, enforcing business-specific rules and constraints.


---




### [5] Step : checkBasicAuth

Performs login, role, and permission checks, and applies dynamic object-level access rules.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Builds the WHERE clause for fetching the object and applies additional scoped filters if configured.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainGetOperation

Executes the database fetch, retrieves the object, and stores it in context for enrichment or further checks.


You can use the following settings to change some behavior of this step.
`selectClause`, `getOptions`
---




### [8] Step : checkInstance

Performs instance-level validations, such as ownership, existence, or access conditions.


---




### [9] Step : buildOutput

Assembles the response from the object, applies masking, formatting, and injects additional metadata if needed.


---




### [10] Step : sendResponse

Delivers the response to the controller for client delivery.


---




### [11] Step : raiseApiEvent

Triggers optional API-level events after workflow completion, sending messages to integrations like Kafka if configured.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `getCustomer` api has got 1 regular client parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| customerId  | ID  | true | request.params?.["customerId"] |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/customers/:customerId**
```js
  axios({
    method: 'GET',
    url: `/v1/customers/${customerId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`customer`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="customermanagement-service-business-api-listcustomers-api-design"></a>

### Business API Design Specification - `List Customers`


# Business API Design Specification - `List Customers`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `listCustomers` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `listCustomers` Business API is designed to handle a `list` operation on the `Customer` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

List all customers for the current business. Any role can search/filter by name, tax number, or contact. Results are scoped to current tenant.

## API Frontend Description By The Backend Architect

List screen allows filtering by name, tax, contact info. Table view recommended. Customers appear in invoice pickers and balance reports.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `customers-listed` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `listCustomers` Business API includes a REST controller that can be triggered via the following route:

`/v1/customers`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `listCustomers` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters


The `listCustomers` Business API does not require any parameters to be provided from the controllers.

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `listCustomers` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, user, tenantOwner, superAdmin]`






---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

`id`,`name`,`taxNumber`,`contactName`,`contactEmail`,`phone`,`address`,`notes`


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{businessId:this.businessId,isActive:true}
```









## List Options
Defines list-specific options including filtering logic, default sorting, and result customization for APIs that return multiple records.

**List Sort By**
Sort order definitions for the result set. Multiple fields can be provided with direction (asc/desc).

[ name asc ]


**List Group By**
Grouping definitions for the result set. This is typically used for visual or report-based grouping.

*The list is not grouped.*



**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.


**Permission Filter**
Optional filter that applies permission constraints dynamically based on session or object roles. So that the list items are filtered by the user's OBAC or ABAC permissions.

*Permission filter is not active at the moment. Follow Mindbricks updates to be able to use it.*

## Pagination Options
Contains settings to configure pagination behavior for `list` APIs. Includes options like page size, offset, cursor support, and total count inclusion.



   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Reads request and Redis parameters, applies defaults, and writes them to context for downstream processing.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Transforms and normalizes parameters, derives dependent values, and reshapes inputs for the main list query.


---




### [4] Step : checkParameters

Executes validation logic on required and custom parameters, enforcing business rules and cross-field consistency.


---




### [5] Step : checkBasicAuth

Performs role-based access checks and applies dynamic membership or session-based restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Constructs the main query WHERE clause and applies optional filters or scoped access controls.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainListOperation

Executes the paginated database query, retrieves the list, and stores results in context for enrichment.


You can use the following settings to change some behavior of this step.
`selectClause`, `listOptions`, `paginationOptions`
---




### [8] Step : buildOutput

Assembles the list response, sanitizes sensitive fields, applies transformations, and injects extra context if needed.


---




### [9] Step : sendResponse

Sends the paginated list to the client through the controller.


---




### [10] Step : raiseApiEvent

Triggers optional post-workflow events, such as Kafka messages, logs, or system notifications.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.
The `listCustomers` api has got no visible parameters.    

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/customers**
```js
  axios({
    method: 'GET',
    url: '/v1/customers',
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`customers`** object in the respones. However, some properties may be omitted based on the object's internal logic.

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customers",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"customers": [
		{
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```  

---

<a id="customermanagement-service-business-api-updatecustomer-api-design"></a>

### Business API Design Specification - `Update Customer`


# Business API Design Specification - `Update Customer`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `updateCustomer` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `updateCustomer` Business API is designed to handle a `update` operation on the `Customer` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Update an existing customer. Owners/Accountants can update all fields; Users cannot update existing records.

## API Frontend Description By The Backend Architect

Update screen shows all editable fields. Business/tenant context enforced. Record remains available for invoice selection if active.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `customer-updated` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `updateCustomer` Business API includes a REST controller that can be triggered via the following route:

`/v1/customers/:customerId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `updateCustomer` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `updateCustomer` Business API has 8 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `customerId`                             | `ID`   | `Yes` | `-` | `urlpath` | `customerId` |
| **Description:**                                | This id paremeter is used to select the required data object that will be updated |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `address`                             | `Text`   | `No` | `-` | `body` | `address` |
| **Description:**                                | Full postal address, optional, multi-line, Unicode supported. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `contactEmail`                             | `String`   | `No` | `-` | `body` | `contactEmail` |
| **Description:**                                | Primary contact's email address (optional, for notifications or info). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `contactName`                             | `String`   | `No` | `-` | `body` | `contactName` |
| **Description:**                                | Primary contact person's name (optional, for individual or company). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `name`                             | `String`   | `No` | `-` | `body` | `name` |
| **Description:**                                | Full customer display name (required). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `notes`                             | `Text`   | `No` | `-` | `body` | `notes` |
| **Description:**                                | Internal notes/comments about the customer, never public. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `phone`                             | `String`   | `No` | `-` | `body` | `phone` |
| **Description:**                                | Main phone number for contact (optional). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `taxNumber`                             | `String`   | `No` | `-` | `body` | `taxNumber` |
| **Description:**                                | Tax/VAT identification number or code (optional). |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `updateCustomer` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`






---



## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.customerId},{businessId:this.businessId,isActive:true}]}
```




## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 


An update data clause populates all update-allowed properties of a data object, however the null properties (that are not provided by client) are ignored in db layer.


**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  address: this.address,
  contactEmail: this.contactEmail,
  contactName: this.contactName,
  name: this.name,
  notes: this.notes,
  phone: this.phone,
  taxNumber: this.taxNumber,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, prepares request and session objects, and sets up internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads parameters from the request or Redis, applies defaults, and writes them into context for downstream milestones.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager executes parameter transform scripts and derives any helper values or reshaped payloads into the context.


---




### [4] Step : checkParameters

Manager validates required parameters, checks ID formats (UUID/ObjectId), and ensures all preconditions for update are met.


---




### [5] Step : checkBasicAuth

Manager performs login verification, role, and permission checks, enforcing tenant and access rules before update.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Manager constructs the WHERE clause used to identify the record to update, applying ownership and parent checks if necessary.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : fetchInstance

Manager fetches the existing record from the database and writes it to the context for validation or enrichment.


---




### [8] Step : checkInstance

Manager performs instance-level validations, including ownership, existence, lock status, or other pre-update checks.


---




### [9] Step : buildDataClause

Manager prepares the data clause for the update, applying transformations or enhancements before persisting.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [10] Step : mainUpdateOperation

Manager executes the update operation with the WHERE and data clauses. Database-level events are raised if configured.


---




### [11] Step : buildOutput

Manager assembles the response object from the update result, masking fields or injecting additional metadata.


---




### [12] Step : sendResponse

Manager sends the response back to the controller for delivery to the client.


---




### [13] Step : raiseApiEvent

Manager triggers API-level events, sending relevant messages to Kafka or other integrations if configured.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `updateCustomer` api has got 8 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| customerId  | ID  | true | request.params?.["customerId"] |
| address  | Text  | false | request.body?.["address"] |
| contactEmail  | String  | false | request.body?.["contactEmail"] |
| contactName  | String  | false | request.body?.["contactName"] |
| name  | String  | false | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| phone  | String  | false | request.body?.["phone"] |
| taxNumber  | String  | false | request.body?.["taxNumber"] |

### REST Request
To access the api you can use the **REST** controller with the path **PATCH  /v1/customers/:customerId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/customers/${customerId}`,
    data: {
            address:"Text",  
            contactEmail:"String",  
            contactName:"String",  
            name:"String",  
            notes:"Text",  
            phone:"String",  
            taxNumber:"String",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`customer`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customer",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"customer": {
		"id": "ID",
		"address": "Text",
		"contactEmail": "String",
		"contactName": "String",
		"name": "String",
		"notes": "Text",
		"phone": "String",
		"taxNumber": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="customermanagement-service-business-api--fetchlistcustomer-api-design"></a>

### Business API Design Specification - `_fetch Listcustomer`


# Business API Design Specification - `_fetch Listcustomer`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `_fetchListCustomer` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `_fetchListCustomer` Business API is designed to handle a `list` operation on the `Customer` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

System API to fetch list of customer records for frontend application. Auto-generated, not visible in design.


## API Options 

* **Auto Params** : `false`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `false`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `_fetchListCustomer` Business API includes a REST controller that can be triggered via the following route:

`/v1/_fetchlistcustomer`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `_fetchListCustomer` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `_fetchListCustomer` Business API has 5 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.


### Filter Parameters

The `_fetchListCustomer` api supports 5 optional filter parameters for filtering list results using URL query parameters. These parameters are only available for `list` type APIs.

#### `contactEmail` Filter

**Type:** `String`  
**Description:** Primary contact's email address (optional, for notifications or info).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Case-Insensitive Partial Matching):**
- Single value: `?contactEmail=<value>` (matches any string containing the value, case-insensitive)
- Multiple values: `?contactEmail=<value1>&contactEmail=<value2>` (matches records containing any of the values)
- Null check: `?contactEmail=null`

**Examples:**
```javascript
// Find records with "john" in the field (case-insensitive partial match)
GET /v1/_fetchlistcustomer?contactEmail=john
// Matches: "John", "Johnny", "johnson", "McJohn", etc.

// Find records with multiple values (use multiple parameters)
GET /v1/_fetchlistcustomer?contactEmail=laptop&contactEmail=phone&contactEmail=tablet
// Matches records containing "laptop", "phone", or "tablet" anywhere in the field

// Find records without this field
GET /v1/_fetchlistcustomer?contactEmail=null
```


#### `contactName` Filter

**Type:** `String`  
**Description:** Primary contact person's name (optional, for individual or company).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Case-Insensitive Partial Matching):**
- Single value: `?contactName=<value>` (matches any string containing the value, case-insensitive)
- Multiple values: `?contactName=<value1>&contactName=<value2>` (matches records containing any of the values)
- Null check: `?contactName=null`

**Examples:**
```javascript
// Find records with "john" in the field (case-insensitive partial match)
GET /v1/_fetchlistcustomer?contactName=john
// Matches: "John", "Johnny", "johnson", "McJohn", etc.

// Find records with multiple values (use multiple parameters)
GET /v1/_fetchlistcustomer?contactName=laptop&contactName=phone&contactName=tablet
// Matches records containing "laptop", "phone", or "tablet" anywhere in the field

// Find records without this field
GET /v1/_fetchlistcustomer?contactName=null
```


#### `name` Filter

**Type:** `String`  
**Description:** Full customer display name (required).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Case-Insensitive Partial Matching):**
- Single value: `?name=<value>` (matches any string containing the value, case-insensitive)
- Multiple values: `?name=<value1>&name=<value2>` (matches records containing any of the values)
- Null check: `?name=null`

**Examples:**
```javascript
// Find records with "john" in the field (case-insensitive partial match)
GET /v1/_fetchlistcustomer?name=john
// Matches: "John", "Johnny", "johnson", "McJohn", etc.

// Find records with multiple values (use multiple parameters)
GET /v1/_fetchlistcustomer?name=laptop&name=phone&name=tablet
// Matches records containing "laptop", "phone", or "tablet" anywhere in the field

// Find records without this field
GET /v1/_fetchlistcustomer?name=null
```


#### `phone` Filter

**Type:** `String`  
**Description:** Main phone number for contact (optional).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Case-Insensitive Partial Matching):**
- Single value: `?phone=<value>` (matches any string containing the value, case-insensitive)
- Multiple values: `?phone=<value1>&phone=<value2>` (matches records containing any of the values)
- Null check: `?phone=null`

**Examples:**
```javascript
// Find records with "john" in the field (case-insensitive partial match)
GET /v1/_fetchlistcustomer?phone=john
// Matches: "John", "Johnny", "johnson", "McJohn", etc.

// Find records with multiple values (use multiple parameters)
GET /v1/_fetchlistcustomer?phone=laptop&phone=phone&phone=tablet
// Matches records containing "laptop", "phone", or "tablet" anywhere in the field

// Find records without this field
GET /v1/_fetchlistcustomer?phone=null
```


#### `taxNumber` Filter

**Type:** `String`  
**Description:** Tax/VAT identification number or code (optional).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Case-Insensitive Partial Matching):**
- Single value: `?taxNumber=<value>` (matches any string containing the value, case-insensitive)
- Multiple values: `?taxNumber=<value1>&taxNumber=<value2>` (matches records containing any of the values)
- Null check: `?taxNumber=null`

**Examples:**
```javascript
// Find records with "john" in the field (case-insensitive partial match)
GET /v1/_fetchlistcustomer?taxNumber=john
// Matches: "John", "Johnny", "johnson", "McJohn", etc.

// Find records with multiple values (use multiple parameters)
GET /v1/_fetchlistcustomer?taxNumber=laptop&taxNumber=phone&taxNumber=tablet
// Matches records containing "laptop", "phone", or "tablet" anywhere in the field

// Find records without this field
GET /v1/_fetchlistcustomer?taxNumber=null
```


  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `_fetchListCustomer` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`






---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

``


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{businessId:this.businessId,isActive:true}
```









## List Options
Defines list-specific options including filtering logic, default sorting, and result customization for APIs that return multiple records.

**List Sort By**
Sort order definitions for the result set. Multiple fields can be provided with direction (asc/desc).

[ createdAt desc ]


**List Group By**
Grouping definitions for the result set. This is typically used for visual or report-based grouping.

*The list is not grouped.*



**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.


**Permission Filter**
Optional filter that applies permission constraints dynamically based on session or object roles. So that the list items are filtered by the user's OBAC or ABAC permissions.

*Permission filter is not active at the moment. Follow Mindbricks updates to be able to use it.*

## Pagination Options
Contains settings to configure pagination behavior for `list` APIs. Includes options like page size, offset, cursor support, and total count inclusion.



   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Reads request and Redis parameters, applies defaults, and writes them to context for downstream processing.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Transforms and normalizes parameters, derives dependent values, and reshapes inputs for the main list query.


---




### [4] Step : checkParameters

Executes validation logic on required and custom parameters, enforcing business rules and cross-field consistency.


---




### [5] Step : checkBasicAuth

Performs role-based access checks and applies dynamic membership or session-based restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Constructs the main query WHERE clause and applies optional filters or scoped access controls.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainListOperation

Executes the paginated database query, retrieves the list, and stores results in context for enrichment.


You can use the following settings to change some behavior of this step.
`selectClause`, `listOptions`, `paginationOptions`
---




### [8] Step : buildOutput

Assembles the list response, sanitizes sensitive fields, applies transformations, and injects extra context if needed.


---




### [9] Step : sendResponse

Sends the paginated list to the client through the controller.


---




### [10] Step : raiseApiEvent

Triggers optional post-workflow events, such as Kafka messages, logs, or system notifications.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `_fetchListCustomer` api has 5 filter parameters available for filtering list results. See the [Filter Parameters](#filter-parameters) section above for detailed usage examples.

| Filter Parameter       | Type                   | Array Property | Description                   |
| ---------------------- | ---------------------- | -------------- | ----------------------------- |
| contactEmail  | String  | No | Primary contact's email address (optional, for notifications or info). |
| contactName  | String  | No | Primary contact person's name (optional, for individual or company). |
| name  | String  | No | Full customer display name (required). |
| phone  | String  | No | Main phone number for contact (optional). |
| taxNumber  | String  | No | Tax/VAT identification number or code (optional). |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistcustomer**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistcustomer',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section for usage examples)
        // contactEmail: '<value>' // Filter by contactEmail
        // contactName: '<value>' // Filter by contactName
        // name: '<value>' // Filter by name
        // phone: '<value>' // Filter by phone
        // taxNumber: '<value>' // Filter by taxNumber
            }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`customers`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "customers",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"customers": [
		{
			"id": "ID",
			"address": "Text",
			"contactEmail": "String",
			"contactName": "String",
			"name": "String",
			"notes": "Text",
			"phone": "String",
			"taxNumber": "String",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID"
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```  

---

# ExpenseManagement Service

<a id="expensemanagement-service-service-design"></a>

## Service Design Specification



# Service Design Specification
**fintrack-expensemanagement-service** documentation
**Version:** `1.0.1`

## Scope

This document provides a structured architectural overview of the `expenseManagement` microservice, detailing its configuration, data model, authorization logic, business rules, and API design. It has been automatically generated based on the service definition within Mindbricks, ensuring that the information reflects the source of truth used during code generation and deployment.

The document is intended to serve multiple audiences:

* **Service architects** can use it to validate design decisions and ensure alignment with broader architectural goals.
* **Developers and maintainers** will find it useful for understanding the structure and behavior of the service, facilitating easier debugging, feature extension, and integration with other systems.
* **Stakeholders and reviewers** can use it to gain a clear understanding of the service's capabilities and domain logic.

> **Note for Frontend Developers**: While this document is valuable for understanding business logic and data interactions, please refer to the [Service API Documentation](#) for endpoint-level specifications and integration details.

> **Note for Backend Developers**: Since the code for this service is automatically generated by Mindbricks, you typically won't need to implement or modify it manually. However, this document is especially valuable when you're building other services—whether within Mindbricks or externally—that need to interact with or depend on this service. It provides a clear reference to the service's data contracts, business rules, and API structure, helping ensure compatibility and correct integration.



## `ExpenseManagement` Service Settings [**Edit**](expensemanagement/serviceSettings)

Handles CRUD for general business expenses (not tied to invoices), enforcing per-business tenant isolation, enabling categorization and supporting future reporting/analytics. Part of the FinTrack financial management backend.

### Service Overview

This service is configured to listen for HTTP requests on port `3005`, 
serving both the main API interface and default administrative endpoints.

The following routes are available by default:

* **API Test Interface (API Face):** `/`
* **Swagger Documentation:** `/swagger`
* **Postman Collection Download:** `/getPostmanCollection`
* **Health Checks:** `/health` and `/admin/health`
* **Current Session Info:** `/currentuser`
* **Favicon:** `/favicon.ico`

The service uses a **PostgreSQL** database for data storage, with the database name set to `fintrack-expensemanagement-service`.

This service is accessible via the following environment-specific URLs:

* **Preview:** `https://fintrack.prw.mindbricks.com/expensemanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/expensemanagement-api`
* **Production:** `https://fintrack.mindbricks.co/expensemanagement-api`

                                 

### Authentication & Security
- **Login Required**: Yes

This service requires user authentication for access. It supports both JWT and RSA-based authentication mechanisms, ensuring secure user sessions and data integrity.
If a crud route also is configured to require login, 
it will check a valid JWT token in the request query/header/bearer/cookie. If the token is valid, it will extract the user information from the token and make the fetched session data available in the request context.

  
### Service Data Objects
The service uses a **PostgreSQL** database for data storage, with the database name set to `fintrack-expensemanagement-service`.

Data deletion is managed using a **soft delete** strategy. Instead of removing records from the database, they are flagged as inactive by setting the `isActive` field to `false`.



| Object Name | Description | Public Access | Tenant Level  | 
|-------------|-------------|---------------| --------------| 
| `expense` | Represents a general expense not tied to any invoice, always scoped to a single business. Can be categorized, linked (optionally) to a supplier, and used in future financial analysis. All fields support Unicode, amount is always in business-relevant currency. | accessProtected |  Yes | 




## expense Data Object

### Object Overview
**Description:** Represents a general expense not tied to any invoice, always scoped to a single business. Can be categorized, linked (optionally) to a supplier, and used in future financial analysis. All fields support Unicode, amount is always in business-relevant currency.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessProtected — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.








### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `amount` | Double | Yes | Expense amount (must be positive, required). |
| `category` | String | Yes | Expense category for grouping/filtering/reporting (e.g., &#34;utilities&#34;, &#34;travel&#34;). Free text now, could migrate to a static data object in future. |
| `currency` | String | Yes | ISO currency code (e.g. &#39;USD&#39;). Required for reporting, summaries, and multi-currency future support. |
| `date` | Date | Yes | Date the expense occurred. Required for reporting, sorting, and filtering. |
| `description` | String | Yes | Required human-readable description of the expense (e.g., purpose or detail). |
| `notes` | Text | No | Internal notes/justification—never exposed to public/customers. Optional. |
| `supplierId` | ID | No | Optional link to a known supplier. May be null/omitted for uncategorized/general expenses. |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **amount**: 0.0
- **category**: 'default'
- **currency**: 'default'
- **date**: new Date()
- **description**: 'default'
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`amount` `category` `currency` `date` `description` `notes` `supplierId`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

 

 

### Elastic Search Indexing

`amount` `category` `currency` `date` `description` `supplierId` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`amount` `category` `date` `supplierId` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.





### Secondary Key Properties

`businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.


### Relation Properties

`supplierId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **supplierId**: ID
Relation to `supplier`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: No





### Filter Properties

`amount` `category` `currency` `date` `description` `supplierId` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **amount**: Double  has a filter named `amount`

- **category**: String  has a filter named `category`

- **currency**: String  has a filter named `currency`

- **date**: Date  has a filter named `date`

- **description**: String  has a filter named `description`

- **supplierId**: ID  has a filter named `supplierId`

- **businessId**: ID  has a filter named `businessId`







## Business Logic


expenseManagement has got 6 Business APIs to manage its internal and crud logic. 
For the details of each business API refer to its chapter.

* [Create Expense](/businessLogic/createexpense)

* [Delete Expense](/businessLogic/deleteexpense)

* [Get Expense](/businessLogic/getexpense)

* [List Expenses](/businessLogic/listexpenses)

* [Update Expense](/businessLogic/updateexpense)

* [_fetch Listexpense](/businessLogic/_fetchlistexpense)



## Edge Controllers



### m2mCreateExpense

**Configuration:**
- **Function Name**: `m2mCreateExpense`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/expense/create`
- **Method**: 

---

### m2mBulkCreateExpense

**Configuration:**
- **Function Name**: `m2mBulkCreateExpense`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/expense/bulk-create`
- **Method**: 

---

### m2mUpdateExpenseById

**Configuration:**
- **Function Name**: `m2mUpdateExpenseById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/expense/update/:id`
- **Method**: 

---

### m2mDeleteExpenseById

**Configuration:**
- **Function Name**: `m2mDeleteExpenseById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/expense/delete/:id`
- **Method**: 

---

### m2mUpdateExpenseByQuery

**Configuration:**
- **Function Name**: `m2mUpdateExpenseByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/expense/update-by-query`
- **Method**: 

---

### m2mDeleteExpenseByQuery

**Configuration:**
- **Function Name**: `m2mDeleteExpenseByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/expense/delete-by-query`
- **Method**: 

---

### m2mUpdateExpenseByIdList

**Configuration:**
- **Function Name**: `m2mUpdateExpenseByIdList`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/expense/update-by-id-list`
- **Method**: 

---



---

## Service Library


### Functions

No general functions defined.


### Hook Functions

No hook functions defined.


### Edge Functions


#### m2mCreateExpense.js
```js
module.exports = async (request) => {
        const { createExpense } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const data = request.body?.data || request.data || request;
        const result = await createExpense(data, context);
        return { status: 200, content: result };
      }
```

#### m2mBulkCreateExpense.js
```js
module.exports = async (request) => {
        const { createBulkExpense } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataList = request.body?.dataList || request.dataList || (Array.isArray(request.body) ? request.body : [request.body]);
        if (!Array.isArray(dataList) || dataList.length === 0) {
          return { status: 400, message: "dataList must be a non-empty array" };
        }
        const result = await createBulkExpense(dataList, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateExpenseById.js
```js
module.exports = async (request) => {
        const { updateExpenseById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.id) delete dataClause.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await updateExpenseById(id, dataClause, context);
        return { status: 200, content: result };
      }
```

#### m2mDeleteExpenseById.js
```js
module.exports = async (request) => {
        const { deleteExpenseById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await deleteExpenseById(id, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateExpenseByQuery.js
```js
module.exports = async (request) => {
        const { updateExpenseByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await updateExpenseByQuery(dataClause, query, context);
        return { status: 200, content: result };
      }
```

#### m2mDeleteExpenseByQuery.js
```js
module.exports = async (request) => {
        const { deleteExpenseByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await deleteExpenseByQuery(query, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateExpenseByIdList.js
```js
module.exports = async (request) => {
        const { updateExpenseByIdList } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const idList = request.body?.idList || request.idList || [];
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.idList) delete dataClause.idList;
        if (!Array.isArray(idList) || idList.length === 0) {
          return { status: 400, message: "idList must be a non-empty array" };
        }
        const result = await updateExpenseByIdList(idList, dataClause, context);
        return { status: 200, content: result };
      }
```



### Templates

No templates defined.


### Assets

No assets defined.


### Public Assets

No public assets defined.



---




### Event Emission


---

## Integration Patterns

## Deployment Considerations

### Environment Configuration
- **HTTP Port**: `3005`
- **Database Type**: MongoDB
- **Global Soft Delete**: Enabled




## Implementation Guidelines

### Development Workflow
1. **Data Model Implementation**: Generate database schema from data object definitions
2. **CRUD Route Generation**: Implement auto-generated routes with custom logic
3. **Custom Logic Integration**: Implement hook functions and edge functions
4. **Authentication Integration**: Configure with project-level authentication
5. **Testing**: Unit and integration testing for all components

### Code Generation Expectations
- **Database Schema**: Auto-generated from data objects and relationships
- **API Routes**: REST endpoints with customizable behavior
- **Validation Logic**: Input validation from property definitions
- **Access Control**: Authentication and authorization middleware

### Custom Code Integration Points
- **Hook Functions**: Lifecycle-specific custom logic
- **Edge Functions**: Full request/response control
- **Library Functions**: Reusable business logic
- **Templates**: Dynamic content rendering

### Testing Strategy

#### Unit Testing
- Test all custom library functions
- Test validation logic and business rules
- Test hook function implementations

#### Integration Testing
- Test API endpoints with authentication scenarios
- Test database operations and transactions
- Test external integrations
- Test event emission and Kafka integration

#### Performance Testing
- Load test high-traffic endpoints
- Test caching effectiveness
- Monitor database query performance
- Test scalability under load

---

## Appendices

### Data Type Reference
| Type | Description | Storage |
|------|-------------|---------|
| ID | Unique identifier | UUID (SQL) / ObjectID (NoSQL) |
| String | Short text (≤255 chars) | VARCHAR |
| Text | Long-form text | TEXT |
| Integer | 32-bit whole numbers | INT |
| Boolean | True/false values | BOOLEAN |
| Double | 64-bit floating point | DOUBLE |
| Float | 32-bit floating point | FLOAT |
| Short | 16-bit integers | SMALLINT |
| Object | JSON object | JSONB (PostgreSQL) / Object (MongoDB) |
| Date | ISO 8601 timestamp | TIMESTAMP |
| Enum | Fixed numeric values | SMALLINT with lookup |

### Enum Value Mappings

#### Request Locations
- `0`: Bearer token in Authorization header
- `1`: Cookie value
- `2`: Custom HTTP header
- `3`: Query parameter
- `4`: Request body property
- `5`: URL path parameter
- `6`: Session data
- `7`: Root request object

#### HTTP Methods
- `0`: GET
- `1`: POST
- `2`: PUT
- `3`: PATCH
- `4`: DELETE


### Edge Function Signature
```javascript
async function edgeFunction(request) {
  // Custom request processing
  // Return response object or throw error
  return {
    data: {},
    status: 200,
    message: "Success"
  };
}
```

---

*This document was generated from the service architecture definition and should be kept in sync with implementation changes.*

---

<a id="expensemanagement-service-rest-api-guide"></a>

## REST API GUIDE 

 

# REST API GUIDE 
## fintrack-expensemanagement-service
**Version:** `1.0.1`

Handles CRUD for general business expenses (not tied to invoices), enforcing per-business tenant isolation, enabling categorization and supporting future reporting/analytics. Part of the FinTrack financial management backend.

## Architectural Design Credit and Contact Information

The architectural design of this microservice is credited to . 
For inquiries, feedback, or further information regarding the architecture, please direct your communication to:

Email: 

We encourage open communication and welcome any questions or discussions related to the architectural aspects of this microservice.

## Documentation Scope

Welcome to the official documentation for the ExpenseManagement Service's REST API. This document is designed to provide a comprehensive guide to interfacing with our ExpenseManagement Service exclusively through RESTful API endpoints.

**Intended Audience**

This documentation is intended for developers and integrators who are looking to interact with the ExpenseManagement Service via HTTP requests for purposes such as creating, updating, deleting and querying ExpenseManagement objects.

**Overview**

Within these pages, you will find detailed information on how to effectively utilize the REST API, including authentication methods, request and response formats, endpoint descriptions, and examples of common use cases.

Beyond REST
It's important to note that the ExpenseManagement Service also supports alternative methods of interaction, such as gRPC and messaging via a Message Broker. These communication methods are beyond the scope of this document. For information regarding these protocols, please refer to their respective documentation.

## Authentication And Authorization

To ensure secure access to the ExpenseManagement service's protected endpoints, a project-wide access token is required. This token serves as the primary method for authenticating requests to our service. However, it's important to note that access control varies across different routes:

**Protected API**: 
Certain API (routes) require specific authorization levels. Access to these routes is contingent upon the possession of a valid access token that meets the route-specific authorization criteria. Unauthorized requests to these routes will be rejected.

**Public API **: 
The service also includes public API (routes) that are accessible without authentication. These public endpoints are designed for open access and do not require an access token.

### Token Locations
When including your access token in a request, ensure it is placed in one of the following specified locations. The service will sequentially search these locations for the token, utilizing the first one it encounters.

| Location               | Token Name / Param Name      |
| ---------------------- | ---------------------------- |
| Query                  | access_token                 |
| Authorization Header   | Bearer                       |
| Header                 | fintrack-access-token|
| Header                 | fintrack-access-token-{businessCodename}|
| Cookie                 | fintrack-access-token-{businessCodename}|


Please ensure the token is correctly placed in one of these locations, using the appropriate label as indicated. The service prioritizes these locations in the order listed, processing the first token it successfully identifies.


## Api Definitions
This section outlines the API endpoints available within the ExpenseManagement service. Each endpoint can receive parameters through various methods, meticulously described in the following definitions. It's important to understand the flexibility in how parameters can be included in requests to effectively interact with the ExpenseManagement service.

This service is configured to listen for HTTP requests on port `3005`, 
serving both the main API interface and default administrative endpoints.

The following routes are available by default:

* **API Test Interface (API Face):** `/`
* **Swagger Documentation:** `/swagger`
* **Postman Collection Download:** `/getPostmanCollection`
* **Health Checks:** `/health` and `/admin/health`
* **Current Session Info:** `/currentuser`
* **Favicon:** `/favicon.ico`

This service is accessible via the following environment-specific URLs:

* **Preview:** `https://fintrack.prw.mindbricks.com/expensemanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/expensemanagement-api`
* **Production:** `https://fintrack.mindbricks.co/expensemanagement-api`

**Parameter Inclusion Methods:**
Parameters can be incorporated into API requests in several ways, each with its designated location. Understanding these methods is crucial for correctly constructing your requests:

**Query Parameters:** Included directly in the URL's query string.

**Path Parameters:** Embedded within the URL's path.

**Body Parameters:** Sent within the JSON body of the request.

**Session Parameters:** Automatically read from the session object. This method is used for parameters that are intrinsic to the user's session, such as userId. When using an API that involves session parameters, you can omit these from your request. The service will automatically bind them to the API layer, provided that a session is associated with your request.

**Note on Session Parameters:**
Session parameters represent a unique method of parameter inclusion, relying on the context of the user's session. A common example of a session parameter is userId, which the service automatically associates with your request when a session exists. This feature ensures seamless integration of user-specific data without manual input for each request.

By adhering to the specified parameter inclusion methods, you can effectively utilize the ExpenseManagement service's API endpoints. For detailed information on each endpoint, including required parameters and their accepted locations, refer to the individual API definitions below.

### Common Parameters

The `ExpenseManagement` service's business API support several common parameters designed to modify and enhance the behavior of API requests. These parameters are not individually listed in the API route definitions to avoid repetition. Instead, refer to this section to understand how to leverage these common behaviors across different routes. Note that all common parameters should be included in the query part of the URL.

### Supported Common Parameters:

- **getJoins (BOOLEAN)**: Controls whether to retrieve associated objects along with the main object. By default, `getJoins` is assumed to be `true`. Set it to `false` if you prefer to receive only the main fields of an object, excluding its associations.

- **excludeCQRS (BOOLEAN)**: Applicable only when `getJoins` is `true`. By default, `excludeCQRS` is set to `false`. Enabling this parameter (`true`) omits non-local associations, which are typically more resource-intensive as they require querying external services like ElasticSearch for additional information. Use this to optimize response times and resource usage.

- **requestId (String)**: Identifies a request to enable tracking through the service's log chain. A random hex string of 32 characters is assigned by default. If you wish to use a custom `requestId`, simply include it in your query parameters.

- **caching (BOOLEAN)**: Determines the use of caching for query API. By default, caching is enabled (`true`). To ensure the freshest data directly from the database, set this parameter to `false`, bypassing the cache.

- **cacheTTL (Integer)**: Specifies the Time-To-Live (TTL) for query caching, in seconds. This is particularly useful for adjusting the default caching duration (5 minutes) for `get list` queries. Setting a custom `cacheTTL` allows you to fine-tune the cache lifespan to meet your needs.

- **pageNumber (Integer)**: For paginated `get list` API's, this parameter selects which page of results to retrieve. The default is `1`, indicating the first page. To disable pagination and retrieve all results, set `pageNumber` to `0`.

- **pageRowCount (Integer)**: In conjunction with paginated API's, this parameter defines the number of records per page. The default value is `25`. Adjusting `pageRowCount` allows you to control the volume of data returned in a single request.

By utilizing these common parameters, you can tailor the behavior of API requests to suit your specific requirements, ensuring optimal performance and usability of the `ExpenseManagement` service.


  ### Multi Tenant Architecture

  The `ExpenseManagement` service operates within a multi tenant architecture.
  The service is designed to support multiple tenants, each with its distinct data and configuration. This architecture ensures that data is securely isolated between tenants, preventing unauthorized access and maintaining data integrity.
  The service tenant is called `business` and identified as `businessId`.
  Other than platform users like superAdmin, saasAdmin and saasUser that belong to the root tenant, the tenant creators(owners) and users will all be associated with an business tenant.
  When users login their scope will be isolated only to include one tenant data they below. So user may acces only this logined tennat through out the session. After loging in to e specific tenant, users should include the tenant id in their request to access the tenant data. In each request they may access different tenant data if they belong them. 


  #### Key Points:
  
  - **Tenant-Specific Requests**: It is imperative that each request specifies the tenant it pertains to. This is crucial because most API's are designed to interact exclusively with objects that are part of the specified tenant sandbox.
  - **User Distinction**: The requesting user must have a registration for that tenant. The service searches for a `business` specific token (cookie or bearer) using the provided `business`Id in the request header. Note that to be able to login and use multiple tenant's sites a user must register for them all.
  - **Request Header Parameter**: When making a request, include the desired `businessId` in the request header using the parameter name ``. This signals to the service which domain context to apply for the request processing. Alternatively, you can include the tenant id in the query parameters with the name `businessId`.
  - **Root Tenant**: As all multi tenant architectures this application also has a default root tenant which created automatically. If there is no tenant mark for the request, the request are assumed as to the root tenant. Root tenant is also the hub for registering tenant creating and their owner users. When users register themselves in the root tenant, an (business) will alos be created with the given data in the request body and the user will be asssociated with this new tenant record as the `tenantAdmin`. 
  - **Superadmin account**: A super admin account is created with the given credentials in the design so that there is an absolute user which has all rights in the root tenant and other tenants. This account is used to create and manage all other tenants in the system. 
    - **Tenant Registration**: The `ExpenseManagement` service allows for the creation of new tenants only through admin account of the root tenant. So if a new business record is needed, the superadmin or admin roles of the root should create then new tenant and assign any user as the owner of it.
  
  #### Implementation:

  When the user logins there may be few ways for Mindbricks to recognize and set the tenant id in the session.
  1. Mindbricks will check the url of the login request if it matches tenant url.
  2. Mindbricks will check the `` has the tenant id.
  3. Mindbricks will check if the user is associated with a `business` in the data model.
  After you login a tenant successfully, ensure that your requests accurately target objects that fall within the tenant scope set during the login session.
  Ensure your requests are correctly formatted to include the domain sandbox information in the header. This enables the `ExpenseManagement` service to accurately identify the domain context, facilitating proper access control and data management based on the user's permissions and the specified domain.  
  ```js
  axios({
    method: 'GET',
    headers: {
      '': 'Your-businessId-here'
    }
    url: "/someroutepath",
    data: {
      "someData":"someData"
    },
    params: {
      "aParam":"aParam"
    }
  });
  ````     
  By adhering to this domain sandbox model, the `ExpenseManagement` service maintains a secure and organized structure for handling requests across different domains, ensuring that operations are performed within the correct contextual boundaries.

### Error Response

If a request encounters an issue, whether due to a logical fault or a technical problem, the service responds with a standardized JSON error structure. The HTTP status code within this response indicates the nature of the error, utilizing commonly recognized codes for clarity:

- **400 Bad Request**: The request was improperly formatted or contained invalid parameters, preventing the server from processing it.
- **401 Unauthorized**: The request lacked valid authentication credentials or the credentials provided do not grant access to the requested resource.
- **404 Not Found**: The requested resource was not found on the server.
- **500 Internal Server Error**: The server encountered an unexpected condition that prevented it from fulfilling the request.

Each error response is structured to provide meaningful insight into the problem, assisting in diagnosing and resolving issues efficiently.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```` 

### Object Structure of a Successfull Response

When the `ExpenseManagement` service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope not only contains the data but also includes essential metadata, such as configuration details and pagination information, to enrich the response and provide context to the client.

**Key Characteristics of the Response Envelope:**

- **Data Presentation**: Depending on the nature of the request, the service returns either a single data object or an array of objects encapsulated within the JSON envelope.
  - **Creation and Update API**: These API routes return the unmodified (pure) form of the data object(s), without any associations to other data objects.
  - **Delete API**: Even though the data is removed from the database, the last known state of the data object(s) is returned in its pure form.
  - **Get Requests**: A single data object is returned in JSON format.
  - **Get List Requests**: An array of data objects is provided, reflecting a collection of resources.

- **Data Structure and Joins**: The complexity of the data structure in the response can vary based on the API's architectural design and the join options specified in the request. The architecture might inherently limit join operations, or they might be dynamically controlled through query parameters.
  - **Pure Data Forms**: In some cases, the response mirrors the exact structure found in the primary data table, without extensions.
  - **Extended Data Forms**: Alternatively, responses might include data extended through joins with tables within the same service or aggregated from external sources, such as ElasticSearch indices related to other services.
  - **Join Varieties**: The extensions might involve one-to-one joins, resulting in single object associations, or one-to-many joins, leading to an array of objects. In certain instances, the data might even feature nested inclusions from other data objects.

**Design Considerations**: The structure of a API's response data is meticulously crafted during the service's architectural planning. This design ensures that responses adequately reflect the intended data relationships and service logic, providing clients with rich and meaningful information.

**Brief Data**: Certain API's return a condensed version of the object data, intentionally selecting only specific fields deemed useful for that request. In such instances, the API documentation will detail the properties included in the response, guiding developers on what to expect.

### API Response Structure

The API utilizes a standardized JSON envelope to encapsulate responses. This envelope is designed to consistently deliver both the requested data and essential metadata, ensuring that clients can efficiently interpret and utilize the response.

**HTTP Status Codes:**

- **200 OK**: This status code is returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request has been processed successfully.
- **201 Created**: This status code is specific to CREATE operations, signifying that the requested resource has been successfully created.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling the successful execution of the request. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
````

- **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation performed.

**Handling Errors:**

For details on handling error scenarios and understanding the structure of error responses, please refer to the "Error Response" section provided earlier in this documentation. It outlines how error conditions are communicated, including the use of HTTP status codes and standardized JSON structures for error messages.

## Resources 
ExpenseManagement service provides the following resources which are stored in its own database as a data object. Note that a resource for an api access is a data object for the service.

### Expense resource

*Resource Definition* : Represents a general expense not tied to any invoice, always scoped to a single business. Can be categorized, linked (optionally) to a supplier, and used in future financial analysis. All fields support Unicode, amount is always in business-relevant currency.
*Expense Resource Properties* 
| Name | Type | Required | Default | Definition | 
| ---- | ---- | -------- | ------- | ---------- |
| **amount** | Double |  |  | *Expense amount (must be positive, required).* |
| **category** | String |  |  | *Expense category for grouping/filtering/reporting (e.g., &#34;utilities&#34;, &#34;travel&#34;). Free text now, could migrate to a static data object in future.* |
| **currency** | String |  |  | *ISO currency code (e.g. &#39;USD&#39;). Required for reporting, summaries, and multi-currency future support.* |
| **date** | Date |  |  | *Date the expense occurred. Required for reporting, sorting, and filtering.* |
| **description** | String |  |  | *Required human-readable description of the expense (e.g., purpose or detail).* |
| **notes** | Text |  |  | *Internal notes/justification—never exposed to public/customers. Optional.* |
| **supplierId** | ID |  |  | *Optional link to a known supplier. May be null/omitted for uncategorized/general expenses.* |
| **businessId** | ID |  |  | *An ID value to represent the tenant id of the business* |
## Business Api
### `Create Expense` API
Create a new expense entry for the current business. Owner/Accountant roles required. Inputs: date, amount, currency, category, description, optional supplierId, notes. Validates positivity. Returns created expense.

**API Frontend Description By The Backend Architect**

Provide an expense creation form with required fields (date, amount, currency, category, description), optional supplier search/link, and notes. Role-based access: only Owner/Accountant may create expenses. UX should validate positive amount and require fields before submit.

**Rest Route**

The `createExpense` API REST controller can be triggered via the following route:

`/v1/expenses`


**Rest Request Parameters**


The `createExpense` api has got 7 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| amount  | Double  | true | request.body?.["amount"] |
| category  | String  | true | request.body?.["category"] |
| currency  | String  | true | request.body?.["currency"] |
| date  | Date  | true | request.body?.["date"] |
| description  | String  | true | request.body?.["description"] |
| notes  | Text  | false | request.body?.["notes"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |
**amount** : Expense amount (must be positive, required).
**category** : Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future.
**currency** : ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support.
**date** : Date the expense occurred. Required for reporting, sorting, and filtering.
**description** : Required human-readable description of the expense (e.g., purpose or detail).
**notes** : Internal notes/justification—never exposed to public/customers. Optional.
**supplierId** : Optional link to a known supplier. May be null/omitted for uncategorized/general expenses.


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/expenses**
```js
  axios({
    method: 'POST',
    url: '/v1/expenses',
    data: {
            amount:"Double",  
            category:"String",  
            currency:"String",  
            date:"Date",  
            description:"String",  
            notes:"Text",  
            supplierId:"ID",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"id": "ID",
		"amount": "Double",
		"category": "String",
		"currency": "String",
		"date": "Date",
		"description": "String",
		"notes": "Text",
		"supplierId": "ID",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Expense` API
Soft delete an expense (mark as inactive). Only Owner/Accountant can delete. Expense remains for history/audit; not shown in default lists.

**API Frontend Description By The Backend Architect**

Delete operation is allowed for Owner/Accountant only (no UI access for Users). Deletion is always soft (isActive=false). Do not show deleted expenses in main lists or reports. UI should visually confirm before deletion.

**Rest Route**

The `deleteExpense` API REST controller can be triggered via the following route:

`/v1/expenses/:expenseId`


**Rest Request Parameters**


The `deleteExpense` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| expenseId  | ID  | true | request.params?.["expenseId"] |
**expenseId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/expenses/:expenseId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/expenses/${expenseId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"id": "ID",
		"amount": "Double",
		"category": "String",
		"currency": "String",
		"date": "Date",
		"description": "String",
		"notes": "Text",
		"supplierId": "ID",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Expense` API
Retrieve a single expense by ID, scoped to current business. Any business user (owner/accountant/user) can view details (for reporting, reference, etc).

**API Frontend Description By The Backend Architect**

Expense detail screens show all fields, supplier name if present (lookup), and notes where authorized. No editing possible for Users; view only. Owner/Accountant may then open update/delete screens from here. Supplier (if present) should present full supplier name/details in details UX.

**Rest Route**

The `getExpense` API REST controller can be triggered via the following route:

`/v1/expenses/:expenseId`


**Rest Request Parameters**


The `getExpense` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| expenseId  | ID  | true | request.params?.["expenseId"] |
**expenseId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/expenses/:expenseId**
```js
  axios({
    method: 'GET',
    url: `/v1/expenses/${expenseId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"supplier": {
			"address": "Text",
			"contactEmail": "String",
			"contactName": "String",
			"name": "String",
			"phone": "String",
			"taxNumber": "String"
		},
		"isActive": true
	}
}
```
### `List Expenses` API
List expenses for the current business; supports filtering by date range, amount, currency, category, description (search), and supplierId. View access for all business roles. Used for main expense table, reporting, and analysis.

**API Frontend Description By The Backend Architect**

Expense table/report views: allow filtering by date, category, supplier, currency, amount range, and fulltext search on description. Results strictly limited to the user's business. All logged-in business users can list expenses. Pagination and sorting as per UI needs. Export, analytics, and aggregation handled in reporting layer.

**Rest Route**

The `listExpenses` API REST controller can be triggered via the following route:

`/v1/expenses`


**Rest Request Parameters**
The `listExpenses` api has got no request parameters.    



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/expenses**
```js
  axios({
    method: 'GET',
    url: '/v1/expenses',
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expenses",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"expenses": [
		{
			"supplier": [
				{
					"name": "String"
				},
				{},
				{}
			],
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Expense` API
Update an existing expense for current business. Only Owner/Accountant may update. Amount must remain positive; supplier if (re)set, must exist. Returns updated expense.

**API Frontend Description By The Backend Architect**

Expense update form should prefill all fields, allow edit of any but auto restrict negative/empty requireds. Only Owner/Accountant can update expenses. Validate all new values client and server side; supplier link optional but validated if changed.

**Rest Route**

The `updateExpense` API REST controller can be triggered via the following route:

`/v1/expenses/:expenseId`


**Rest Request Parameters**


The `updateExpense` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| expenseId  | ID  | true | request.params?.["expenseId"] |
| amount  | Double  | false | request.body?.["amount"] |
| category  | String  | false | request.body?.["category"] |
| currency  | String  | false | request.body?.["currency"] |
| date  | Date  | false | request.body?.["date"] |
| description  | String  | false | request.body?.["description"] |
| notes  | Text  | false | request.body?.["notes"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |
**expenseId** : This id paremeter is used to select the required data object that will be updated
**amount** : Expense amount (must be positive, required).
**category** : Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future.
**currency** : ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support.
**date** : Date the expense occurred. Required for reporting, sorting, and filtering.
**description** : Required human-readable description of the expense (e.g., purpose or detail).
**notes** : Internal notes/justification—never exposed to public/customers. Optional.
**supplierId** : Optional link to a known supplier. May be null/omitted for uncategorized/general expenses.


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/expenses/:expenseId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/expenses/${expenseId}`,
    data: {
            amount:"Double",  
            category:"String",  
            currency:"String",  
            date:"Date",  
            description:"String",  
            notes:"Text",  
            supplierId:"ID",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"id": "ID",
		"amount": "Double",
		"category": "String",
		"currency": "String",
		"date": "Date",
		"description": "String",
		"notes": "Text",
		"supplierId": "ID",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `_fetch Listexpense` API
System API to fetch list of expense records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListExpense` API REST controller can be triggered via the following route:

`/v1/_fetchlistexpense`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListExpense` api supports 6 optional filter parameters for filtering list results:

**amount** (`Double`): Expense amount (must be positive, required).

- Single: `?amount=<value>`
- Multiple: `?amount=<value1>&amount=<value2>`
- Range: `?amount=$lt-<value>`, `$lte-`, `$gt-`, `$gte-`, `$btw-<min>-<max>`
- Null: `?amount=null`


**category** (`String`): Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future.

- Single (partial match, case-insensitive): `?category=<value>`
- Multiple: `?category=<value1>&category=<value2>`
- Null: `?category=null`


**currency** (`String`): ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support.

- Single (partial match, case-insensitive): `?currency=<value>`
- Multiple: `?currency=<value1>&currency=<value2>`
- Null: `?currency=null`


**date** (`Date`): Date the expense occurred. Required for reporting, sorting, and filtering.

- Single date: `?date=2024-01-15`
- Multiple dates: `?date=2024-01-15&date=2024-01-20`
- Special: `$today`, `$ltoday`, `$week`, `$lweek`, `$month`, `$leq-<date>`, `$lin-<date>`
- Null: `?date=null`


**description** (`String`): Required human-readable description of the expense (e.g., purpose or detail).

- Single (partial match, case-insensitive): `?description=<value>`
- Multiple: `?description=<value1>&description=<value2>`
- Null: `?description=null`


**supplierId** (`ID`): Optional link to a known supplier. May be null/omitted for uncategorized/general expenses.

- Single: `?supplierId=<value>`
- Multiple: `?supplierId=<value1>&supplierId=<value2>`
- Null: `?supplierId=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistexpense**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistexpense',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // amount: '<value>' // Filter by amount
        // category: '<value>' // Filter by category
        // currency: '<value>' // Filter by currency
        // date: '<value>' // Filter by date
        // description: '<value>' // Filter by description
        // supplierId: '<value>' // Filter by supplierId
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expenses",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"expenses": [
		{
			"id": "ID",
			"amount": "Double",
			"category": "String",
			"currency": "String",
			"date": "Date",
			"description": "String",
			"notes": "Text",
			"supplierId": "ID",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"supplier": [
				{
					"address": "Text",
					"contactEmail": "String",
					"contactName": "String",
					"name": "String",
					"notes": "Text",
					"phone": "String",
					"taxNumber": "String"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```


### Authentication Specific Routes



### Common Routes

### Route: currentuser

*Route Definition*: Retrieves the currently authenticated user's session information.

*Route Type*: sessionInfo

*Access Route*: `GET /currentuser`

#### Parameters

This route does **not** require any request parameters.

#### Behavior

- Returns the authenticated session object associated with the current access token.
- If no valid session exists, responds with a 401 Unauthorized.

```js
// Sample GET /currentuser call
axios.get("/currentuser", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````
**Success Response**
Returns the session object, including user-related data and token information.
````
{
  "sessionId": "9cf23fa8-07d4-4e7c-80a6-ec6d6ac96bb9",
  "userId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  "email": "user@example.com",
  "fullname": "John Doe",
  "roleId": "user",
  "tenantId": "abc123",
  "accessToken": "jwt-token-string",
  ...
}
````
**Error Response**
**401 Unauthorized:** No active session found.
````
{
  "status": "ERR",
  "message": "No login found"
}
````

**Notes**
* This route is typically used by frontend or mobile applications to fetch the current session state after login.
* The returned session includes key user identity fields, tenant information (if applicable), and the access token for further authenticated requests.
* Always ensure a valid access token is provided in the request to retrieve the session.

### Route: permissions

`*Route Definition*`: Retrieves all effective permission records assigned to the currently authenticated user.

`*Route Type*`: permissionFetch

*Access Route*: `GET /permissions`

#### Parameters

This route does **not** require any request parameters.

#### Behavior

- Fetches all active permission records (`givenPermissions` entries) associated with the current user session.
- Returns a full array of permission objects.
- Requires a valid session (`access token`) to be available.

```js
// Sample GET /permissions call
axios.get("/permissions", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````
**Success Response**

Returns an array of permission objects.
```json
[
  {
    "id": "perm1",
    "permissionName": "adminPanel.access",
    "roleId": "admin",
    "subjectUserId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
    "subjectUserGroupId": null,
    "objectId": null,
    "canDo": true,
    "tenantCodename": "store123"
  },
  {
    "id": "perm2",
    "permissionName": "orders.manage",
    "roleId": null,
    "subjectUserId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
    "subjectUserGroupId": null,
    "objectId": null,
    "canDo": true,
    "tenantCodename": "store123"
  }
]
````
Each object reflects a single permission grant, aligned with the givenPermissions model:

- `**permissionName**`: The permission the user has.
- `**roleId**`: If the permission was granted through a role.
-` **subjectUserId**`: If directly granted to the user.
- `**subjectUserGroupId**`: If granted through a group.
- `**objectId**`: If tied to a specific object (OBAC).
- `**canDo**`: True or false flag to represent if permission is active or restricted.

**Error Responses**
* **401 Unauthorized**: No active session found.
```json
{
  "status": "ERR",
  "message": "No login found"
}
````
* **500 Internal Server Error**: Unexpected error fetching permissions.

**Notes**
* The /permissions route is available across all backend services generated by Mindbricks, not just the auth service.
* Auth service: Fetches permissions freshly from the live database (givenPermissions table).
* Other services: Typically use a cached or projected view of permissions stored in a common ElasticSearch store, optimized for faster authorization checks.

> **Tip**:
> Applications can cache permission results client-side or server-side, but should occasionally refresh by calling this endpoint, especially after login or permission-changing operations.

### Route: permissions/:permissionName

*Route Definition*: Checks whether the current user has access to a specific permission, and provides a list of scoped object exceptions or inclusions.

*Route Type*: permissionScopeCheck

*Access Route*: `GET /permissions/:permissionName`

#### Parameters

| Parameter         | Type   | Required | Population             |
|------------------|--------|----------|------------------------|
| permissionName   | String | Yes      | `request.params.permissionName` |

#### Behavior

- Evaluates whether the current user **has access** to the given `permissionName`.
- Returns a structured object indicating:
  - Whether the permission is generally granted (`canDo`)
  - Which object IDs are explicitly included or excluded from access (`exceptions`)
- Requires a valid session (`access token`).

```js
// Sample GET /permissions/orders.manage
axios.get("/permissions/orders.manage", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````

**Success Response**

```json
{
  "canDo": true,
  "exceptions": [
    "a1f2e3d4-xxxx-yyyy-zzzz-object1",
    "b2c3d4e5-xxxx-yyyy-zzzz-object2"
  ]
}
````

* If `canDo` is `true`, the user generally has the permission, but not for the objects listed in `exceptions` (i.e., restrictions).
* If `canDo` is `false`, the user does not have the permission by default — but only for the objects in `exceptions`, they do have permission (i.e., selective overrides).
* The exceptions array contains valid **UUID strings**, each corresponding to an object ID (typically from the data model targeted by the permission).

## Copyright
All sources, documents and other digital materials are copyright of .

## About Us
For more information please visit our website: .

.
.


---

<a id="expensemanagement-service-event-guide"></a>

## EVENT GUIDE

# EVENT GUIDE
## fintrack-expensemanagement-service

Handles CRUD for general business expenses (not tied to invoices), enforcing per-business tenant isolation, enabling categorization and supporting future reporting/analytics. Part of the FinTrack financial management backend.

## Architectural Design Credit and Contact Information

The architectural design of this microservice is credited to . For inquiries, feedback, or further information regarding the architecture, please direct your communication to:

Email: 

We encourage open communication and welcome any questions or discussions related to the architectural aspects of this microservice.

# Documentation Scope

Welcome to the official documentation for the `ExpenseManagement` Service Event descriptions. This guide is dedicated to detailing how to subscribe to and listen for state changes within the `ExpenseManagement` Service, offering an exclusive focus on event subscription mechanisms.

**Intended Audience**

This documentation is aimed at developers and integrators looking to monitor `ExpenseManagement` Service state changes. It is especially relevant for those wishing to implement or enhance business logic based on interactions with `ExpenseManagement` objects.

**Overview**

This section provides detailed instructions on monitoring service events, covering payload structures and demonstrating typical use cases through examples.

# Authentication and Authorization

Access to the `ExpenseManagement` service's events is facilitated through the project's Kafka server, which is not accessible to the public. Subscription to a Kafka topic requires being on the same network and possessing valid Kafka user credentials.  This document presupposes that readers have existing access to the Kafka server.

Additionally, the service offers a public subscription option via REST for real-time data management in frontend applications, secured through REST API authentication and authorization mechanisms. To subscribe to service events via the REST API, please consult the Realtime REST API Guide.

# Database Events

Database events are triggered at the database layer, automatically and atomically, in response to any modifications at the data level. These events serve to notify subscribers about the creation, update, or deletion of objects within the database, distinct from any overarching business logic. 

Listening to database events is particularly beneficial for those focused on tracking changes at the database level. A typical use case for subscribing to database events is to replicate the data store of one service within another service's scope, ensuring data consistency and syncronization across services.

For example, while a business operation such as "approve membership" might generate a high-level business event like `membership-approved`, the underlying database changes could involve multiple state updates to different entities. These might be published as separate events, such as `dbevent-member-updated` and `dbevent-user-updated`, reflecting the granular changes at the database level.

Such detailed eventing provides a robust foundation for building responsive, data-driven applications, enabling fine-grained observability and reaction to the dynamics of the data landscape. It also facilitates the architectural pattern of event sourcing, where state changes are captured as a sequence of events, allowing for high-fidelity data replication and history replay for analytical or auditing purposes.

## DbEvent expense-created

**Event topic**: `fintrack-expensemanagement-service-dbevent-expense-created`

This event is triggered upon the creation of a `expense` data object in the database. The event payload encompasses the newly created data, encapsulated within the root of the paylod.

**Event payload**: 
```json
{"id":"ID","amount":"Double","category":"String","currency":"String","date":"Date","description":"String","notes":"Text","supplierId":"ID","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  
## DbEvent expense-updated

**Event topic**: `fintrack-expensemanagement-service-dbevent-expense-updated`

Activation of this event follows the update of a `expense` data object. The payload contains the updated information under the `expense` attribute, along with the original data prior to update, labeled as `old_expense` and also you can find the old and new versions of updated-only portion of the data..

**Event payload**: 
```json
{
old_expense:{"id":"ID","amount":"Double","category":"String","currency":"String","date":"Date","description":"String","notes":"Text","supplierId":"ID","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
expense:{"id":"ID","amount":"Double","category":"String","currency":"String","date":"Date","description":"String","notes":"Text","supplierId":"ID","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
oldDataValues,
newDataValues
}
``` 
## DbEvent expense-deleted

**Event topic**: `fintrack-expensemanagement-service-dbevent-expense-deleted`

This event announces the deletion of a `expense` data object, covering both hard deletions (permanent removal) and soft deletions (where the `isActive` attribute is set to false). Regardless of the deletion type, the event payload will present the data as it was immediately before deletion, highlighting an `isActive` status of false for soft deletions.

**Event payload**: 
```json
{"id":"ID","amount":"Double","category":"String","currency":"String","date":"Date","description":"String","notes":"Text","supplierId":"ID","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  


# ElasticSearch Index Events

Within the `ExpenseManagement` service, most data objects are mirrored in ElasticSearch indices, ensuring these indices remain syncronized with their database counterparts through creation, updates, and deletions. These indices serve dual purposes: they act as a data source for external services and furnish aggregated data tailored to enhance frontend user experiences. Consequently, an ElasticSearch index might encapsulate data in its original form or aggregate additional information from other data objects. 

These aggregations can include both one-to-one and one-to-many relationships not only with database objects within the same service but also across different services. This capability allows developers to access comprehensive, aggregated data efficiently. By subscribing to ElasticSearch index events, developers are notified when an index is updated and can directly obtain the aggregated entity within the event payload, bypassing the need for separate ElasticSearch queries.

It's noteworthy that some services may augment another service's index by appending to the entity’s `extends` object. In such scenarios, an `*-extended` event will contain only the newly added data. Should you require the complete dataset, you would need to retrieve the full ElasticSearch index entity using the provided ID.

This approach to indexing and event handling facilitates a modular, interconnected architecture where services can seamlessly integrate and react to changes, enriching the overall data ecosystem and enabling more dynamic, responsive applications.



## Index Event expense-created

**Event topic**: `elastic-index-fintrack_expense-created`

**Event payload**:
```json
{"id":"ID","amount":"Double","category":"String","currency":"String","date":"Date","description":"String","notes":"Text","supplierId":"ID","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event expense-updated

**Event topic**: `elastic-index-fintrack_expense-created`

**Event payload**:
```json
{"id":"ID","amount":"Double","category":"String","currency":"String","date":"Date","description":"String","notes":"Text","supplierId":"ID","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event expense-deleted

**Event topic**: `elastic-index-fintrack_expense-deleted`

**Event payload**:
```json
{"id":"ID","amount":"Double","category":"String","currency":"String","date":"Date","description":"String","notes":"Text","supplierId":"ID","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event expense-extended

**Event topic**: `elastic-index-fintrack_expense-extended`

**Event payload**:
```js
{
  id: id,
  extends: {
    [extendName]: "Object",
    [extendName + "_count"]: "Number",
  },
}
``` 

# Route Events

Route events are emitted following the successful execution of a route. While most routes perform CRUD (Create, Read, Update, Delete) operations on data objects, resulting in route events that closely resemble database events, there are distinctions worth noting. A single route execution might trigger multiple CRUD actions and ElasticSearch indexing operations. However, for those primarily concerned with the overarching business logic and its outcomes, listening to the consolidated route event, published once at the conclusion of the route's execution, is more pertinent.

Moreover, routes often deliver aggregated data beyond the primary database object, catering to specific client needs. For instance, creating a data object via a route might not only return the entity's data but also route-specific metrics, such as the executing user's permissions related to the entity. Alternatively, a route might automatically generate default child entities following the creation of a parent object. Consequently, the route event encapsulates a unified dataset encompassing both the parent and its children, in contrast to individual events triggered for each entity created. Therefore, subscribing to route events can offer a richer, more contextually relevant set of information aligned with business logic.

The payload of a route event mirrors the REST response JSON of the route, providing a direct and comprehensive reflection of the data and metadata communicated to the client. This ensures that subscribers to route events receive a payload that encapsulates both the primary data involved and any additional information deemed significant at the business level, facilitating a deeper understanding and integration of the service's functional outcomes.


## Route Event expense-created

**Event topic** : `fintrack-expensemanagement-service-expense-created`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `expense` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`expense`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"201","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"expense","method":"POST","action":"create","appVersion":"Version","rowCount":1,"expense":{"id":"ID","amount":"Double","category":"String","currency":"String","date":"Date","description":"String","notes":"Text","supplierId":"ID","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event expense-deleted

**Event topic** : `fintrack-expensemanagement-service-expense-deleted`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `expense` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`expense`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"expense","method":"DELETE","action":"delete","appVersion":"Version","rowCount":1,"expense":{"id":"ID","amount":"Double","category":"String","currency":"String","date":"Date","description":"String","notes":"Text","supplierId":"ID","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event expense-retrived

**Event topic** : `fintrack-expensemanagement-service-expense-retrived`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `expense` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`expense`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"expense","method":"GET","action":"get","appVersion":"Version","rowCount":1,"expense":{"supplier":{"address":"Text","contactEmail":"String","contactName":"String","name":"String","phone":"String","taxNumber":"String"},"isActive":true}}
```  
## Route Event expenses-listed

**Event topic** : `fintrack-expensemanagement-service-expenses-listed`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `expenses` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`expenses`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"expenses","method":"GET","action":"list","appVersion":"Version","rowCount":"\"Number\"","expenses":[{"supplier":[{"name":"String"},{},{}],"isActive":true},{},{}],"paging":{"pageNumber":"Number","pageRowCount":"NUmber","totalRowCount":"Number","pageCount":"Number"},"filters":[],"uiPermissions":[]}
```  
## Route Event expense-updated

**Event topic** : `fintrack-expensemanagement-service-expense-updated`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `expense` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`expense`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"expense","method":"PATCH","action":"update","appVersion":"Version","rowCount":1,"expense":{"id":"ID","amount":"Double","category":"String","currency":"String","date":"Date","description":"String","notes":"Text","supplierId":"ID","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  




# Copyright
All sources, documents and other digital materials are copyright of .

# About Us
For more information please visit our website: .

.
.


---

## Data Objects

<a id="expensemanagement-service-expense-design"></a>

### Service Design Specification - Object Design for expense

# Service Design Specification - Object Design for expense
**fintrack-expensemanagement-service** documentation

## Document Overview
This document outlines the object design for the `expense` model in our application. It includes details about the model's attributes, relationships, and any specific validation or business logic that applies.

## expense Data Object

### Object Overview
**Description:** Represents a general expense not tied to any invoice, always scoped to a single business. Can be categorized, linked (optionally) to a supplier, and used in future financial analysis. All fields support Unicode, amount is always in business-relevant currency.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessProtected — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.








### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `amount` | Double | Yes | Expense amount (must be positive, required). |
| `category` | String | Yes | Expense category for grouping/filtering/reporting (e.g., &#34;utilities&#34;, &#34;travel&#34;). Free text now, could migrate to a static data object in future. |
| `currency` | String | Yes | ISO currency code (e.g. &#39;USD&#39;). Required for reporting, summaries, and multi-currency future support. |
| `date` | Date | Yes | Date the expense occurred. Required for reporting, sorting, and filtering. |
| `description` | String | Yes | Required human-readable description of the expense (e.g., purpose or detail). |
| `notes` | Text | No | Internal notes/justification—never exposed to public/customers. Optional. |
| `supplierId` | ID | No | Optional link to a known supplier. May be null/omitted for uncategorized/general expenses. |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **amount**: 0.0
- **category**: 'default'
- **currency**: 'default'
- **date**: new Date()
- **description**: 'default'
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`amount` `category` `currency` `date` `description` `notes` `supplierId`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

 

 

### Elastic Search Indexing

`amount` `category` `currency` `date` `description` `supplierId` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`amount` `category` `date` `supplierId` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.





### Secondary Key Properties

`businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.


### Relation Properties

`supplierId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **supplierId**: ID
Relation to `supplier`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: No





### Filter Properties

`amount` `category` `currency` `date` `description` `supplierId` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **amount**: Double  has a filter named `amount`

- **category**: String  has a filter named `category`

- **currency**: String  has a filter named `currency`

- **date**: Date  has a filter named `date`

- **description**: String  has a filter named `description`

- **supplierId**: ID  has a filter named `supplierId`

- **businessId**: ID  has a filter named `businessId`



  

---

## Business APIs

<a id="expensemanagement-service-business-api-createexpense-api-design"></a>

### Business API Design Specification - `Create Expense`


# Business API Design Specification - `Create Expense`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `createExpense` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `createExpense` Business API is designed to handle a `create` operation on the `Expense` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Create a new expense entry for the current business. Owner/Accountant roles required. Inputs: date, amount, currency, category, description, optional supplierId, notes. Validates positivity. Returns created expense.

## API Frontend Description By The Backend Architect

Provide an expense creation form with required fields (date, amount, currency, category, description), optional supplier search/link, and notes. Role-based access: only Owner/Accountant may create expenses. UX should validate positive amount and require fields before submit.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `expense-created` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `createExpense` Business API includes a REST controller that can be triggered via the following route:

`/v1/expenses`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `createExpense` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `createExpense` Business API has 8 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `expenseId`                             | `ID`   | `No` | `-` | `body` | `expenseId` |
| **Description:**                                | This id paremeter is used to create the data object with a given specific id. Leave null for automatic id. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `amount`                             | `Double`   | `Yes` | `-` | `body` | `amount` |
| **Description:**                                | Expense amount (must be positive, required). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `category`                             | `String`   | `Yes` | `-` | `body` | `category` |
| **Description:**                                | Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `currency`                             | `String`   | `Yes` | `-` | `body` | `currency` |
| **Description:**                                | ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `date`                             | `Date`   | `Yes` | `-` | `body` | `date` |
| **Description:**                                | Date the expense occurred. Required for reporting, sorting, and filtering. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `description`                             | `String`   | `Yes` | `-` | `body` | `description` |
| **Description:**                                | Required human-readable description of the expense (e.g., purpose or detail). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `notes`                             | `Text`   | `No` | `-` | `body` | `notes` |
| **Description:**                                | Internal notes/justification—never exposed to public/customers. Optional. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `supplierId`                             | `ID`   | `No` | `-` | `body` | `supplierId` |
| **Description:**                                | Optional link to a known supplier. May be null/omitted for uncategorized/general expenses. |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `createExpense` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`






---





## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 



**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  id: this.expenseId,
  businessId: this.businessId,
  amount: this.amount,
  category: this.category,
  currency: this.currency,
  date: this.date,
  description: this.description,
  notes: this.notes,
  supplierId: this.supplierId,
  isActive: true,
  _archivedAt: null,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, populates session and request objects, prepares internal structures for parameter handling and workflow execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads input parameters, normalizes missing values, applies default type casting, and stores them in the API context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager transforms parameters, computes derived values, flattens or remaps arrays/objects, and adjusts formats for downstream processing.


---




### [4] Step : checkParameters

Manager executes built-in validations: required field checks, type enforcement, and basic business rules. Prevents operation if validation fails.


---




### [5] Step : checkBasicAuth

Manager performs authentication and authorization checks: verifies session, user roles, permissions, and tenant restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildDataClause

Manager constructs the final data object for creation, fills auto-generated fields (IDs, timestamps, owner fields), and ensures schema consistency.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [7] Step : mainCreateOperation

Manager executes the database insert operation, updates indexes/caches, and triggers internal post-processing like linked default records.


---




### [8] Step : buildOutput

Manager shapes the response: masks sensitive fields, resolves linked references, and formats output according to API contract.


---




### [9] Step : sendResponse

Manager sends the response to the client and finalizes internal tasks like flushing logs or updating session state.


---




### [10] Step : raiseApiEvent

Manager triggers API-level events (Kafka, WebSocket, async workflows) as the final internal step.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `createExpense` api has got 7 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| amount  | Double  | true | request.body?.["amount"] |
| category  | String  | true | request.body?.["category"] |
| currency  | String  | true | request.body?.["currency"] |
| date  | Date  | true | request.body?.["date"] |
| description  | String  | true | request.body?.["description"] |
| notes  | Text  | false | request.body?.["notes"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |

### REST Request
To access the api you can use the **REST** controller with the path **POST  /v1/expenses**
```js
  axios({
    method: 'POST',
    url: '/v1/expenses',
    data: {
            amount:"Double",  
            category:"String",  
            currency:"String",  
            date:"Date",  
            description:"String",  
            notes:"Text",  
            supplierId:"ID",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`expense`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"id": "ID",
		"amount": "Double",
		"category": "String",
		"currency": "String",
		"date": "Date",
		"description": "String",
		"notes": "Text",
		"supplierId": "ID",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="expensemanagement-service-business-api-deleteexpense-api-design"></a>

### Business API Design Specification - `Delete Expense`


# Business API Design Specification - `Delete Expense`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `deleteExpense` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `deleteExpense` Business API is designed to handle a `delete` operation on the `Expense` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Soft delete an expense (mark as inactive). Only Owner/Accountant can delete. Expense remains for history/audit; not shown in default lists.

## API Frontend Description By The Backend Architect

Delete operation is allowed for Owner/Accountant only (no UI access for Users). Deletion is always soft (isActive=false). Do not show deleted expenses in main lists or reports. UI should visually confirm before deletion.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `expense-deleted` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `deleteExpense` Business API includes a REST controller that can be triggered via the following route:

`/v1/expenses/:expenseId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `deleteExpense` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `deleteExpense` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `expenseId`                             | `ID`   | `Yes` | `-` | `urlpath` | `expenseId` |
| **Description:**                                | This id paremeter is used to select the required data object that will be deleted |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `deleteExpense` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`






---



## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.expenseId},{businessId:this.businessId,isActive:true}]}
```





## Delete Options
Use these options to set `delete` specific settings.

**useSoftDelete**: true
If true, the record will be marked as deleted `(isActive: false)` instead of removed. The implementation depends on the data object’s soft delete configuration.





   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, prepares request/session objects, and sets up internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads and normalizes parameters, applies defaults, and stores them in the context for downstream steps.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager executes parameter transform scripts, computes derived values, and remaps objects or arrays as needed for later processing.


---




### [4] Step : checkParameters

Manager runs built-in validations including required field checks, type enforcement, and deletion preconditions. Stops execution if validation fails.


---




### [5] Step : checkBasicAuth

Manager validates session, user roles, permissions, and tenant-specific access rules to enforce basic auth restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Manager generates the query conditions, applies ownership and parent checks, and ensures the clause is correct for the delete operation.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : fetchInstance

Manager fetches the target record, applies filters from WHERE clause, and writes the instance to the context for further checks.


---




### [8] Step : checkInstance

Manager performs object-level validations such as lock status, soft-delete eligibility, and multi-step approval enforcement.


---




### [9] Step : mainDeleteOperation

Manager executes the delete query, updates related indexes/caches, and handles soft/hard delete logic according to configuration.


You can use the following settings to change some behavior of this step.
`deleteOptions`
---




### [10] Step : buildOutput

Manager shapes the response payload, masks sensitive fields, and formats related cleanup results for output.


---




### [11] Step : sendResponse

Manager delivers the response to the client and finalizes any temporary internal structures.


---




### [12] Step : raiseApiEvent

Manager triggers asynchronous API events, notifies queues or streams, and performs final cleanup for the workflow.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `deleteExpense` api has got 1 regular client parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| expenseId  | ID  | true | request.params?.["expenseId"] |

### REST Request
To access the api you can use the **REST** controller with the path **DELETE  /v1/expenses/:expenseId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/expenses/${expenseId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`expense`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"id": "ID",
		"amount": "Double",
		"category": "String",
		"currency": "String",
		"date": "Date",
		"description": "String",
		"notes": "Text",
		"supplierId": "ID",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="expensemanagement-service-business-api-getexpense-api-design"></a>

### Business API Design Specification - `Get Expense`


# Business API Design Specification - `Get Expense`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `getExpense` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `getExpense` Business API is designed to handle a `get` operation on the `Expense` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Retrieve a single expense by ID, scoped to current business. Any business user (owner/accountant/user) can view details (for reporting, reference, etc).

## API Frontend Description By The Backend Architect

Expense detail screens show all fields, supplier name if present (lookup), and notes where authorized. No editing possible for Users; view only. Owner/Accountant may then open update/delete screens from here. Supplier (if present) should present full supplier name/details in details UX.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `expense-retrived` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `getExpense` Business API includes a REST controller that can be triggered via the following route:

`/v1/expenses/:expenseId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `getExpense` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `getExpense` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `expenseId`                             | `ID`   | `Yes` | `-` | `urlpath` | `expenseId` |
| **Description:**                                | This id paremeter is used to query the required data object. |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `getExpense` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`






---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

`id`,`date`,`amount`,`currency`,`category`,`description`,`supplierId`,`notes`,`isActive`,`createdAt`,`updatedAt`


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.expenseId},{businessId:this.businessId,isActive:true}]}
```







## Get Options
Use these options to set `get` specific settings.

**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.





   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Extracts parameters from request and Redis, applies defaults, and writes them to context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Executes parameter transformation scripts, applies type coercion, merges derived values, and reshapes inputs for downstream milestones.


---




### [4] Step : checkParameters

Validates required and custom parameters, enforcing business-specific rules and constraints.


---




### [5] Step : checkBasicAuth

Performs login, role, and permission checks, and applies dynamic object-level access rules.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Builds the WHERE clause for fetching the object and applies additional scoped filters if configured.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainGetOperation

Executes the database fetch, retrieves the object, and stores it in context for enrichment or further checks.


You can use the following settings to change some behavior of this step.
`selectClause`, `getOptions`
---




### [8] Step : checkInstance

Performs instance-level validations, such as ownership, existence, or access conditions.


---




### [9] Step : buildOutput

Assembles the response from the object, applies masking, formatting, and injects additional metadata if needed.


---




### [10] Step : sendResponse

Delivers the response to the controller for client delivery.


---




### [11] Step : raiseApiEvent

Triggers optional API-level events after workflow completion, sending messages to integrations like Kafka if configured.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `getExpense` api has got 1 regular client parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| expenseId  | ID  | true | request.params?.["expenseId"] |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/expenses/:expenseId**
```js
  axios({
    method: 'GET',
    url: `/v1/expenses/${expenseId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`expense`** object in the respones. However, some properties may be omitted based on the object's internal logic.

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"supplier": {
			"address": "Text",
			"contactEmail": "String",
			"contactName": "String",
			"name": "String",
			"phone": "String",
			"taxNumber": "String"
		},
		"isActive": true
	}
}
```  

---

<a id="expensemanagement-service-business-api-listexpenses-api-design"></a>

### Business API Design Specification - `List Expenses`


# Business API Design Specification - `List Expenses`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `listExpenses` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `listExpenses` Business API is designed to handle a `list` operation on the `Expense` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

List expenses for the current business; supports filtering by date range, amount, currency, category, description (search), and supplierId. View access for all business roles. Used for main expense table, reporting, and analysis.

## API Frontend Description By The Backend Architect

Expense table/report views: allow filtering by date, category, supplier, currency, amount range, and fulltext search on description. Results strictly limited to the user's business. All logged-in business users can list expenses. Pagination and sorting as per UI needs. Export, analytics, and aggregation handled in reporting layer.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `expenses-listed` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `listExpenses` Business API includes a REST controller that can be triggered via the following route:

`/v1/expenses`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `listExpenses` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters


The `listExpenses` Business API does not require any parameters to be provided from the controllers.

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `listExpenses` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`






---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

`id`,`date`,`amount`,`currency`,`category`,`description`,`supplierId`,`notes`,`isActive`,`createdAt`,`updatedAt`


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{businessId:this.businessId,isActive:true}
```









## List Options
Defines list-specific options including filtering logic, default sorting, and result customization for APIs that return multiple records.

**List Sort By**
Sort order definitions for the result set. Multiple fields can be provided with direction (asc/desc).

[ date desc,createdAt desc ]


**List Group By**
Grouping definitions for the result set. This is typically used for visual or report-based grouping.

*The list is not grouped.*



**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.


**Permission Filter**
Optional filter that applies permission constraints dynamically based on session or object roles. So that the list items are filtered by the user's OBAC or ABAC permissions.

*Permission filter is not active at the moment. Follow Mindbricks updates to be able to use it.*

## Pagination Options
Contains settings to configure pagination behavior for `list` APIs. Includes options like page size, offset, cursor support, and total count inclusion.



   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Reads request and Redis parameters, applies defaults, and writes them to context for downstream processing.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Transforms and normalizes parameters, derives dependent values, and reshapes inputs for the main list query.


---




### [4] Step : checkParameters

Executes validation logic on required and custom parameters, enforcing business rules and cross-field consistency.


---




### [5] Step : checkBasicAuth

Performs role-based access checks and applies dynamic membership or session-based restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Constructs the main query WHERE clause and applies optional filters or scoped access controls.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainListOperation

Executes the paginated database query, retrieves the list, and stores results in context for enrichment.


You can use the following settings to change some behavior of this step.
`selectClause`, `listOptions`, `paginationOptions`
---




### [8] Step : buildOutput

Assembles the list response, sanitizes sensitive fields, applies transformations, and injects extra context if needed.


---




### [9] Step : sendResponse

Sends the paginated list to the client through the controller.


---




### [10] Step : raiseApiEvent

Triggers optional post-workflow events, such as Kafka messages, logs, or system notifications.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.
The `listExpenses` api has got no visible parameters.    

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/expenses**
```js
  axios({
    method: 'GET',
    url: '/v1/expenses',
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`expenses`** object in the respones. However, some properties may be omitted based on the object's internal logic.

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expenses",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"expenses": [
		{
			"supplier": [
				{
					"name": "String"
				},
				{},
				{}
			],
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```  

---

<a id="expensemanagement-service-business-api-updateexpense-api-design"></a>

### Business API Design Specification - `Update Expense`


# Business API Design Specification - `Update Expense`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `updateExpense` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `updateExpense` Business API is designed to handle a `update` operation on the `Expense` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Update an existing expense for current business. Only Owner/Accountant may update. Amount must remain positive; supplier if (re)set, must exist. Returns updated expense.

## API Frontend Description By The Backend Architect

Expense update form should prefill all fields, allow edit of any but auto restrict negative/empty requireds. Only Owner/Accountant can update expenses. Validate all new values client and server side; supplier link optional but validated if changed.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `expense-updated` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `updateExpense` Business API includes a REST controller that can be triggered via the following route:

`/v1/expenses/:expenseId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `updateExpense` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `updateExpense` Business API has 8 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `expenseId`                             | `ID`   | `Yes` | `-` | `urlpath` | `expenseId` |
| **Description:**                                | This id paremeter is used to select the required data object that will be updated |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `amount`                             | `Double`   | `No` | `-` | `body` | `amount` |
| **Description:**                                | Expense amount (must be positive, required). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `category`                             | `String`   | `No` | `-` | `body` | `category` |
| **Description:**                                | Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `currency`                             | `String`   | `No` | `-` | `body` | `currency` |
| **Description:**                                | ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `date`                             | `Date`   | `No` | `-` | `body` | `date` |
| **Description:**                                | Date the expense occurred. Required for reporting, sorting, and filtering. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `description`                             | `String`   | `No` | `-` | `body` | `description` |
| **Description:**                                | Required human-readable description of the expense (e.g., purpose or detail). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `notes`                             | `Text`   | `No` | `-` | `body` | `notes` |
| **Description:**                                | Internal notes/justification—never exposed to public/customers. Optional. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `supplierId`                             | `ID`   | `No` | `-` | `body` | `supplierId` |
| **Description:**                                | Optional link to a known supplier. May be null/omitted for uncategorized/general expenses. |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `updateExpense` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`






---



## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.expenseId},{businessId:this.businessId,isActive:true}]}
```




## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 


An update data clause populates all update-allowed properties of a data object, however the null properties (that are not provided by client) are ignored in db layer.


**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  amount: this.amount,
  category: this.category,
  currency: this.currency,
  date: this.date,
  description: this.description,
  notes: this.notes,
  supplierId: this.supplierId,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, prepares request and session objects, and sets up internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads parameters from the request or Redis, applies defaults, and writes them into context for downstream milestones.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager executes parameter transform scripts and derives any helper values or reshaped payloads into the context.


---




### [4] Step : checkParameters

Manager validates required parameters, checks ID formats (UUID/ObjectId), and ensures all preconditions for update are met.


---




### [5] Step : checkBasicAuth

Manager performs login verification, role, and permission checks, enforcing tenant and access rules before update.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Manager constructs the WHERE clause used to identify the record to update, applying ownership and parent checks if necessary.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : fetchInstance

Manager fetches the existing record from the database and writes it to the context for validation or enrichment.


---




### [8] Step : checkInstance

Manager performs instance-level validations, including ownership, existence, lock status, or other pre-update checks.


---




### [9] Step : buildDataClause

Manager prepares the data clause for the update, applying transformations or enhancements before persisting.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [10] Step : mainUpdateOperation

Manager executes the update operation with the WHERE and data clauses. Database-level events are raised if configured.


---




### [11] Step : buildOutput

Manager assembles the response object from the update result, masking fields or injecting additional metadata.


---




### [12] Step : sendResponse

Manager sends the response back to the controller for delivery to the client.


---




### [13] Step : raiseApiEvent

Manager triggers API-level events, sending relevant messages to Kafka or other integrations if configured.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `updateExpense` api has got 8 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| expenseId  | ID  | true | request.params?.["expenseId"] |
| amount  | Double  | false | request.body?.["amount"] |
| category  | String  | false | request.body?.["category"] |
| currency  | String  | false | request.body?.["currency"] |
| date  | Date  | false | request.body?.["date"] |
| description  | String  | false | request.body?.["description"] |
| notes  | Text  | false | request.body?.["notes"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |

### REST Request
To access the api you can use the **REST** controller with the path **PATCH  /v1/expenses/:expenseId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/expenses/${expenseId}`,
    data: {
            amount:"Double",  
            category:"String",  
            currency:"String",  
            date:"Date",  
            description:"String",  
            notes:"Text",  
            supplierId:"ID",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`expense`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expense",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"expense": {
		"id": "ID",
		"amount": "Double",
		"category": "String",
		"currency": "String",
		"date": "Date",
		"description": "String",
		"notes": "Text",
		"supplierId": "ID",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="expensemanagement-service-business-api--fetchlistexpense-api-design"></a>

### Business API Design Specification - `_fetch Listexpense`


# Business API Design Specification - `_fetch Listexpense`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `_fetchListExpense` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `_fetchListExpense` Business API is designed to handle a `list` operation on the `Expense` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

System API to fetch list of expense records for frontend application. Auto-generated, not visible in design.


## API Options 

* **Auto Params** : `false`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `false`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `_fetchListExpense` Business API includes a REST controller that can be triggered via the following route:

`/v1/_fetchlistexpense`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `_fetchListExpense` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `_fetchListExpense` Business API has 6 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.


### Filter Parameters

The `_fetchListExpense` api supports 6 optional filter parameters for filtering list results using URL query parameters. These parameters are only available for `list` type APIs.

#### `amount` Filter

**Type:** `Double`  
**Description:** Expense amount (must be positive, required).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property:**
- Single value: `?amount=<value>`
- Multiple values: `?amount=<value1>&amount=<value2>`
- Range operators: `?amount=$lt-<value>`, `?amount=$lte-<value>`, `?amount=$gt-<value>`, `?amount=$gte-<value>`, `?amount=$btw-<min>-<max>`
- Null check: `?amount=null`

**Range Operators:**
- `$lt-<value>` - Less than
- `$lte-<value>` - Less than or equal
- `$gt-<value>` - Greater than
- `$gte-<value>` - Greater than or equal
- `$btw-<min>-<max>` - Between (inclusive)

**Examples:**
```javascript
// Get records with exact value
GET /v1/_fetchlistexpense?amount=25

// Get records with multiple values (use multiple parameters)
GET /v1/_fetchlistexpense?amount=25&amount=30&amount=35

// Get records less than value
GET /v1/_fetchlistexpense?amount=$lt-30

// Get records greater than or equal to value
GET /v1/_fetchlistexpense?amount=$gte-18

// Get records between two values
GET /v1/_fetchlistexpense?amount=$btw-100-500

// Get records without this field
GET /v1/_fetchlistexpense?amount=null
```


#### `category` Filter

**Type:** `String`  
**Description:** Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future.  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Case-Insensitive Partial Matching):**
- Single value: `?category=<value>` (matches any string containing the value, case-insensitive)
- Multiple values: `?category=<value1>&category=<value2>` (matches records containing any of the values)
- Null check: `?category=null`

**Examples:**
```javascript
// Find records with "john" in the field (case-insensitive partial match)
GET /v1/_fetchlistexpense?category=john
// Matches: "John", "Johnny", "johnson", "McJohn", etc.

// Find records with multiple values (use multiple parameters)
GET /v1/_fetchlistexpense?category=laptop&category=phone&category=tablet
// Matches records containing "laptop", "phone", or "tablet" anywhere in the field

// Find records without this field
GET /v1/_fetchlistexpense?category=null
```


#### `currency` Filter

**Type:** `String`  
**Description:** ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support.  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Case-Insensitive Partial Matching):**
- Single value: `?currency=<value>` (matches any string containing the value, case-insensitive)
- Multiple values: `?currency=<value1>&currency=<value2>` (matches records containing any of the values)
- Null check: `?currency=null`

**Examples:**
```javascript
// Find records with "john" in the field (case-insensitive partial match)
GET /v1/_fetchlistexpense?currency=john
// Matches: "John", "Johnny", "johnson", "McJohn", etc.

// Find records with multiple values (use multiple parameters)
GET /v1/_fetchlistexpense?currency=laptop&currency=phone&currency=tablet
// Matches records containing "laptop", "phone", or "tablet" anywhere in the field

// Find records without this field
GET /v1/_fetchlistexpense?currency=null
```


#### `date` Filter

**Type:** `Date`  
**Description:** Date the expense occurred. Required for reporting, sorting, and filtering.  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Date filtering matches records where the date falls within the specified day, ignoring time portion):**
- Single date: `?date=2024-01-15`
- Multiple dates: `?date=2024-01-15&date=2024-01-20`
- Special operators: `?date=$today`, `?date=$week`, `?date=$month`
- Local timezone: `?date=$ltoday`, `?date=$lweek`, `?date=$leq-2024-01-15`, `?date=$lin-2024-01-15&date=$lin-2024-01-20`
- Null check: `?date=null`

**Special Date Operators:**
- `$today` - Today (server timezone)
- `$ltoday` - Today (user's local timezone)
- `$week` - This week (server timezone)
- `$lweek` - This week (user's local timezone)
- `$month` - This month (server timezone)
- `$leq-<date>` - Specific date (user's local timezone)
- `$lin-<date>` - Date in array (user's local timezone, use multiple parameters)

**Date Formats:**
Dates can be provided in ISO 8601 format (`2024-01-15`, `2024-01-15T10:30:00Z`) or as timestamps (`1705324800000`).

**Examples:**
```javascript
// Get records created on a specific date
GET /v1/_fetchlistexpense?date=2024-01-15

// Get records created on multiple dates (use multiple parameters)
GET /v1/_fetchlistexpense?date=2024-01-15&date=2024-01-20

// Get records created today (server timezone)
GET /v1/_fetchlistexpense?date=$today

// Get records created today (user's local timezone)
GET /v1/_fetchlistexpense?date=$ltoday

// Get records created this week (server timezone)
GET /v1/_fetchlistexpense?date=$week

// Get records created this week (user's local timezone)
GET /v1/_fetchlistexpense?date=$lweek

// Get records created this month
GET /v1/_fetchlistexpense?date=$month

// Get records created on a specific date (user's local timezone)
GET /v1/_fetchlistexpense?date=$leq-2024-01-15

// Get records created on multiple dates (user's local timezone, use multiple parameters)
GET /v1/_fetchlistexpense?date=$lin-2024-01-15&date=$lin-2024-01-20

// Get records without this field
GET /v1/_fetchlistexpense?date=null
```


#### `description` Filter

**Type:** `String`  
**Description:** Required human-readable description of the expense (e.g., purpose or detail).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Case-Insensitive Partial Matching):**
- Single value: `?description=<value>` (matches any string containing the value, case-insensitive)
- Multiple values: `?description=<value1>&description=<value2>` (matches records containing any of the values)
- Null check: `?description=null`

**Examples:**
```javascript
// Find records with "john" in the field (case-insensitive partial match)
GET /v1/_fetchlistexpense?description=john
// Matches: "John", "Johnny", "johnson", "McJohn", etc.

// Find records with multiple values (use multiple parameters)
GET /v1/_fetchlistexpense?description=laptop&description=phone&description=tablet
// Matches records containing "laptop", "phone", or "tablet" anywhere in the field

// Find records without this field
GET /v1/_fetchlistexpense?description=null
```


#### `supplierId` Filter

**Type:** `ID`  
**Description:** Optional link to a known supplier. May be null/omitted for uncategorized/general expenses.  
**Location:** Query Parameter

**Usage:**

**Non-Array Property:**
- Single value: `?supplierId=<value>`
- Multiple values: `?supplierId=<value1>&supplierId=<value2>`
- Null check: `?supplierId=null`

**Examples:**
```javascript
// Get records with a specific ID
GET /v1/_fetchlistexpense?supplierId=550e8400-e29b-41d4-a716-446655440000

// Get records with multiple IDs (use multiple parameters)
GET /v1/_fetchlistexpense?supplierId=550e8400-e29b-41d4-a716-446655440000&supplierId=660e8400-e29b-41d4-a716-446655440001

// Get records without this field
GET /v1/_fetchlistexpense?supplierId=null
```



  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `_fetchListExpense` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`






---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

``


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{businessId:this.businessId,isActive:true}
```









## List Options
Defines list-specific options including filtering logic, default sorting, and result customization for APIs that return multiple records.

**List Sort By**
Sort order definitions for the result set. Multiple fields can be provided with direction (asc/desc).

[ createdAt desc ]


**List Group By**
Grouping definitions for the result set. This is typically used for visual or report-based grouping.

*The list is not grouped.*



**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.


**Permission Filter**
Optional filter that applies permission constraints dynamically based on session or object roles. So that the list items are filtered by the user's OBAC or ABAC permissions.

*Permission filter is not active at the moment. Follow Mindbricks updates to be able to use it.*

## Pagination Options
Contains settings to configure pagination behavior for `list` APIs. Includes options like page size, offset, cursor support, and total count inclusion.



   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Reads request and Redis parameters, applies defaults, and writes them to context for downstream processing.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Transforms and normalizes parameters, derives dependent values, and reshapes inputs for the main list query.


---




### [4] Step : checkParameters

Executes validation logic on required and custom parameters, enforcing business rules and cross-field consistency.


---




### [5] Step : checkBasicAuth

Performs role-based access checks and applies dynamic membership or session-based restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Constructs the main query WHERE clause and applies optional filters or scoped access controls.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainListOperation

Executes the paginated database query, retrieves the list, and stores results in context for enrichment.


You can use the following settings to change some behavior of this step.
`selectClause`, `listOptions`, `paginationOptions`
---




### [8] Step : buildOutput

Assembles the list response, sanitizes sensitive fields, applies transformations, and injects extra context if needed.


---




### [9] Step : sendResponse

Sends the paginated list to the client through the controller.


---




### [10] Step : raiseApiEvent

Triggers optional post-workflow events, such as Kafka messages, logs, or system notifications.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `_fetchListExpense` api has 6 filter parameters available for filtering list results. See the [Filter Parameters](#filter-parameters) section above for detailed usage examples.

| Filter Parameter       | Type                   | Array Property | Description                   |
| ---------------------- | ---------------------- | -------------- | ----------------------------- |
| amount  | Double  | No | Expense amount (must be positive, required). |
| category  | String  | No | Expense category for grouping/filtering/reporting (e.g., "utilities", "travel"). Free text now, could migrate to a static data object in future. |
| currency  | String  | No | ISO currency code (e.g. 'USD'). Required for reporting, summaries, and multi-currency future support. |
| date  | Date  | No | Date the expense occurred. Required for reporting, sorting, and filtering. |
| description  | String  | No | Required human-readable description of the expense (e.g., purpose or detail). |
| supplierId  | ID  | No | Optional link to a known supplier. May be null/omitted for uncategorized/general expenses. |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistexpense**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistexpense',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section for usage examples)
        // amount: '<value>' // Filter by amount
        // category: '<value>' // Filter by category
        // currency: '<value>' // Filter by currency
        // date: '<value>' // Filter by date
        // description: '<value>' // Filter by description
        // supplierId: '<value>' // Filter by supplierId
            }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`expenses`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "expenses",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"expenses": [
		{
			"id": "ID",
			"amount": "Double",
			"category": "String",
			"currency": "String",
			"date": "Date",
			"description": "String",
			"notes": "Text",
			"supplierId": "ID",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"supplier": [
				{
					"address": "Text",
					"contactEmail": "String",
					"contactName": "String",
					"name": "String",
					"notes": "Text",
					"phone": "String",
					"taxNumber": "String"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```  

---

# InvoiceManagement Service

<a id="invoicemanagement-service-service-design"></a>

## Service Design Specification



# Service Design Specification
**fintrack-invoicemanagement-service** documentation
**Version:** `1.0.1`

## Scope

This document provides a structured architectural overview of the `invoiceManagement` microservice, detailing its configuration, data model, authorization logic, business rules, and API design. It has been automatically generated based on the service definition within Mindbricks, ensuring that the information reflects the source of truth used during code generation and deployment.

The document is intended to serve multiple audiences:

* **Service architects** can use it to validate design decisions and ensure alignment with broader architectural goals.
* **Developers and maintainers** will find it useful for understanding the structure and behavior of the service, facilitating easier debugging, feature extension, and integration with other systems.
* **Stakeholders and reviewers** can use it to gain a clear understanding of the service's capabilities and domain logic.

> **Note for Frontend Developers**: While this document is valuable for understanding business logic and data interactions, please refer to the [Service API Documentation](#) for endpoint-level specifications and integration details.

> **Note for Backend Developers**: Since the code for this service is automatically generated by Mindbricks, you typically won't need to implement or modify it manually. However, this document is especially valuable when you're building other services—whether within Mindbricks or externally—that need to interact with or depend on this service. It provides a clear reference to the service's data contracts, business rules, and API structure, helping ensure compatibility and correct integration.



## `InvoiceManagement` Service Settings [**Edit**](invoicemanagement/serviceSettings)

Handles creation and modification of all sales (outgoing) and purchase (incoming) invoices for FinTrack SMBs. Supports multi-item entry per invoice, VAT at item level, detailed filtering, and status calculation based on payments and due dates. Strictly scoped to a single business context.

### Service Overview

This service is configured to listen for HTTP requests on port `3001`, 
serving both the main API interface and default administrative endpoints.

The following routes are available by default:

* **API Test Interface (API Face):** `/`
* **Swagger Documentation:** `/swagger`
* **Postman Collection Download:** `/getPostmanCollection`
* **Health Checks:** `/health` and `/admin/health`
* **Current Session Info:** `/currentuser`
* **Favicon:** `/favicon.ico`

The service uses a **PostgreSQL** database for data storage, with the database name set to `fintrack-invoicemanagement-service`.

This service is accessible via the following environment-specific URLs:

* **Preview:** `https://fintrack.prw.mindbricks.com/invoicemanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/invoicemanagement-api`
* **Production:** `https://fintrack.mindbricks.co/invoicemanagement-api`

                                 

### Authentication & Security
- **Login Required**: Yes

This service requires user authentication for access. It supports both JWT and RSA-based authentication mechanisms, ensuring secure user sessions and data integrity.
If a crud route also is configured to require login, 
it will check a valid JWT token in the request query/header/bearer/cookie. If the token is valid, it will extract the user information from the token and make the fetched session data available in the request context.

  
### Service Data Objects
The service uses a **PostgreSQL** database for data storage, with the database name set to `fintrack-invoicemanagement-service`.

Data deletion is managed using a **soft delete** strategy. Instead of removing records from the database, they are flagged as inactive by setting the `isActive` field to `false`.



| Object Name | Description | Public Access | Tenant Level  | 
|-------------|-------------|---------------| --------------| 
| `invoice` | Represents a single sales or purchase invoice document for a business. Contains summary information, partner (customer/supplier), and status derived from payments and dates. | accessPrivate |  Yes | 
| `invoiceItem` | Represents a single line item in an invoice, with product/service linkage, quantity, pricing, VAT, and per-line total. | accessPrivate |  Yes | 




## invoice Data Object

### Object Overview
**Description:** Represents a single sales or purchase invoice document for a business. Contains summary information, partner (customer/supplier), and status derived from payments and dates.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessPrivate — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.




### Composite Indexes

- **businessInvoiceNumberUnique**: [businessId, invoiceNumber] 
This composite index is defined to optimize query performance for complex queries involving multiple fields.

The index also defines a conflict resolution strategy for duplicate key violations.

When a new record would violate this composite index, the following action will be taken:

**On Duplicate**: `throwError`

An error will be thrown, preventing the insertion of conflicting data.






### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `currency` | String | Yes | Currency code for all values in invoice and its items (e.g., &#39;USD&#39;). |
| `customerId` | ID | No | Referenced customer (for sales invoice; null for purchase invoice). |
| `dueDate` | Date | Yes | Date by which payment for this invoice is due. |
| `invoiceNumber` | String | Yes | A unique identifier (number/code) for this invoice within a business. |
| `issueDate` | Date | Yes | Date this invoice was issued. |
| `notes` | Text | No | Internal notes about the invoice, never publicly exposed. |
| `status` | Enum | Yes | Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate. |
| `supplierId` | ID | No | Referenced supplier (for purchase invoice; null for sales invoice). |
| `totalAmount` | Double | Yes | Grand total for invoice (sum of line item totals, including VAT). Calculated; always up-to-date. |
| `type` | Enum | Yes | Invoice nature; &#39;sales&#39;=outgoing, &#39;purchase&#39;=incoming. |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **currency**: 'default'
- **dueDate**: new Date()
- **invoiceNumber**: 'default'
- **issueDate**: new Date()
- **status**: unpaid
- **totalAmount**: 0.0
- **type**: "sales"
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`status` `totalAmount` `type` `businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`currency` `customerId` `dueDate` `invoiceNumber` `issueDate` `notes` `status` `supplierId` `type`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

### Enum Properties
Enum properties are defined with a set of allowed values, ensuring that only valid options can be assigned to them. 
The enum options value will be stored as strings in the database, 
but when a data object is created an addtional property with the same name plus an idx suffix will be created, which will hold the index of the selected enum option.
You can use the index property to sort by the enum value or when your enum options represent a sequence of values.

- **status**: [unpaid, partial, paid, overdue]

- **type**: [sales, purchase]

 

 

### Elastic Search Indexing

`currency` `customerId` `dueDate` `invoiceNumber` `issueDate` `status` `supplierId` `totalAmount` `type` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`currency` `customerId` `dueDate` `invoiceNumber` `issueDate` `status` `supplierId` `type` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.





### Secondary Key Properties

`invoiceNumber` `businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.


### Relation Properties

`customerId` `supplierId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **customerId**: ID
Relation to `customer`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: No

- **supplierId**: ID
Relation to `supplier`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: No




### Formula Properties

`totalAmount`

Formula properties are used to define calculated fields that derive their values from other properties or external data.
These properties are automatically calculated based on the defined formula and can be used for dynamic data retrieval.

- **totalAmount**: Double  
  - Formula: `LIB.calculateInvoiceTotal(this)`
  
  - Calculate After Instance: Yes
  
  - Calculate When Input Has: [id]
  


### Filter Properties

`customerId` `dueDate` `invoiceNumber` `issueDate` `status` `supplierId` `type` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **customerId**: ID  has a filter named `customerId`

- **dueDate**: Date  has a filter named `dueDate`

- **invoiceNumber**: String  has a filter named `invoiceNumber`

- **issueDate**: Date  has a filter named `issueDate`

- **status**: Enum  has a filter named `status`

- **supplierId**: ID  has a filter named `supplierId`

- **type**: Enum  has a filter named `type`

- **businessId**: ID  has a filter named `businessId`





## invoiceItem Data Object

### Object Overview
**Description:** Represents a single line item in an invoice, with product/service linkage, quantity, pricing, VAT, and per-line total.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessPrivate — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.








### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `description` | String | No | Optional text/override for item description (default: product/service name). |
| `invoiceId` | ID | Yes | Reference to parent invoice (ensures item belongs to this invoice). |
| `productOrServiceId` | ID | Yes | Reference to product/service used in this line item. |
| `quantity` | Double | Yes | Quantity of product/service being invoiced. |
| `total` | Double | Yes | Line total (unit price * quantity + VAT Amount); calculated. |
| `unitPrice` | Double | Yes | The (net) unit price for this item (auto-fetched from product/service at time of insert, overridable). |
| `vatAmount` | Double | Yes | Computed VAT amount for this invoice item. |
| `vatRate` | Double | Yes | VAT rate (%) applied for this item (auto-fetched from product/service, overridable if allowed). |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **invoiceId**: '00000000-0000-0000-0000-000000000000'
- **productOrServiceId**: '00000000-0000-0000-0000-000000000000'
- **quantity**: 1
- **total**: 0.0
- **unitPrice**: 0.0
- **vatAmount**: 0.0
- **vatRate**: 0
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`invoiceId` `total` `vatAmount` `businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`description` `productOrServiceId` `quantity` `unitPrice` `vatRate`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

 

 

### Elastic Search Indexing

`description` `invoiceId` `productOrServiceId` `quantity` `total` `unitPrice` `vatAmount` `vatRate` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`invoiceId` `productOrServiceId` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.





### Secondary Key Properties

`businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.


### Relation Properties

`invoiceId` `productOrServiceId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **invoiceId**: ID
Relation to `invoice`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: Yes

- **productOrServiceId**: ID
Relation to `productOrService`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: Yes




### Formula Properties

`description` `total` `unitPrice` `vatAmount` `vatRate`

Formula properties are used to define calculated fields that derive their values from other properties or external data.
These properties are automatically calculated based on the defined formula and can be used for dynamic data retrieval.

- **description**: String  
  - Formula: `!this.description &amp;&amp; this.productOrServiceId ? LIB.getProductOrServiceName(this.productOrServiceId) : this.description`
  
  - Calculate After Instance: Yes
  
  - Calculate When Input Has: [productOrServiceId]
  

- **total**: Double  
  - Formula: `this.unitPrice * this.quantity + this.vatAmount`
  
  - Calculate After Instance: No
  
  - Calculate When Input Has: [quantity, unitPrice, vatAmount]
  

- **unitPrice**: Double  
  - Formula: `this.unitPrice ?? LIB.getProductOrServicePrice(this.productOrServiceId)`
  
  - Calculate After Instance: Yes
  
  - Calculate When Input Has: [productOrServiceId]
  

- **vatAmount**: Double  
  - Formula: `LIB.calculateVatAmount(this.unitPrice, this.quantity, this.vatRate)`
  
  - Calculate After Instance: No
  
  - Calculate When Input Has: [quantity, unitPrice, vatRate]
  

- **vatRate**: Double  
  - Formula: `this.vatRate ?? LIB.getProductOrServiceVatRate(this.productOrServiceId)`
  
  - Calculate After Instance: Yes
  
  - Calculate When Input Has: [productOrServiceId]
  


### Filter Properties

`invoiceId` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **invoiceId**: ID  has a filter named `invoiceId`

- **businessId**: ID  has a filter named `businessId`







## Business Logic


invoiceManagement has got 12 Business APIs to manage its internal and crud logic. 
For the details of each business API refer to its chapter.

* [Create Invoice](/businessLogic/createinvoice)

* [Create Invoiceitem](/businessLogic/createinvoiceitem)

* [Delete Invoice](/businessLogic/deleteinvoice)

* [Delete Invoiceitem](/businessLogic/deleteinvoiceitem)

* [Get Invoice](/businessLogic/getinvoice)

* [Get Invoiceitem](/businessLogic/getinvoiceitem)

* [List Invoiceitems](/businessLogic/listinvoiceitems)

* [List Invoices](/businessLogic/listinvoices)

* [Update Invoice](/businessLogic/updateinvoice)

* [Update Invoiceitem](/businessLogic/updateinvoiceitem)

* [_fetch Listinvoice](/businessLogic/_fetchlistinvoice)

* [_fetch Listinvoiceitem](/businessLogic/_fetchlistinvoiceitem)



## Edge Controllers



### m2mCreateInvoice

**Configuration:**
- **Function Name**: `m2mCreateInvoice`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoice/create`
- **Method**: 

---

### m2mBulkCreateInvoice

**Configuration:**
- **Function Name**: `m2mBulkCreateInvoice`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoice/bulk-create`
- **Method**: 

---

### m2mUpdateInvoiceById

**Configuration:**
- **Function Name**: `m2mUpdateInvoiceById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoice/update/:id`
- **Method**: 

---

### m2mDeleteInvoiceById

**Configuration:**
- **Function Name**: `m2mDeleteInvoiceById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoice/delete/:id`
- **Method**: 

---

### m2mUpdateInvoiceByQuery

**Configuration:**
- **Function Name**: `m2mUpdateInvoiceByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoice/update-by-query`
- **Method**: 

---

### m2mDeleteInvoiceByQuery

**Configuration:**
- **Function Name**: `m2mDeleteInvoiceByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoice/delete-by-query`
- **Method**: 

---

### m2mUpdateInvoiceByIdList

**Configuration:**
- **Function Name**: `m2mUpdateInvoiceByIdList`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoice/update-by-id-list`
- **Method**: 

---

### m2mCreateInvoiceItem

**Configuration:**
- **Function Name**: `m2mCreateInvoiceItem`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoiceitem/create`
- **Method**: 

---

### m2mBulkCreateInvoiceItem

**Configuration:**
- **Function Name**: `m2mBulkCreateInvoiceItem`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoiceitem/bulk-create`
- **Method**: 

---

### m2mUpdateInvoiceItemById

**Configuration:**
- **Function Name**: `m2mUpdateInvoiceItemById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoiceitem/update/:id`
- **Method**: 

---

### m2mDeleteInvoiceItemById

**Configuration:**
- **Function Name**: `m2mDeleteInvoiceItemById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoiceitem/delete/:id`
- **Method**: 

---

### m2mUpdateInvoiceItemByQuery

**Configuration:**
- **Function Name**: `m2mUpdateInvoiceItemByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoiceitem/update-by-query`
- **Method**: 

---

### m2mDeleteInvoiceItemByQuery

**Configuration:**
- **Function Name**: `m2mDeleteInvoiceItemByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoiceitem/delete-by-query`
- **Method**: 

---

### m2mUpdateInvoiceItemByIdList

**Configuration:**
- **Function Name**: `m2mUpdateInvoiceItemByIdList`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/invoiceitem/update-by-id-list`
- **Method**: 

---



---

## Service Library


### Functions


#### calculateVatAmount.js
```js
module.exports = function(unitPrice, quantity, vatRate) {
  if (typeof unitPrice !== 'number' || typeof quantity !== 'number' || typeof vatRate !== 'number') return 0;
  return +(unitPrice * quantity * vatRate / 100).toFixed(2);
};
```

#### calculateInvoiceTotal.js
```js
const { getInvoiceItemListByQuery } = require("dbLayer");
module.exports = async function(context) {
  if (!context || !context.id) return 0;
  const items = await getInvoiceItemListByQuery({ invoiceId: context.id });
  if (!items || !Array.isArray(items)) return 0;
  return +items.reduce((sum, item) => sum + (+item.total || 0), 0).toFixed(2);
};
```

#### validateInvoiceTypeAndPartner.js
```js
module.exports = function(type, customerId, supplierId) {
  if (type === "sales" && !customerId) throw new Error("Sales invoice must have customerId");
  if (type === "purchase" && !supplierId) throw new Error("Purchase invoice must have supplierId");
  return true;
};
```

#### getProductOrServiceName.js
```js
const { fetchRemoteObjectByMQuery } = require("serviceCommon");
module.exports = async function(productOrServiceId) {
  if (!productOrServiceId) return "";
  const obj = await fetchRemoteObjectByMQuery("ProductOrService", { id: productOrServiceId });
  return obj?.name || "";
};
```

#### getProductOrServicePrice.js
```js
const { fetchRemoteObjectByMQuery } = require("serviceCommon");
module.exports = async function(productOrServiceId) {
  if (!productOrServiceId) return 0;
  const obj = await fetchRemoteObjectByMQuery("ProductOrService", { id: productOrServiceId });
  return typeof obj?.price === "number" ? obj.price : 0;
};
```

#### getProductOrServiceVatRate.js
```js
const { fetchRemoteObjectByMQuery } = require("serviceCommon");
module.exports = async function(productOrServiceId) {
  if (!productOrServiceId) return 0;
  const obj = await fetchRemoteObjectByMQuery("ProductOrService", { id: productOrServiceId });
  return typeof obj?.vatRate === "number" ? obj.vatRate : 0;
};
```



### Hook Functions

No hook functions defined.


### Edge Functions


#### m2mCreateInvoice.js
```js
module.exports = async (request) => {
        const { createInvoice } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const data = request.body?.data || request.data || request;
        const result = await createInvoice(data, context);
        return { status: 200, content: result };
      }
```

#### m2mBulkCreateInvoice.js
```js
module.exports = async (request) => {
        const { createBulkInvoice } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataList = request.body?.dataList || request.dataList || (Array.isArray(request.body) ? request.body : [request.body]);
        if (!Array.isArray(dataList) || dataList.length === 0) {
          return { status: 400, message: "dataList must be a non-empty array" };
        }
        const result = await createBulkInvoice(dataList, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateInvoiceById.js
```js
module.exports = async (request) => {
        const { updateInvoiceById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.id) delete dataClause.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await updateInvoiceById(id, dataClause, context);
        return { status: 200, content: result };
      }
```

#### m2mDeleteInvoiceById.js
```js
module.exports = async (request) => {
        const { deleteInvoiceById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await deleteInvoiceById(id, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateInvoiceByQuery.js
```js
module.exports = async (request) => {
        const { updateInvoiceByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await updateInvoiceByQuery(dataClause, query, context);
        return { status: 200, content: result };
      }
```

#### m2mDeleteInvoiceByQuery.js
```js
module.exports = async (request) => {
        const { deleteInvoiceByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await deleteInvoiceByQuery(query, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateInvoiceByIdList.js
```js
module.exports = async (request) => {
        const { updateInvoiceByIdList } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const idList = request.body?.idList || request.idList || [];
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.idList) delete dataClause.idList;
        if (!Array.isArray(idList) || idList.length === 0) {
          return { status: 400, message: "idList must be a non-empty array" };
        }
        const result = await updateInvoiceByIdList(idList, dataClause, context);
        return { status: 200, content: result };
      }
```

#### m2mCreateInvoiceItem.js
```js
module.exports = async (request) => {
        const { createInvoiceItem } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const data = request.body?.data || request.data || request;
        const result = await createInvoiceItem(data, context);
        return { status: 200, content: result };
      }
```

#### m2mBulkCreateInvoiceItem.js
```js
module.exports = async (request) => {
        const { createBulkInvoiceItem } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataList = request.body?.dataList || request.dataList || (Array.isArray(request.body) ? request.body : [request.body]);
        if (!Array.isArray(dataList) || dataList.length === 0) {
          return { status: 400, message: "dataList must be a non-empty array" };
        }
        const result = await createBulkInvoiceItem(dataList, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateInvoiceItemById.js
```js
module.exports = async (request) => {
        const { updateInvoiceItemById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.id) delete dataClause.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await updateInvoiceItemById(id, dataClause, context);
        return { status: 200, content: result };
      }
```

#### m2mDeleteInvoiceItemById.js
```js
module.exports = async (request) => {
        const { deleteInvoiceItemById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await deleteInvoiceItemById(id, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateInvoiceItemByQuery.js
```js
module.exports = async (request) => {
        const { updateInvoiceItemByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await updateInvoiceItemByQuery(dataClause, query, context);
        return { status: 200, content: result };
      }
```

#### m2mDeleteInvoiceItemByQuery.js
```js
module.exports = async (request) => {
        const { deleteInvoiceItemByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await deleteInvoiceItemByQuery(query, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateInvoiceItemByIdList.js
```js
module.exports = async (request) => {
        const { updateInvoiceItemByIdList } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const idList = request.body?.idList || request.idList || [];
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.idList) delete dataClause.idList;
        if (!Array.isArray(idList) || idList.length === 0) {
          return { status: 400, message: "idList must be a non-empty array" };
        }
        const result = await updateInvoiceItemByIdList(idList, dataClause, context);
        return { status: 200, content: result };
      }
```



### Templates

No templates defined.


### Assets

No assets defined.


### Public Assets

No public assets defined.



---




### Event Emission


---

## Integration Patterns

## Deployment Considerations

### Environment Configuration
- **HTTP Port**: `3001`
- **Database Type**: MongoDB
- **Global Soft Delete**: Enabled




## Implementation Guidelines

### Development Workflow
1. **Data Model Implementation**: Generate database schema from data object definitions
2. **CRUD Route Generation**: Implement auto-generated routes with custom logic
3. **Custom Logic Integration**: Implement hook functions and edge functions
4. **Authentication Integration**: Configure with project-level authentication
5. **Testing**: Unit and integration testing for all components

### Code Generation Expectations
- **Database Schema**: Auto-generated from data objects and relationships
- **API Routes**: REST endpoints with customizable behavior
- **Validation Logic**: Input validation from property definitions
- **Access Control**: Authentication and authorization middleware

### Custom Code Integration Points
- **Hook Functions**: Lifecycle-specific custom logic
- **Edge Functions**: Full request/response control
- **Library Functions**: Reusable business logic
- **Templates**: Dynamic content rendering

### Testing Strategy

#### Unit Testing
- Test all custom library functions
- Test validation logic and business rules
- Test hook function implementations

#### Integration Testing
- Test API endpoints with authentication scenarios
- Test database operations and transactions
- Test external integrations
- Test event emission and Kafka integration

#### Performance Testing
- Load test high-traffic endpoints
- Test caching effectiveness
- Monitor database query performance
- Test scalability under load

---

## Appendices

### Data Type Reference
| Type | Description | Storage |
|------|-------------|---------|
| ID | Unique identifier | UUID (SQL) / ObjectID (NoSQL) |
| String | Short text (≤255 chars) | VARCHAR |
| Text | Long-form text | TEXT |
| Integer | 32-bit whole numbers | INT |
| Boolean | True/false values | BOOLEAN |
| Double | 64-bit floating point | DOUBLE |
| Float | 32-bit floating point | FLOAT |
| Short | 16-bit integers | SMALLINT |
| Object | JSON object | JSONB (PostgreSQL) / Object (MongoDB) |
| Date | ISO 8601 timestamp | TIMESTAMP |
| Enum | Fixed numeric values | SMALLINT with lookup |

### Enum Value Mappings

#### Request Locations
- `0`: Bearer token in Authorization header
- `1`: Cookie value
- `2`: Custom HTTP header
- `3`: Query parameter
- `4`: Request body property
- `5`: URL path parameter
- `6`: Session data
- `7`: Root request object

#### HTTP Methods
- `0`: GET
- `1`: POST
- `2`: PUT
- `3`: PATCH
- `4`: DELETE


### Edge Function Signature
```javascript
async function edgeFunction(request) {
  // Custom request processing
  // Return response object or throw error
  return {
    data: {},
    status: 200,
    message: "Success"
  };
}
```

---

*This document was generated from the service architecture definition and should be kept in sync with implementation changes.*

---

<a id="invoicemanagement-service-rest-api-guide"></a>

## REST API GUIDE 

 

# REST API GUIDE 
## fintrack-invoicemanagement-service
**Version:** `1.0.1`

Handles creation and modification of all sales (outgoing) and purchase (incoming) invoices for FinTrack SMBs. Supports multi-item entry per invoice, VAT at item level, detailed filtering, and status calculation based on payments and due dates. Strictly scoped to a single business context.

## Architectural Design Credit and Contact Information

The architectural design of this microservice is credited to . 
For inquiries, feedback, or further information regarding the architecture, please direct your communication to:

Email: 

We encourage open communication and welcome any questions or discussions related to the architectural aspects of this microservice.

## Documentation Scope

Welcome to the official documentation for the InvoiceManagement Service's REST API. This document is designed to provide a comprehensive guide to interfacing with our InvoiceManagement Service exclusively through RESTful API endpoints.

**Intended Audience**

This documentation is intended for developers and integrators who are looking to interact with the InvoiceManagement Service via HTTP requests for purposes such as creating, updating, deleting and querying InvoiceManagement objects.

**Overview**

Within these pages, you will find detailed information on how to effectively utilize the REST API, including authentication methods, request and response formats, endpoint descriptions, and examples of common use cases.

Beyond REST
It's important to note that the InvoiceManagement Service also supports alternative methods of interaction, such as gRPC and messaging via a Message Broker. These communication methods are beyond the scope of this document. For information regarding these protocols, please refer to their respective documentation.

## Authentication And Authorization

To ensure secure access to the InvoiceManagement service's protected endpoints, a project-wide access token is required. This token serves as the primary method for authenticating requests to our service. However, it's important to note that access control varies across different routes:

**Protected API**: 
Certain API (routes) require specific authorization levels. Access to these routes is contingent upon the possession of a valid access token that meets the route-specific authorization criteria. Unauthorized requests to these routes will be rejected.

**Public API **: 
The service also includes public API (routes) that are accessible without authentication. These public endpoints are designed for open access and do not require an access token.

### Token Locations
When including your access token in a request, ensure it is placed in one of the following specified locations. The service will sequentially search these locations for the token, utilizing the first one it encounters.

| Location               | Token Name / Param Name      |
| ---------------------- | ---------------------------- |
| Query                  | access_token                 |
| Authorization Header   | Bearer                       |
| Header                 | fintrack-access-token|
| Header                 | fintrack-access-token-{businessCodename}|
| Cookie                 | fintrack-access-token-{businessCodename}|


Please ensure the token is correctly placed in one of these locations, using the appropriate label as indicated. The service prioritizes these locations in the order listed, processing the first token it successfully identifies.


## Api Definitions
This section outlines the API endpoints available within the InvoiceManagement service. Each endpoint can receive parameters through various methods, meticulously described in the following definitions. It's important to understand the flexibility in how parameters can be included in requests to effectively interact with the InvoiceManagement service.

This service is configured to listen for HTTP requests on port `3001`, 
serving both the main API interface and default administrative endpoints.

The following routes are available by default:

* **API Test Interface (API Face):** `/`
* **Swagger Documentation:** `/swagger`
* **Postman Collection Download:** `/getPostmanCollection`
* **Health Checks:** `/health` and `/admin/health`
* **Current Session Info:** `/currentuser`
* **Favicon:** `/favicon.ico`

This service is accessible via the following environment-specific URLs:

* **Preview:** `https://fintrack.prw.mindbricks.com/invoicemanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/invoicemanagement-api`
* **Production:** `https://fintrack.mindbricks.co/invoicemanagement-api`

**Parameter Inclusion Methods:**
Parameters can be incorporated into API requests in several ways, each with its designated location. Understanding these methods is crucial for correctly constructing your requests:

**Query Parameters:** Included directly in the URL's query string.

**Path Parameters:** Embedded within the URL's path.

**Body Parameters:** Sent within the JSON body of the request.

**Session Parameters:** Automatically read from the session object. This method is used for parameters that are intrinsic to the user's session, such as userId. When using an API that involves session parameters, you can omit these from your request. The service will automatically bind them to the API layer, provided that a session is associated with your request.

**Note on Session Parameters:**
Session parameters represent a unique method of parameter inclusion, relying on the context of the user's session. A common example of a session parameter is userId, which the service automatically associates with your request when a session exists. This feature ensures seamless integration of user-specific data without manual input for each request.

By adhering to the specified parameter inclusion methods, you can effectively utilize the InvoiceManagement service's API endpoints. For detailed information on each endpoint, including required parameters and their accepted locations, refer to the individual API definitions below.

### Common Parameters

The `InvoiceManagement` service's business API support several common parameters designed to modify and enhance the behavior of API requests. These parameters are not individually listed in the API route definitions to avoid repetition. Instead, refer to this section to understand how to leverage these common behaviors across different routes. Note that all common parameters should be included in the query part of the URL.

### Supported Common Parameters:

- **getJoins (BOOLEAN)**: Controls whether to retrieve associated objects along with the main object. By default, `getJoins` is assumed to be `true`. Set it to `false` if you prefer to receive only the main fields of an object, excluding its associations.

- **excludeCQRS (BOOLEAN)**: Applicable only when `getJoins` is `true`. By default, `excludeCQRS` is set to `false`. Enabling this parameter (`true`) omits non-local associations, which are typically more resource-intensive as they require querying external services like ElasticSearch for additional information. Use this to optimize response times and resource usage.

- **requestId (String)**: Identifies a request to enable tracking through the service's log chain. A random hex string of 32 characters is assigned by default. If you wish to use a custom `requestId`, simply include it in your query parameters.

- **caching (BOOLEAN)**: Determines the use of caching for query API. By default, caching is enabled (`true`). To ensure the freshest data directly from the database, set this parameter to `false`, bypassing the cache.

- **cacheTTL (Integer)**: Specifies the Time-To-Live (TTL) for query caching, in seconds. This is particularly useful for adjusting the default caching duration (5 minutes) for `get list` queries. Setting a custom `cacheTTL` allows you to fine-tune the cache lifespan to meet your needs.

- **pageNumber (Integer)**: For paginated `get list` API's, this parameter selects which page of results to retrieve. The default is `1`, indicating the first page. To disable pagination and retrieve all results, set `pageNumber` to `0`.

- **pageRowCount (Integer)**: In conjunction with paginated API's, this parameter defines the number of records per page. The default value is `25`. Adjusting `pageRowCount` allows you to control the volume of data returned in a single request.

By utilizing these common parameters, you can tailor the behavior of API requests to suit your specific requirements, ensuring optimal performance and usability of the `InvoiceManagement` service.


  ### Multi Tenant Architecture

  The `InvoiceManagement` service operates within a multi tenant architecture.
  The service is designed to support multiple tenants, each with its distinct data and configuration. This architecture ensures that data is securely isolated between tenants, preventing unauthorized access and maintaining data integrity.
  The service tenant is called `business` and identified as `businessId`.
  Other than platform users like superAdmin, saasAdmin and saasUser that belong to the root tenant, the tenant creators(owners) and users will all be associated with an business tenant.
  When users login their scope will be isolated only to include one tenant data they below. So user may acces only this logined tennat through out the session. After loging in to e specific tenant, users should include the tenant id in their request to access the tenant data. In each request they may access different tenant data if they belong them. 


  #### Key Points:
  
  - **Tenant-Specific Requests**: It is imperative that each request specifies the tenant it pertains to. This is crucial because most API's are designed to interact exclusively with objects that are part of the specified tenant sandbox.
  - **User Distinction**: The requesting user must have a registration for that tenant. The service searches for a `business` specific token (cookie or bearer) using the provided `business`Id in the request header. Note that to be able to login and use multiple tenant's sites a user must register for them all.
  - **Request Header Parameter**: When making a request, include the desired `businessId` in the request header using the parameter name ``. This signals to the service which domain context to apply for the request processing. Alternatively, you can include the tenant id in the query parameters with the name `businessId`.
  - **Root Tenant**: As all multi tenant architectures this application also has a default root tenant which created automatically. If there is no tenant mark for the request, the request are assumed as to the root tenant. Root tenant is also the hub for registering tenant creating and their owner users. When users register themselves in the root tenant, an (business) will alos be created with the given data in the request body and the user will be asssociated with this new tenant record as the `tenantAdmin`. 
  - **Superadmin account**: A super admin account is created with the given credentials in the design so that there is an absolute user which has all rights in the root tenant and other tenants. This account is used to create and manage all other tenants in the system. 
    - **Tenant Registration**: The `InvoiceManagement` service allows for the creation of new tenants only through admin account of the root tenant. So if a new business record is needed, the superadmin or admin roles of the root should create then new tenant and assign any user as the owner of it.
  
  #### Implementation:

  When the user logins there may be few ways for Mindbricks to recognize and set the tenant id in the session.
  1. Mindbricks will check the url of the login request if it matches tenant url.
  2. Mindbricks will check the `` has the tenant id.
  3. Mindbricks will check if the user is associated with a `business` in the data model.
  After you login a tenant successfully, ensure that your requests accurately target objects that fall within the tenant scope set during the login session.
  Ensure your requests are correctly formatted to include the domain sandbox information in the header. This enables the `InvoiceManagement` service to accurately identify the domain context, facilitating proper access control and data management based on the user's permissions and the specified domain.  
  ```js
  axios({
    method: 'GET',
    headers: {
      '': 'Your-businessId-here'
    }
    url: "/someroutepath",
    data: {
      "someData":"someData"
    },
    params: {
      "aParam":"aParam"
    }
  });
  ````     
  By adhering to this domain sandbox model, the `InvoiceManagement` service maintains a secure and organized structure for handling requests across different domains, ensuring that operations are performed within the correct contextual boundaries.

### Error Response

If a request encounters an issue, whether due to a logical fault or a technical problem, the service responds with a standardized JSON error structure. The HTTP status code within this response indicates the nature of the error, utilizing commonly recognized codes for clarity:

- **400 Bad Request**: The request was improperly formatted or contained invalid parameters, preventing the server from processing it.
- **401 Unauthorized**: The request lacked valid authentication credentials or the credentials provided do not grant access to the requested resource.
- **404 Not Found**: The requested resource was not found on the server.
- **500 Internal Server Error**: The server encountered an unexpected condition that prevented it from fulfilling the request.

Each error response is structured to provide meaningful insight into the problem, assisting in diagnosing and resolving issues efficiently.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```` 

### Object Structure of a Successfull Response

When the `InvoiceManagement` service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope not only contains the data but also includes essential metadata, such as configuration details and pagination information, to enrich the response and provide context to the client.

**Key Characteristics of the Response Envelope:**

- **Data Presentation**: Depending on the nature of the request, the service returns either a single data object or an array of objects encapsulated within the JSON envelope.
  - **Creation and Update API**: These API routes return the unmodified (pure) form of the data object(s), without any associations to other data objects.
  - **Delete API**: Even though the data is removed from the database, the last known state of the data object(s) is returned in its pure form.
  - **Get Requests**: A single data object is returned in JSON format.
  - **Get List Requests**: An array of data objects is provided, reflecting a collection of resources.

- **Data Structure and Joins**: The complexity of the data structure in the response can vary based on the API's architectural design and the join options specified in the request. The architecture might inherently limit join operations, or they might be dynamically controlled through query parameters.
  - **Pure Data Forms**: In some cases, the response mirrors the exact structure found in the primary data table, without extensions.
  - **Extended Data Forms**: Alternatively, responses might include data extended through joins with tables within the same service or aggregated from external sources, such as ElasticSearch indices related to other services.
  - **Join Varieties**: The extensions might involve one-to-one joins, resulting in single object associations, or one-to-many joins, leading to an array of objects. In certain instances, the data might even feature nested inclusions from other data objects.

**Design Considerations**: The structure of a API's response data is meticulously crafted during the service's architectural planning. This design ensures that responses adequately reflect the intended data relationships and service logic, providing clients with rich and meaningful information.

**Brief Data**: Certain API's return a condensed version of the object data, intentionally selecting only specific fields deemed useful for that request. In such instances, the API documentation will detail the properties included in the response, guiding developers on what to expect.

### API Response Structure

The API utilizes a standardized JSON envelope to encapsulate responses. This envelope is designed to consistently deliver both the requested data and essential metadata, ensuring that clients can efficiently interpret and utilize the response.

**HTTP Status Codes:**

- **200 OK**: This status code is returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request has been processed successfully.
- **201 Created**: This status code is specific to CREATE operations, signifying that the requested resource has been successfully created.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling the successful execution of the request. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
````

- **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation performed.

**Handling Errors:**

For details on handling error scenarios and understanding the structure of error responses, please refer to the "Error Response" section provided earlier in this documentation. It outlines how error conditions are communicated, including the use of HTTP status codes and standardized JSON structures for error messages.

## Resources 
InvoiceManagement service provides the following resources which are stored in its own database as a data object. Note that a resource for an api access is a data object for the service.

### Invoice resource

*Resource Definition* : Represents a single sales or purchase invoice document for a business. Contains summary information, partner (customer/supplier), and status derived from payments and dates.
*Invoice Resource Properties* 
| Name | Type | Required | Default | Definition | 
| ---- | ---- | -------- | ------- | ---------- |
| **currency** | String |  |  | *Currency code for all values in invoice and its items (e.g., &#39;USD&#39;).* |
| **customerId** | ID |  |  | *Referenced customer (for sales invoice; null for purchase invoice).* |
| **dueDate** | Date |  |  | *Date by which payment for this invoice is due.* |
| **invoiceNumber** | String |  |  | *A unique identifier (number/code) for this invoice within a business.* |
| **issueDate** | Date |  |  | *Date this invoice was issued.* |
| **notes** | Text |  |  | *Internal notes about the invoice, never publicly exposed.* |
| **status** | Enum |  |  | *Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate.* |
| **supplierId** | ID |  |  | *Referenced supplier (for purchase invoice; null for sales invoice).* |
| **totalAmount** | Double |  |  | *Grand total for invoice (sum of line item totals, including VAT). Calculated; always up-to-date.* |
| **type** | Enum |  |  | *Invoice nature; &#39;sales&#39;=outgoing, &#39;purchase&#39;=incoming.* |
| **businessId** | ID |  |  | *An ID value to represent the tenant id of the business* |
#### Enum Properties
Enum properties are represented as strings in the database. The values are mapped to their corresponding names in the application layer.
##### status Enum Property
*Property Definition* : Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate.*Enum Options*
| Name | Value | Index | 
| ---- | ----- | ----- |
| **unpaid** | `"unpaid""` | 0 | 
| **partial** | `"partial""` | 1 | 
| **paid** | `"paid""` | 2 | 
| **overdue** | `"overdue""` | 3 | 
##### type Enum Property
*Property Definition* : Invoice nature; &#39;sales&#39;=outgoing, &#39;purchase&#39;=incoming.*Enum Options*
| Name | Value | Index | 
| ---- | ----- | ----- |
| **sales** | `"sales""` | 0 | 
| **purchase** | `"purchase""` | 1 | 
### InvoiceItem resource

*Resource Definition* : Represents a single line item in an invoice, with product/service linkage, quantity, pricing, VAT, and per-line total.
*InvoiceItem Resource Properties* 
| Name | Type | Required | Default | Definition | 
| ---- | ---- | -------- | ------- | ---------- |
| **description** | String |  |  | *Optional text/override for item description (default: product/service name).* |
| **invoiceId** | ID |  |  | *Reference to parent invoice (ensures item belongs to this invoice).* |
| **productOrServiceId** | ID |  |  | *Reference to product/service used in this line item.* |
| **quantity** | Double |  |  | *Quantity of product/service being invoiced.* |
| **total** | Double |  |  | *Line total (unit price * quantity + VAT Amount); calculated.* |
| **unitPrice** | Double |  |  | *The (net) unit price for this item (auto-fetched from product/service at time of insert, overridable).* |
| **vatAmount** | Double |  |  | *Computed VAT amount for this invoice item.* |
| **vatRate** | Double |  |  | *VAT rate (%) applied for this item (auto-fetched from product/service, overridable if allowed).* |
| **businessId** | ID |  |  | *An ID value to represent the tenant id of the business* |
## Business Api
### `Create Invoice` API
Create a new invoice (sales or purchase), require proper partner, auto-status, and initialize with/without items. Owner or Accountant only.

**API Frontend Description By The Backend Architect**

UI must prompt for invoice type first; if type=sales require customer; if type=purchase require supplier. Line items can be added inline or after main invoice save. Save triggers recalculation of total and default status to unpaid. Allow adding notes.

**Rest Route**

The `createInvoice` API REST controller can be triggered via the following route:

`/v1/invoices`


**Rest Request Parameters**


The `createInvoice` api has got 9 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| currency  | String  | true | request.body?.["currency"] |
| customerId  | ID  | false | request.body?.["customerId"] |
| dueDate  | Date  | true | request.body?.["dueDate"] |
| invoiceNumber  | String  | true | request.body?.["invoiceNumber"] |
| issueDate  | Date  | true | request.body?.["issueDate"] |
| notes  | Text  | false | request.body?.["notes"] |
| status  | Enum  | true | request.body?.["status"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |
| type  | Enum  | true | request.body?.["type"] |
**currency** : Currency code for all values in invoice and its items (e.g., 'USD').
**customerId** : Referenced customer (for sales invoice; null for purchase invoice).
**dueDate** : Date by which payment for this invoice is due.
**invoiceNumber** : A unique identifier (number/code) for this invoice within a business.
**issueDate** : Date this invoice was issued.
**notes** : Internal notes about the invoice, never publicly exposed.
**status** : Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate.
**supplierId** : Referenced supplier (for purchase invoice; null for sales invoice).
**type** : Invoice nature; 'sales'=outgoing, 'purchase'=incoming.


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/invoices**
```js
  axios({
    method: 'POST',
    url: '/v1/invoices',
    data: {
            currency:"String",  
            customerId:"ID",  
            dueDate:"Date",  
            invoiceNumber:"String",  
            issueDate:"Date",  
            notes:"Text",  
            status:"Enum",  
            supplierId:"ID",  
            type:"Enum",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Create Invoiceitem` API
Create a new line item for an invoice. Only permitted for Owner/Accountant or if user has edit rights for invoice.

**API Frontend Description By The Backend Architect**

Item is created within context of an invoice. Product/service lookup required. Quantity and price editable if business logic allows. VAT is defaulted/calculated and presented. Totals computed automatically.

**Rest Route**

The `createInvoiceItem` API REST controller can be triggered via the following route:

`/v1/invoiceitems`


**Rest Request Parameters**


The `createInvoiceItem` api has got 3 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.body?.["invoiceId"] |
| productOrServiceId  | ID  | true | request.body?.["productOrServiceId"] |
| quantity  | Double  | true | request.body?.["quantity"] |
**invoiceId** : Reference to parent invoice (ensures item belongs to this invoice).
**productOrServiceId** : Reference to product/service used in this line item.
**quantity** : Quantity of product/service being invoiced.


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/invoiceitems**
```js
  axios({
    method: 'POST',
    url: '/v1/invoiceitems',
    data: {
            invoiceId:"ID",  
            productOrServiceId:"ID",  
            quantity:"Double",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Invoice` API
Soft delete/deactivate an invoice (remains for audit/history, removes from normal use). Owner/Accountant only.

**API Frontend Description By The Backend Architect**

Allow delete/deactivation from invoice list/details. Deletion is always soft (record preserved).

**Rest Route**

The `deleteInvoice` API REST controller can be triggered via the following route:

`/v1/invoices/:invoiceId`


**Rest Request Parameters**


The `deleteInvoice` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.params?.["invoiceId"] |
**invoiceId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/invoices/:invoiceId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/invoices/${invoiceId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Invoiceitem` API
Remove an invoice line item. Soft delete by default. Only Owner/Accountant allowed; item remains for reporting/audit.

**API Frontend Description By The Backend Architect**

Delete removes item from invoice's current views but keeps for reporting/history. Adjust totals on invoice accordingly.

**Rest Route**

The `deleteInvoiceItem` API REST controller can be triggered via the following route:

`/v1/invoiceitems/:invoiceItemId`


**Rest Request Parameters**


The `deleteInvoiceItem` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceItemId  | ID  | true | request.params?.["invoiceItemId"] |
**invoiceItemId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/invoiceitems/:invoiceItemId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/invoiceitems/${invoiceItemId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Invoice` API
Fetch a detailed invoice by ID, including all items and partner details. All business users have read access within business context.

**API Frontend Description By The Backend Architect**

Display invoice header, itemized line items, customer (sales) or supplier (purchase) info, summary totals and auto-calculated status. Status should match payments up to the time of request.

**Rest Route**

The `getInvoice` API REST controller can be triggered via the following route:

`/v1/invoices/:invoiceId`


**Rest Request Parameters**


The `getInvoice` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.params?.["invoiceId"] |
**invoiceId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/invoices/:invoiceId**
```js
  axios({
    method: 'GET',
    url: `/v1/invoices/${invoiceId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID",
		"items": [
			{
				"description": "String",
				"quantity": "Double",
				"total": "Double",
				"unitPrice": "Double",
				"vatAmount": "Double",
				"vatRate": "Double"
			},
			{},
			{}
		],
		"customer": {
			"contactEmail": "String",
			"contactName": "String",
			"name": "String"
		},
		"supplier": {
			"contactEmail": "String",
			"contactName": "String",
			"name": "String"
		}
	}
}
```
### `Get Invoiceitem` API
Get details for a single invoice item (line details with product/service info). All business users have access within scope (for invoice display and workflows).

**API Frontend Description By The Backend Architect**

Show item description, product/service name, quantity, unit price, VAT, and subtotal/total (with calculations). Allow link to product/service catalog for further details.

**Rest Route**

The `getInvoiceItem` API REST controller can be triggered via the following route:

`/v1/invoiceitems/:invoiceItemId`


**Rest Request Parameters**


The `getInvoiceItem` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceItemId  | ID  | true | request.params?.["invoiceItemId"] |
**invoiceItemId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/invoiceitems/:invoiceItemId**
```js
  axios({
    method: 'GET',
    url: `/v1/invoiceitems/${invoiceItemId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID",
		"productOrService": {
			"currency": "String",
			"name": "String",
			"price": "Double",
			"sku": "String",
			"type": "Enum",
			"type_idx": "Integer",
			"vatRate": "Double"
		}
	}
}
```
### `List Invoiceitems` API
List all line items for given invoice or with filter. Used for invoice display, checks, audits. All business roles permitted to read within tenant scope.

**API Frontend Description By The Backend Architect**

Present all invoice items for invoice details screen, permit search by invoice, product/service or description; paginate for large sets. Enable inline item addition (if permitted).

**Rest Route**

The `listInvoiceItems` API REST controller can be triggered via the following route:

`/v1/invoiceitems`


**Rest Request Parameters**


**Filter Parameters**

The `listInvoiceItems` api supports 1 optional filter parameter for filtering list results:

**invoiceId** (`ID`): Reference to parent invoice (ensures item belongs to this invoice).

- Single: `?invoiceId=<value>`
- Multiple: `?invoiceId=<value1>&invoiceId=<value2>`
- Null: `?invoiceId=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/invoiceitems**
```js
  axios({
    method: 'GET',
    url: '/v1/invoiceitems',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // invoiceId: '<value>' // Filter by invoiceId
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItems",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoiceItems": [
		{
			"id": "ID",
			"description": "String",
			"invoiceId": "ID",
			"productOrServiceId": "ID",
			"quantity": "Double",
			"total": "Double",
			"unitPrice": "Double",
			"vatAmount": "Double",
			"vatRate": "Double",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"productOrService": [
				{
					"currency": "String",
					"name": "String",
					"price": "Double",
					"sku": "String",
					"type": "Enum",
					"type_idx": "Integer",
					"vatRate": "Double"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `List Invoices` API
List/search invoices for the current business, with filtering by type, date, partner, and status. All business users may view within context.

**API Frontend Description By The Backend Architect**

Show invoice list with filtering/search by type, partner, status, date range (on issueDate/dueDate). Display summary fields and enable quick navigation to invoice details or edit (if permitted).

**Rest Route**

The `listInvoices` API REST controller can be triggered via the following route:

`/v1/invoices`


**Rest Request Parameters**


**Filter Parameters**

The `listInvoices` api supports 7 optional filter parameters for filtering list results:

**customerId** (`ID`): Referenced customer (for sales invoice; null for purchase invoice).

- Single: `?customerId=<value>`
- Multiple: `?customerId=<value1>&customerId=<value2>`
- Null: `?customerId=null`


**dueDate** (`Date`): Date by which payment for this invoice is due.

- Single date: `?dueDate=2024-01-15`
- Multiple dates: `?dueDate=2024-01-15&dueDate=2024-01-20`
- Special: `$today`, `$ltoday`, `$week`, `$lweek`, `$month`, `$leq-<date>`, `$lin-<date>`
- Null: `?dueDate=null`


**invoiceNumber** (`String`): A unique identifier (number/code) for this invoice within a business.

- Single (partial match, case-insensitive): `?invoiceNumber=<value>`
- Multiple: `?invoiceNumber=<value1>&invoiceNumber=<value2>`
- Null: `?invoiceNumber=null`


**issueDate** (`Date`): Date this invoice was issued.

- Single date: `?issueDate=2024-01-15`
- Multiple dates: `?issueDate=2024-01-15&issueDate=2024-01-20`
- Special: `$today`, `$ltoday`, `$week`, `$lweek`, `$month`, `$leq-<date>`, `$lin-<date>`
- Null: `?issueDate=null`


**status** (`Enum`): Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate.

- Single: `?status=<value>` (case-insensitive)
- Multiple: `?status=<value1>&status=<value2>`
- Null: `?status=null`


**supplierId** (`ID`): Referenced supplier (for purchase invoice; null for sales invoice).

- Single: `?supplierId=<value>`
- Multiple: `?supplierId=<value1>&supplierId=<value2>`
- Null: `?supplierId=null`


**type** (`Enum`): Invoice nature; 'sales'=outgoing, 'purchase'=incoming.

- Single: `?type=<value>` (case-insensitive)
- Multiple: `?type=<value1>&type=<value2>`
- Null: `?type=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/invoices**
```js
  axios({
    method: 'GET',
    url: '/v1/invoices',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // customerId: '<value>' // Filter by customerId
        // dueDate: '<value>' // Filter by dueDate
        // invoiceNumber: '<value>' // Filter by invoiceNumber
        // issueDate: '<value>' // Filter by issueDate
        // status: '<value>' // Filter by status
        // supplierId: '<value>' // Filter by supplierId
        // type: '<value>' // Filter by type
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoices",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoices": [
		{
			"id": "ID",
			"currency": "String",
			"customerId": "ID",
			"dueDate": "Date",
			"invoiceNumber": "String",
			"issueDate": "Date",
			"notes": "Text",
			"status": "Enum",
			"status_idx": "Integer",
			"supplierId": "ID",
			"totalAmount": "Double",
			"type": "Enum",
			"type_idx": "Integer",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"items": [
				{
					"description": "String",
					"quantity": "Double",
					"total": "Double",
					"unitPrice": "Double",
					"vatAmount": "Double",
					"vatRate": "Double"
				},
				{},
				{}
			],
			"customer": [
				{
					"contactEmail": "String",
					"contactName": "String",
					"name": "String"
				},
				{},
				{}
			],
			"supplier": [
				{
					"contactEmail": "String",
					"contactName": "String",
					"name": "String"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Invoice` API
Update invoice details (e.g., dates, partner, notes); recalculate totals and enforce type/partner links. Owner/Accountant only.

**API Frontend Description By The Backend Architect**

Allow editing of fields except invoice type. Changing partner: must match rules (sales: customer; purchase: supplier). Totals always refresh after updating. No direct status edit; status recalculated on payment update.

**Rest Route**

The `updateInvoice` API REST controller can be triggered via the following route:

`/v1/invoices/:invoiceId`


**Rest Request Parameters**


The `updateInvoice` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.params?.["invoiceId"] |
| currency  | String  | true | request.body?.["currency"] |
| customerId  | ID  | false | request.body?.["customerId"] |
| dueDate  | Date  | true | request.body?.["dueDate"] |
| invoiceNumber  | String  | true | request.body?.["invoiceNumber"] |
| issueDate  | Date  | true | request.body?.["issueDate"] |
| notes  | Text  | false | request.body?.["notes"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |
**invoiceId** : This id paremeter is used to select the required data object that will be updated
**currency** : Currency code for all values in invoice and its items (e.g., 'USD').
**customerId** : Referenced customer (for sales invoice; null for purchase invoice).
**dueDate** : Date by which payment for this invoice is due.
**invoiceNumber** : A unique identifier (number/code) for this invoice within a business.
**issueDate** : Date this invoice was issued.
**notes** : Internal notes about the invoice, never publicly exposed.
**supplierId** : Referenced supplier (for purchase invoice; null for sales invoice).


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/invoices/:invoiceId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/invoices/${invoiceId}`,
    data: {
            currency:"String",  
            customerId:"ID",  
            dueDate:"Date",  
            invoiceNumber:"String",  
            issueDate:"Date",  
            notes:"Text",  
            supplierId:"ID",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Update Invoiceitem` API
Update an existing invoice line item (description, quantity, unit price, VAT). Owner/Accountant only.

**API Frontend Description By The Backend Architect**

Editable fields: description, quantity, unitPrice, vatRate. Totals/VAT recalc on any change. Editing productOrServiceId updates downstream values. UI should limit changes if invoice is paid/partial/overdue.

**Rest Route**

The `updateInvoiceItem` API REST controller can be triggered via the following route:

`/v1/invoiceitems/:invoiceItemId`


**Rest Request Parameters**


The `updateInvoiceItem` api has got 3 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceItemId  | ID  | true | request.params?.["invoiceItemId"] |
| productOrServiceId  | ID  | true | request.body?.["productOrServiceId"] |
| quantity  | Double  | true | request.body?.["quantity"] |
**invoiceItemId** : This id paremeter is used to select the required data object that will be updated
**productOrServiceId** : Reference to product/service used in this line item.
**quantity** : Quantity of product/service being invoiced.


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/invoiceitems/:invoiceItemId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/invoiceitems/${invoiceItemId}`,
    data: {
            productOrServiceId:"ID",  
            quantity:"Double",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `_fetch Listinvoice` API
System API to fetch list of invoice records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListInvoice` API REST controller can be triggered via the following route:

`/v1/_fetchlistinvoice`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListInvoice` api supports 7 optional filter parameters for filtering list results:

**customerId** (`ID`): Referenced customer (for sales invoice; null for purchase invoice).

- Single: `?customerId=<value>`
- Multiple: `?customerId=<value1>&customerId=<value2>`
- Null: `?customerId=null`


**dueDate** (`Date`): Date by which payment for this invoice is due.

- Single date: `?dueDate=2024-01-15`
- Multiple dates: `?dueDate=2024-01-15&dueDate=2024-01-20`
- Special: `$today`, `$ltoday`, `$week`, `$lweek`, `$month`, `$leq-<date>`, `$lin-<date>`
- Null: `?dueDate=null`


**invoiceNumber** (`String`): A unique identifier (number/code) for this invoice within a business.

- Single (partial match, case-insensitive): `?invoiceNumber=<value>`
- Multiple: `?invoiceNumber=<value1>&invoiceNumber=<value2>`
- Null: `?invoiceNumber=null`


**issueDate** (`Date`): Date this invoice was issued.

- Single date: `?issueDate=2024-01-15`
- Multiple dates: `?issueDate=2024-01-15&issueDate=2024-01-20`
- Special: `$today`, `$ltoday`, `$week`, `$lweek`, `$month`, `$leq-<date>`, `$lin-<date>`
- Null: `?issueDate=null`


**status** (`Enum`): Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate.

- Single: `?status=<value>` (case-insensitive)
- Multiple: `?status=<value1>&status=<value2>`
- Null: `?status=null`


**supplierId** (`ID`): Referenced supplier (for purchase invoice; null for sales invoice).

- Single: `?supplierId=<value>`
- Multiple: `?supplierId=<value1>&supplierId=<value2>`
- Null: `?supplierId=null`


**type** (`Enum`): Invoice nature; 'sales'=outgoing, 'purchase'=incoming.

- Single: `?type=<value>` (case-insensitive)
- Multiple: `?type=<value1>&type=<value2>`
- Null: `?type=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistinvoice**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistinvoice',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // customerId: '<value>' // Filter by customerId
        // dueDate: '<value>' // Filter by dueDate
        // invoiceNumber: '<value>' // Filter by invoiceNumber
        // issueDate: '<value>' // Filter by issueDate
        // status: '<value>' // Filter by status
        // supplierId: '<value>' // Filter by supplierId
        // type: '<value>' // Filter by type
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoices",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoices": [
		{
			"id": "ID",
			"currency": "String",
			"customerId": "ID",
			"dueDate": "Date",
			"invoiceNumber": "String",
			"issueDate": "Date",
			"notes": "Text",
			"status": "Enum",
			"status_idx": "Integer",
			"supplierId": "ID",
			"totalAmount": "Double",
			"type": "Enum",
			"type_idx": "Integer",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"customer": [
				{
					"address": "Text",
					"contactEmail": "String",
					"contactName": "String",
					"name": "String",
					"notes": "Text",
					"phone": "String",
					"taxNumber": "String",
					"businessId": "ID"
				},
				{},
				{}
			],
			"supplier": [
				{
					"address": "Text",
					"contactEmail": "String",
					"contactName": "String",
					"name": "String",
					"notes": "Text",
					"phone": "String",
					"taxNumber": "String"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `_fetch Listinvoiceitem` API
System API to fetch list of invoiceItem records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListInvoiceItem` API REST controller can be triggered via the following route:

`/v1/_fetchlistinvoiceitem`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListInvoiceItem` api supports 1 optional filter parameter for filtering list results:

**invoiceId** (`ID`): Reference to parent invoice (ensures item belongs to this invoice).

- Single: `?invoiceId=<value>`
- Multiple: `?invoiceId=<value1>&invoiceId=<value2>`
- Null: `?invoiceId=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistinvoiceitem**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistinvoiceitem',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // invoiceId: '<value>' // Filter by invoiceId
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItems",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoiceItems": [
		{
			"id": "ID",
			"description": "String",
			"invoiceId": "ID",
			"productOrServiceId": "ID",
			"quantity": "Double",
			"total": "Double",
			"unitPrice": "Double",
			"vatAmount": "Double",
			"vatRate": "Double",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"invoice": [
				{
					"currency": "String",
					"customerId": "ID",
					"dueDate": "Date",
					"invoiceNumber": "String",
					"issueDate": "Date",
					"notes": "Text",
					"status": "Enum",
					"status_idx": "Integer",
					"supplierId": "ID",
					"totalAmount": "Double",
					"type": "Enum",
					"type_idx": "Integer"
				},
				{},
				{}
			],
			"productOrService": [
				{
					"currency": "String",
					"description": "Text",
					"name": "String",
					"notes": "Text",
					"price": "Double",
					"sku": "String",
					"type": "Enum",
					"type_idx": "Integer",
					"vatRate": "Double"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```


### Authentication Specific Routes



### Common Routes

### Route: currentuser

*Route Definition*: Retrieves the currently authenticated user's session information.

*Route Type*: sessionInfo

*Access Route*: `GET /currentuser`

#### Parameters

This route does **not** require any request parameters.

#### Behavior

- Returns the authenticated session object associated with the current access token.
- If no valid session exists, responds with a 401 Unauthorized.

```js
// Sample GET /currentuser call
axios.get("/currentuser", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````
**Success Response**
Returns the session object, including user-related data and token information.
````
{
  "sessionId": "9cf23fa8-07d4-4e7c-80a6-ec6d6ac96bb9",
  "userId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  "email": "user@example.com",
  "fullname": "John Doe",
  "roleId": "user",
  "tenantId": "abc123",
  "accessToken": "jwt-token-string",
  ...
}
````
**Error Response**
**401 Unauthorized:** No active session found.
````
{
  "status": "ERR",
  "message": "No login found"
}
````

**Notes**
* This route is typically used by frontend or mobile applications to fetch the current session state after login.
* The returned session includes key user identity fields, tenant information (if applicable), and the access token for further authenticated requests.
* Always ensure a valid access token is provided in the request to retrieve the session.

### Route: permissions

`*Route Definition*`: Retrieves all effective permission records assigned to the currently authenticated user.

`*Route Type*`: permissionFetch

*Access Route*: `GET /permissions`

#### Parameters

This route does **not** require any request parameters.

#### Behavior

- Fetches all active permission records (`givenPermissions` entries) associated with the current user session.
- Returns a full array of permission objects.
- Requires a valid session (`access token`) to be available.

```js
// Sample GET /permissions call
axios.get("/permissions", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````
**Success Response**

Returns an array of permission objects.
```json
[
  {
    "id": "perm1",
    "permissionName": "adminPanel.access",
    "roleId": "admin",
    "subjectUserId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
    "subjectUserGroupId": null,
    "objectId": null,
    "canDo": true,
    "tenantCodename": "store123"
  },
  {
    "id": "perm2",
    "permissionName": "orders.manage",
    "roleId": null,
    "subjectUserId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
    "subjectUserGroupId": null,
    "objectId": null,
    "canDo": true,
    "tenantCodename": "store123"
  }
]
````
Each object reflects a single permission grant, aligned with the givenPermissions model:

- `**permissionName**`: The permission the user has.
- `**roleId**`: If the permission was granted through a role.
-` **subjectUserId**`: If directly granted to the user.
- `**subjectUserGroupId**`: If granted through a group.
- `**objectId**`: If tied to a specific object (OBAC).
- `**canDo**`: True or false flag to represent if permission is active or restricted.

**Error Responses**
* **401 Unauthorized**: No active session found.
```json
{
  "status": "ERR",
  "message": "No login found"
}
````
* **500 Internal Server Error**: Unexpected error fetching permissions.

**Notes**
* The /permissions route is available across all backend services generated by Mindbricks, not just the auth service.
* Auth service: Fetches permissions freshly from the live database (givenPermissions table).
* Other services: Typically use a cached or projected view of permissions stored in a common ElasticSearch store, optimized for faster authorization checks.

> **Tip**:
> Applications can cache permission results client-side or server-side, but should occasionally refresh by calling this endpoint, especially after login or permission-changing operations.

### Route: permissions/:permissionName

*Route Definition*: Checks whether the current user has access to a specific permission, and provides a list of scoped object exceptions or inclusions.

*Route Type*: permissionScopeCheck

*Access Route*: `GET /permissions/:permissionName`

#### Parameters

| Parameter         | Type   | Required | Population             |
|------------------|--------|----------|------------------------|
| permissionName   | String | Yes      | `request.params.permissionName` |

#### Behavior

- Evaluates whether the current user **has access** to the given `permissionName`.
- Returns a structured object indicating:
  - Whether the permission is generally granted (`canDo`)
  - Which object IDs are explicitly included or excluded from access (`exceptions`)
- Requires a valid session (`access token`).

```js
// Sample GET /permissions/orders.manage
axios.get("/permissions/orders.manage", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````

**Success Response**

```json
{
  "canDo": true,
  "exceptions": [
    "a1f2e3d4-xxxx-yyyy-zzzz-object1",
    "b2c3d4e5-xxxx-yyyy-zzzz-object2"
  ]
}
````

* If `canDo` is `true`, the user generally has the permission, but not for the objects listed in `exceptions` (i.e., restrictions).
* If `canDo` is `false`, the user does not have the permission by default — but only for the objects in `exceptions`, they do have permission (i.e., selective overrides).
* The exceptions array contains valid **UUID strings**, each corresponding to an object ID (typically from the data model targeted by the permission).

## Copyright
All sources, documents and other digital materials are copyright of .

## About Us
For more information please visit our website: .

.
.


---

<a id="invoicemanagement-service-event-guide"></a>

## EVENT GUIDE

# EVENT GUIDE
## fintrack-invoicemanagement-service

Handles creation and modification of all sales (outgoing) and purchase (incoming) invoices for FinTrack SMBs. Supports multi-item entry per invoice, VAT at item level, detailed filtering, and status calculation based on payments and due dates. Strictly scoped to a single business context.

## Architectural Design Credit and Contact Information

The architectural design of this microservice is credited to . For inquiries, feedback, or further information regarding the architecture, please direct your communication to:

Email: 

We encourage open communication and welcome any questions or discussions related to the architectural aspects of this microservice.

# Documentation Scope

Welcome to the official documentation for the `InvoiceManagement` Service Event descriptions. This guide is dedicated to detailing how to subscribe to and listen for state changes within the `InvoiceManagement` Service, offering an exclusive focus on event subscription mechanisms.

**Intended Audience**

This documentation is aimed at developers and integrators looking to monitor `InvoiceManagement` Service state changes. It is especially relevant for those wishing to implement or enhance business logic based on interactions with `InvoiceManagement` objects.

**Overview**

This section provides detailed instructions on monitoring service events, covering payload structures and demonstrating typical use cases through examples.

# Authentication and Authorization

Access to the `InvoiceManagement` service's events is facilitated through the project's Kafka server, which is not accessible to the public. Subscription to a Kafka topic requires being on the same network and possessing valid Kafka user credentials.  This document presupposes that readers have existing access to the Kafka server.

Additionally, the service offers a public subscription option via REST for real-time data management in frontend applications, secured through REST API authentication and authorization mechanisms. To subscribe to service events via the REST API, please consult the Realtime REST API Guide.

# Database Events

Database events are triggered at the database layer, automatically and atomically, in response to any modifications at the data level. These events serve to notify subscribers about the creation, update, or deletion of objects within the database, distinct from any overarching business logic. 

Listening to database events is particularly beneficial for those focused on tracking changes at the database level. A typical use case for subscribing to database events is to replicate the data store of one service within another service's scope, ensuring data consistency and syncronization across services.

For example, while a business operation such as "approve membership" might generate a high-level business event like `membership-approved`, the underlying database changes could involve multiple state updates to different entities. These might be published as separate events, such as `dbevent-member-updated` and `dbevent-user-updated`, reflecting the granular changes at the database level.

Such detailed eventing provides a robust foundation for building responsive, data-driven applications, enabling fine-grained observability and reaction to the dynamics of the data landscape. It also facilitates the architectural pattern of event sourcing, where state changes are captured as a sequence of events, allowing for high-fidelity data replication and history replay for analytical or auditing purposes.

## DbEvent invoice-created

**Event topic**: `fintrack-invoicemanagement-service-dbevent-invoice-created`

This event is triggered upon the creation of a `invoice` data object in the database. The event payload encompasses the newly created data, encapsulated within the root of the paylod.

**Event payload**: 
```json
{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  
## DbEvent invoice-updated

**Event topic**: `fintrack-invoicemanagement-service-dbevent-invoice-updated`

Activation of this event follows the update of a `invoice` data object. The payload contains the updated information under the `invoice` attribute, along with the original data prior to update, labeled as `old_invoice` and also you can find the old and new versions of updated-only portion of the data..

**Event payload**: 
```json
{
old_invoice:{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
invoice:{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
oldDataValues,
newDataValues
}
``` 
## DbEvent invoice-deleted

**Event topic**: `fintrack-invoicemanagement-service-dbevent-invoice-deleted`

This event announces the deletion of a `invoice` data object, covering both hard deletions (permanent removal) and soft deletions (where the `isActive` attribute is set to false). Regardless of the deletion type, the event payload will present the data as it was immediately before deletion, highlighting an `isActive` status of false for soft deletions.

**Event payload**: 
```json
{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  
## DbEvent invoiceItem-created

**Event topic**: `fintrack-invoicemanagement-service-dbevent-invoiceitem-created`

This event is triggered upon the creation of a `invoiceItem` data object in the database. The event payload encompasses the newly created data, encapsulated within the root of the paylod.

**Event payload**: 
```json
{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  
## DbEvent invoiceItem-updated

**Event topic**: `fintrack-invoicemanagement-service-dbevent-invoiceitem-updated`

Activation of this event follows the update of a `invoiceItem` data object. The payload contains the updated information under the `invoiceItem` attribute, along with the original data prior to update, labeled as `old_invoiceItem` and also you can find the old and new versions of updated-only portion of the data..

**Event payload**: 
```json
{
old_invoiceItem:{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
invoiceItem:{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
oldDataValues,
newDataValues
}
``` 
## DbEvent invoiceItem-deleted

**Event topic**: `fintrack-invoicemanagement-service-dbevent-invoiceitem-deleted`

This event announces the deletion of a `invoiceItem` data object, covering both hard deletions (permanent removal) and soft deletions (where the `isActive` attribute is set to false). Regardless of the deletion type, the event payload will present the data as it was immediately before deletion, highlighting an `isActive` status of false for soft deletions.

**Event payload**: 
```json
{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  


# ElasticSearch Index Events

Within the `InvoiceManagement` service, most data objects are mirrored in ElasticSearch indices, ensuring these indices remain syncronized with their database counterparts through creation, updates, and deletions. These indices serve dual purposes: they act as a data source for external services and furnish aggregated data tailored to enhance frontend user experiences. Consequently, an ElasticSearch index might encapsulate data in its original form or aggregate additional information from other data objects. 

These aggregations can include both one-to-one and one-to-many relationships not only with database objects within the same service but also across different services. This capability allows developers to access comprehensive, aggregated data efficiently. By subscribing to ElasticSearch index events, developers are notified when an index is updated and can directly obtain the aggregated entity within the event payload, bypassing the need for separate ElasticSearch queries.

It's noteworthy that some services may augment another service's index by appending to the entity’s `extends` object. In such scenarios, an `*-extended` event will contain only the newly added data. Should you require the complete dataset, you would need to retrieve the full ElasticSearch index entity using the provided ID.

This approach to indexing and event handling facilitates a modular, interconnected architecture where services can seamlessly integrate and react to changes, enriching the overall data ecosystem and enabling more dynamic, responsive applications.



## Index Event invoice-created

**Event topic**: `elastic-index-fintrack_invoice-created`

**Event payload**:
```json
{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event invoice-updated

**Event topic**: `elastic-index-fintrack_invoice-created`

**Event payload**:
```json
{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event invoice-deleted

**Event topic**: `elastic-index-fintrack_invoice-deleted`

**Event payload**:
```json
{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event invoice-extended

**Event topic**: `elastic-index-fintrack_invoice-extended`

**Event payload**:
```js
{
  id: id,
  extends: {
    [extendName]: "Object",
    [extendName + "_count"]: "Number",
  },
}
``` 

# Route Events

Route events are emitted following the successful execution of a route. While most routes perform CRUD (Create, Read, Update, Delete) operations on data objects, resulting in route events that closely resemble database events, there are distinctions worth noting. A single route execution might trigger multiple CRUD actions and ElasticSearch indexing operations. However, for those primarily concerned with the overarching business logic and its outcomes, listening to the consolidated route event, published once at the conclusion of the route's execution, is more pertinent.

Moreover, routes often deliver aggregated data beyond the primary database object, catering to specific client needs. For instance, creating a data object via a route might not only return the entity's data but also route-specific metrics, such as the executing user's permissions related to the entity. Alternatively, a route might automatically generate default child entities following the creation of a parent object. Consequently, the route event encapsulates a unified dataset encompassing both the parent and its children, in contrast to individual events triggered for each entity created. Therefore, subscribing to route events can offer a richer, more contextually relevant set of information aligned with business logic.

The payload of a route event mirrors the REST response JSON of the route, providing a direct and comprehensive reflection of the data and metadata communicated to the client. This ensures that subscribers to route events receive a payload that encapsulates both the primary data involved and any additional information deemed significant at the business level, facilitating a deeper understanding and integration of the service's functional outcomes.


## Route Event invoice-created

**Event topic** : `fintrack-invoicemanagement-service-invoice-created`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoice` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoice`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"201","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoice","method":"POST","action":"create","appVersion":"Version","rowCount":1,"invoice":{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event invoiceitem-created

**Event topic** : `fintrack-invoicemanagement-service-invoiceitem-created`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoiceItem` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoiceItem`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"201","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoiceItem","method":"POST","action":"create","appVersion":"Version","rowCount":1,"invoiceItem":{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event invoice-deleted

**Event topic** : `fintrack-invoicemanagement-service-invoice-deleted`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoice` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoice`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoice","method":"DELETE","action":"delete","appVersion":"Version","rowCount":1,"invoice":{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event invoiceitem-deleted

**Event topic** : `fintrack-invoicemanagement-service-invoiceitem-deleted`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoiceItem` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoiceItem`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoiceItem","method":"DELETE","action":"delete","appVersion":"Version","rowCount":1,"invoiceItem":{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event invoice-retrived

**Event topic** : `fintrack-invoicemanagement-service-invoice-retrived`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoice` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoice`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoice","method":"GET","action":"get","appVersion":"Version","rowCount":1,"invoice":{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID","items":[{"description":"String","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double"},{},{}],"customer":{"contactEmail":"String","contactName":"String","name":"String"},"supplier":{"contactEmail":"String","contactName":"String","name":"String"}}}
```  
## Route Event invoiceitem-retrived

**Event topic** : `fintrack-invoicemanagement-service-invoiceitem-retrived`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoiceItem` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoiceItem`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoiceItem","method":"GET","action":"get","appVersion":"Version","rowCount":1,"invoiceItem":{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID","productOrService":{"currency":"String","name":"String","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double"}}}
```  
## Route Event invoiceitems-listed

**Event topic** : `fintrack-invoicemanagement-service-invoiceitems-listed`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoiceItems` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoiceItems`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoiceItems","method":"GET","action":"list","appVersion":"Version","rowCount":"\"Number\"","invoiceItems":[{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID","productOrService":[{"currency":"String","name":"String","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double"},{},{}]},{},{}],"paging":{"pageNumber":"Number","pageRowCount":"NUmber","totalRowCount":"Number","pageCount":"Number"},"filters":[],"uiPermissions":[]}
```  
## Route Event invoices-listed

**Event topic** : `fintrack-invoicemanagement-service-invoices-listed`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoices` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoices`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoices","method":"GET","action":"list","appVersion":"Version","rowCount":"\"Number\"","invoices":[{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID","items":[{"description":"String","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double"},{},{}],"customer":[{"contactEmail":"String","contactName":"String","name":"String"},{},{}],"supplier":[{"contactEmail":"String","contactName":"String","name":"String"},{},{}]},{},{}],"paging":{"pageNumber":"Number","pageRowCount":"NUmber","totalRowCount":"Number","pageCount":"Number"},"filters":[],"uiPermissions":[]}
```  
## Route Event invoice-updated

**Event topic** : `fintrack-invoicemanagement-service-invoice-updated`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoice` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoice`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoice","method":"PATCH","action":"update","appVersion":"Version","rowCount":1,"invoice":{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event invoiceitem-updated

**Event topic** : `fintrack-invoicemanagement-service-invoiceitem-updated`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoiceItem` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoiceItem`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoiceItem","method":"PATCH","action":"update","appVersion":"Version","rowCount":1,"invoiceItem":{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  



## Index Event invoiceitem-created

**Event topic**: `elastic-index-fintrack_invoiceitem-created`

**Event payload**:
```json
{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event invoiceitem-updated

**Event topic**: `elastic-index-fintrack_invoiceitem-created`

**Event payload**:
```json
{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event invoiceitem-deleted

**Event topic**: `elastic-index-fintrack_invoiceitem-deleted`

**Event payload**:
```json
{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event invoiceitem-extended

**Event topic**: `elastic-index-fintrack_invoiceitem-extended`

**Event payload**:
```js
{
  id: id,
  extends: {
    [extendName]: "Object",
    [extendName + "_count"]: "Number",
  },
}
``` 

# Route Events

Route events are emitted following the successful execution of a route. While most routes perform CRUD (Create, Read, Update, Delete) operations on data objects, resulting in route events that closely resemble database events, there are distinctions worth noting. A single route execution might trigger multiple CRUD actions and ElasticSearch indexing operations. However, for those primarily concerned with the overarching business logic and its outcomes, listening to the consolidated route event, published once at the conclusion of the route's execution, is more pertinent.

Moreover, routes often deliver aggregated data beyond the primary database object, catering to specific client needs. For instance, creating a data object via a route might not only return the entity's data but also route-specific metrics, such as the executing user's permissions related to the entity. Alternatively, a route might automatically generate default child entities following the creation of a parent object. Consequently, the route event encapsulates a unified dataset encompassing both the parent and its children, in contrast to individual events triggered for each entity created. Therefore, subscribing to route events can offer a richer, more contextually relevant set of information aligned with business logic.

The payload of a route event mirrors the REST response JSON of the route, providing a direct and comprehensive reflection of the data and metadata communicated to the client. This ensures that subscribers to route events receive a payload that encapsulates both the primary data involved and any additional information deemed significant at the business level, facilitating a deeper understanding and integration of the service's functional outcomes.


## Route Event invoice-created

**Event topic** : `fintrack-invoicemanagement-service-invoice-created`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoice` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoice`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"201","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoice","method":"POST","action":"create","appVersion":"Version","rowCount":1,"invoice":{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event invoiceitem-created

**Event topic** : `fintrack-invoicemanagement-service-invoiceitem-created`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoiceItem` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoiceItem`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"201","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoiceItem","method":"POST","action":"create","appVersion":"Version","rowCount":1,"invoiceItem":{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event invoice-deleted

**Event topic** : `fintrack-invoicemanagement-service-invoice-deleted`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoice` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoice`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoice","method":"DELETE","action":"delete","appVersion":"Version","rowCount":1,"invoice":{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event invoiceitem-deleted

**Event topic** : `fintrack-invoicemanagement-service-invoiceitem-deleted`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoiceItem` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoiceItem`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoiceItem","method":"DELETE","action":"delete","appVersion":"Version","rowCount":1,"invoiceItem":{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event invoice-retrived

**Event topic** : `fintrack-invoicemanagement-service-invoice-retrived`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoice` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoice`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoice","method":"GET","action":"get","appVersion":"Version","rowCount":1,"invoice":{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID","items":[{"description":"String","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double"},{},{}],"customer":{"contactEmail":"String","contactName":"String","name":"String"},"supplier":{"contactEmail":"String","contactName":"String","name":"String"}}}
```  
## Route Event invoiceitem-retrived

**Event topic** : `fintrack-invoicemanagement-service-invoiceitem-retrived`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoiceItem` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoiceItem`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoiceItem","method":"GET","action":"get","appVersion":"Version","rowCount":1,"invoiceItem":{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID","productOrService":{"currency":"String","name":"String","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double"}}}
```  
## Route Event invoiceitems-listed

**Event topic** : `fintrack-invoicemanagement-service-invoiceitems-listed`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoiceItems` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoiceItems`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoiceItems","method":"GET","action":"list","appVersion":"Version","rowCount":"\"Number\"","invoiceItems":[{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID","productOrService":[{"currency":"String","name":"String","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double"},{},{}]},{},{}],"paging":{"pageNumber":"Number","pageRowCount":"NUmber","totalRowCount":"Number","pageCount":"Number"},"filters":[],"uiPermissions":[]}
```  
## Route Event invoices-listed

**Event topic** : `fintrack-invoicemanagement-service-invoices-listed`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoices` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoices`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoices","method":"GET","action":"list","appVersion":"Version","rowCount":"\"Number\"","invoices":[{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID","items":[{"description":"String","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double"},{},{}],"customer":[{"contactEmail":"String","contactName":"String","name":"String"},{},{}],"supplier":[{"contactEmail":"String","contactName":"String","name":"String"},{},{}]},{},{}],"paging":{"pageNumber":"Number","pageRowCount":"NUmber","totalRowCount":"Number","pageCount":"Number"},"filters":[],"uiPermissions":[]}
```  
## Route Event invoice-updated

**Event topic** : `fintrack-invoicemanagement-service-invoice-updated`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoice` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoice`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoice","method":"PATCH","action":"update","appVersion":"Version","rowCount":1,"invoice":{"id":"ID","currency":"String","customerId":"ID","dueDate":"Date","invoiceNumber":"String","issueDate":"Date","notes":"Text","status":"Enum","status_idx":"Integer","supplierId":"ID","totalAmount":"Double","type":"Enum","type_idx":"Integer","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event invoiceitem-updated

**Event topic** : `fintrack-invoicemanagement-service-invoiceitem-updated`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `invoiceItem` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`invoiceItem`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"invoiceItem","method":"PATCH","action":"update","appVersion":"Version","rowCount":1,"invoiceItem":{"id":"ID","description":"String","invoiceId":"ID","productOrServiceId":"ID","quantity":"Double","total":"Double","unitPrice":"Double","vatAmount":"Double","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  




# Copyright
All sources, documents and other digital materials are copyright of .

# About Us
For more information please visit our website: .

.
.


---

## Data Objects

<a id="invoicemanagement-service-invoice-design"></a>

### Service Design Specification - Object Design for invoice

# Service Design Specification - Object Design for invoice
**fintrack-invoicemanagement-service** documentation

## Document Overview
This document outlines the object design for the `invoice` model in our application. It includes details about the model's attributes, relationships, and any specific validation or business logic that applies.

## invoice Data Object

### Object Overview
**Description:** Represents a single sales or purchase invoice document for a business. Contains summary information, partner (customer/supplier), and status derived from payments and dates.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessPrivate — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.




### Composite Indexes

- **businessInvoiceNumberUnique**: [businessId, invoiceNumber] 
This composite index is defined to optimize query performance for complex queries involving multiple fields.

The index also defines a conflict resolution strategy for duplicate key violations.

When a new record would violate this composite index, the following action will be taken:

**On Duplicate**: `throwError`

An error will be thrown, preventing the insertion of conflicting data.






### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `currency` | String | Yes | Currency code for all values in invoice and its items (e.g., &#39;USD&#39;). |
| `customerId` | ID | No | Referenced customer (for sales invoice; null for purchase invoice). |
| `dueDate` | Date | Yes | Date by which payment for this invoice is due. |
| `invoiceNumber` | String | Yes | A unique identifier (number/code) for this invoice within a business. |
| `issueDate` | Date | Yes | Date this invoice was issued. |
| `notes` | Text | No | Internal notes about the invoice, never publicly exposed. |
| `status` | Enum | Yes | Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate. |
| `supplierId` | ID | No | Referenced supplier (for purchase invoice; null for sales invoice). |
| `totalAmount` | Double | Yes | Grand total for invoice (sum of line item totals, including VAT). Calculated; always up-to-date. |
| `type` | Enum | Yes | Invoice nature; &#39;sales&#39;=outgoing, &#39;purchase&#39;=incoming. |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **currency**: 'default'
- **dueDate**: new Date()
- **invoiceNumber**: 'default'
- **issueDate**: new Date()
- **status**: unpaid
- **totalAmount**: 0.0
- **type**: "sales"
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`status` `totalAmount` `type` `businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`currency` `customerId` `dueDate` `invoiceNumber` `issueDate` `notes` `status` `supplierId` `type`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

### Enum Properties
Enum properties are defined with a set of allowed values, ensuring that only valid options can be assigned to them. 
The enum options value will be stored as strings in the database, 
but when a data object is created an addtional property with the same name plus an idx suffix will be created, which will hold the index of the selected enum option.
You can use the index property to sort by the enum value or when your enum options represent a sequence of values.

- **status**: [unpaid, partial, paid, overdue]

- **type**: [sales, purchase]

 

 

### Elastic Search Indexing

`currency` `customerId` `dueDate` `invoiceNumber` `issueDate` `status` `supplierId` `totalAmount` `type` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`currency` `customerId` `dueDate` `invoiceNumber` `issueDate` `status` `supplierId` `type` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.





### Secondary Key Properties

`invoiceNumber` `businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.


### Relation Properties

`customerId` `supplierId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **customerId**: ID
Relation to `customer`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: No

- **supplierId**: ID
Relation to `supplier`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: No




### Formula Properties

`totalAmount`

Formula properties are used to define calculated fields that derive their values from other properties or external data.
These properties are automatically calculated based on the defined formula and can be used for dynamic data retrieval.

- **totalAmount**: Double  
  - Formula: `LIB.calculateInvoiceTotal(this)`
  
  - Calculate After Instance: Yes
  
  - Calculate When Input Has: [id]
  


### Filter Properties

`customerId` `dueDate` `invoiceNumber` `issueDate` `status` `supplierId` `type` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **customerId**: ID  has a filter named `customerId`

- **dueDate**: Date  has a filter named `dueDate`

- **invoiceNumber**: String  has a filter named `invoiceNumber`

- **issueDate**: Date  has a filter named `issueDate`

- **status**: Enum  has a filter named `status`

- **supplierId**: ID  has a filter named `supplierId`

- **type**: Enum  has a filter named `type`

- **businessId**: ID  has a filter named `businessId`



  

---

<a id="invoicemanagement-service-invoiceitem-design"></a>

### Service Design Specification - Object Design for invoiceItem

# Service Design Specification - Object Design for invoiceItem
**fintrack-invoicemanagement-service** documentation

## Document Overview
This document outlines the object design for the `invoiceItem` model in our application. It includes details about the model's attributes, relationships, and any specific validation or business logic that applies.

## invoiceItem Data Object

### Object Overview
**Description:** Represents a single line item in an invoice, with product/service linkage, quantity, pricing, VAT, and per-line total.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessPrivate — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.








### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `description` | String | No | Optional text/override for item description (default: product/service name). |
| `invoiceId` | ID | Yes | Reference to parent invoice (ensures item belongs to this invoice). |
| `productOrServiceId` | ID | Yes | Reference to product/service used in this line item. |
| `quantity` | Double | Yes | Quantity of product/service being invoiced. |
| `total` | Double | Yes | Line total (unit price * quantity + VAT Amount); calculated. |
| `unitPrice` | Double | Yes | The (net) unit price for this item (auto-fetched from product/service at time of insert, overridable). |
| `vatAmount` | Double | Yes | Computed VAT amount for this invoice item. |
| `vatRate` | Double | Yes | VAT rate (%) applied for this item (auto-fetched from product/service, overridable if allowed). |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **invoiceId**: '00000000-0000-0000-0000-000000000000'
- **productOrServiceId**: '00000000-0000-0000-0000-000000000000'
- **quantity**: 1
- **total**: 0.0
- **unitPrice**: 0.0
- **vatAmount**: 0.0
- **vatRate**: 0
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`invoiceId` `total` `vatAmount` `businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`description` `productOrServiceId` `quantity` `unitPrice` `vatRate`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

 

 

### Elastic Search Indexing

`description` `invoiceId` `productOrServiceId` `quantity` `total` `unitPrice` `vatAmount` `vatRate` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`invoiceId` `productOrServiceId` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.





### Secondary Key Properties

`businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.


### Relation Properties

`invoiceId` `productOrServiceId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **invoiceId**: ID
Relation to `invoice`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: Yes

- **productOrServiceId**: ID
Relation to `productOrService`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: Yes




### Formula Properties

`description` `total` `unitPrice` `vatAmount` `vatRate`

Formula properties are used to define calculated fields that derive their values from other properties or external data.
These properties are automatically calculated based on the defined formula and can be used for dynamic data retrieval.

- **description**: String  
  - Formula: `!this.description &amp;&amp; this.productOrServiceId ? LIB.getProductOrServiceName(this.productOrServiceId) : this.description`
  
  - Calculate After Instance: Yes
  
  - Calculate When Input Has: [productOrServiceId]
  

- **total**: Double  
  - Formula: `this.unitPrice * this.quantity + this.vatAmount`
  
  - Calculate After Instance: No
  
  - Calculate When Input Has: [quantity, unitPrice, vatAmount]
  

- **unitPrice**: Double  
  - Formula: `this.unitPrice ?? LIB.getProductOrServicePrice(this.productOrServiceId)`
  
  - Calculate After Instance: Yes
  
  - Calculate When Input Has: [productOrServiceId]
  

- **vatAmount**: Double  
  - Formula: `LIB.calculateVatAmount(this.unitPrice, this.quantity, this.vatRate)`
  
  - Calculate After Instance: No
  
  - Calculate When Input Has: [quantity, unitPrice, vatRate]
  

- **vatRate**: Double  
  - Formula: `this.vatRate ?? LIB.getProductOrServiceVatRate(this.productOrServiceId)`
  
  - Calculate After Instance: Yes
  
  - Calculate When Input Has: [productOrServiceId]
  


### Filter Properties

`invoiceId` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **invoiceId**: ID  has a filter named `invoiceId`

- **businessId**: ID  has a filter named `businessId`



  

---

## Business APIs

<a id="invoicemanagement-service-business-api-createinvoice-api-design"></a>

### Business API Design Specification - `Create Invoice`


# Business API Design Specification - `Create Invoice`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `createInvoice` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `createInvoice` Business API is designed to handle a `create` operation on the `Invoice` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Create a new invoice (sales or purchase), require proper partner, auto-status, and initialize with/without items. Owner or Accountant only.

## API Frontend Description By The Backend Architect

UI must prompt for invoice type first; if type=sales require customer; if type=purchase require supplier. Line items can be added inline or after main invoice save. Save triggers recalculation of total and default status to unpaid. Allow adding notes.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `invoice-created` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `createInvoice` Business API includes a REST controller that can be triggered via the following route:

`/v1/invoices`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `createInvoice` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `createInvoice` Business API has 11 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceId`                             | `ID`   | `No` | `-` | `body` | `invoiceId` |
| **Description:**                                | This id paremeter is used to create the data object with a given specific id. Leave null for automatic id. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `currency`                             | `String`   | `Yes` | `-` | `body` | `currency` |
| **Description:**                                | Currency code for all values in invoice and its items (e.g., 'USD'). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `customerId`                             | `ID`   | `No` | `-` | `body` | `customerId` |
| **Description:**                                | Referenced customer (for sales invoice; null for purchase invoice). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `dueDate`                             | `Date`   | `Yes` | `-` | `body` | `dueDate` |
| **Description:**                                | Date by which payment for this invoice is due. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceNumber`                             | `String`   | `Yes` | `-` | `body` | `invoiceNumber` |
| **Description:**                                | A unique identifier (number/code) for this invoice within a business. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `issueDate`                             | `Date`   | `Yes` | `-` | `body` | `issueDate` |
| **Description:**                                | Date this invoice was issued. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `notes`                             | `Text`   | `No` | `-` | `body` | `notes` |
| **Description:**                                | Internal notes about the invoice, never publicly exposed. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `status`                             | `Enum`   | `Yes` | `-` | `body` | `status` |
| **Description:**                                | Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `supplierId`                             | `ID`   | `No` | `-` | `body` | `supplierId` |
| **Description:**                                | Referenced supplier (for purchase invoice; null for sales invoice). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `totalAmount`                             | `Double`   | `Yes` | `-` | `body` | `totalAmount` |
| **Description:**                                | Grand total for invoice (sum of line item totals, including VAT). Calculated; always up-to-date. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `type`                             | `Enum`   | `Yes` | `-` | `body` | `type` |
| **Description:**                                | Invoice nature; 'sales'=outgoing, 'purchase'=incoming. |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `createInvoice` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant]`




---





## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 



**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  id: this.invoiceId,
  businessId: this.businessId,
  currency: this.currency,
  customerId: this.customerId,
  dueDate: this.dueDate,
  invoiceNumber: this.invoiceNumber,
  issueDate: this.issueDate,
  notes: this.notes,
  status: this.status,
  supplierId: this.supplierId,
  totalAmount: this.totalAmount,
  type: this.type,
  isActive: true,
  _archivedAt: null,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, populates session and request objects, prepares internal structures for parameter handling and workflow execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads input parameters, normalizes missing values, applies default type casting, and stores them in the API context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager transforms parameters, computes derived values, flattens or remaps arrays/objects, and adjusts formats for downstream processing.


---




### [4] Step : checkParameters

Manager executes built-in validations: required field checks, type enforcement, and basic business rules. Prevents operation if validation fails.


---




### [5] Step : checkBasicAuth

Manager performs authentication and authorization checks: verifies session, user roles, permissions, and tenant restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildDataClause

Manager constructs the final data object for creation, fills auto-generated fields (IDs, timestamps, owner fields), and ensures schema consistency.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [7] Step : mainCreateOperation

Manager executes the database insert operation, updates indexes/caches, and triggers internal post-processing like linked default records.


---




### [8] Step : buildOutput

Manager shapes the response: masks sensitive fields, resolves linked references, and formats output according to API contract.


---




### [9] Step : sendResponse

Manager sends the response to the client and finalizes internal tasks like flushing logs or updating session state.


---




### [10] Step : raiseApiEvent

Manager triggers API-level events (Kafka, WebSocket, async workflows) as the final internal step.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `createInvoice` api has got 9 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| currency  | String  | true | request.body?.["currency"] |
| customerId  | ID  | false | request.body?.["customerId"] |
| dueDate  | Date  | true | request.body?.["dueDate"] |
| invoiceNumber  | String  | true | request.body?.["invoiceNumber"] |
| issueDate  | Date  | true | request.body?.["issueDate"] |
| notes  | Text  | false | request.body?.["notes"] |
| status  | Enum  | true | request.body?.["status"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |
| type  | Enum  | true | request.body?.["type"] |

### REST Request
To access the api you can use the **REST** controller with the path **POST  /v1/invoices**
```js
  axios({
    method: 'POST',
    url: '/v1/invoices',
    data: {
            currency:"String",  
            customerId:"ID",  
            dueDate:"Date",  
            invoiceNumber:"String",  
            issueDate:"Date",  
            notes:"Text",  
            status:"Enum",  
            supplierId:"ID",  
            type:"Enum",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoice`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="invoicemanagement-service-business-api-createinvoiceitem-api-design"></a>

### Business API Design Specification - `Create Invoiceitem`


# Business API Design Specification - `Create Invoiceitem`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `createInvoiceItem` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `createInvoiceItem` Business API is designed to handle a `create` operation on the `InvoiceItem` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Create a new line item for an invoice. Only permitted for Owner/Accountant or if user has edit rights for invoice.

## API Frontend Description By The Backend Architect

Item is created within context of an invoice. Product/service lookup required. Quantity and price editable if business logic allows. VAT is defaulted/calculated and presented. Totals computed automatically.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `invoiceitem-created` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `createInvoiceItem` Business API includes a REST controller that can be triggered via the following route:

`/v1/invoiceitems`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `createInvoiceItem` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `createInvoiceItem` Business API has 9 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceItemId`                             | `ID`   | `No` | `-` | `body` | `invoiceItemId` |
| **Description:**                                | This id paremeter is used to create the data object with a given specific id. Leave null for automatic id. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `description`                             | `String`   | `No` | `-` | `body` | `description` |
| **Description:**                                | Optional text/override for item description (default: product/service name). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceId`                             | `ID`   | `Yes` | `-` | `body` | `invoiceId` |
| **Description:**                                | Reference to parent invoice (ensures item belongs to this invoice). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `productOrServiceId`                             | `ID`   | `Yes` | `-` | `body` | `productOrServiceId` |
| **Description:**                                | Reference to product/service used in this line item. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `quantity`                             | `Double`   | `Yes` | `-` | `body` | `quantity` |
| **Description:**                                | Quantity of product/service being invoiced. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `total`                             | `Double`   | `Yes` | `-` | `body` | `total` |
| **Description:**                                | Line total (unit price * quantity + VAT Amount); calculated. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `unitPrice`                             | `Double`   | `Yes` | `-` | `body` | `unitPrice` |
| **Description:**                                | The (net) unit price for this item (auto-fetched from product/service at time of insert, overridable). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `vatAmount`                             | `Double`   | `Yes` | `-` | `body` | `vatAmount` |
| **Description:**                                | Computed VAT amount for this invoice item. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `vatRate`                             | `Double`   | `Yes` | `-` | `body` | `vatRate` |
| **Description:**                                | VAT rate (%) applied for this item (auto-fetched from product/service, overridable if allowed). |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `createInvoiceItem` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant]`




---





## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 



**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  id: this.invoiceItemId,
  businessId: this.businessId,
  description: this.description,
  invoiceId: this.invoiceId,
  productOrServiceId: this.productOrServiceId,
  quantity: this.quantity,
  total: this.total,
  unitPrice: this.unitPrice,
  vatAmount: this.vatAmount,
  vatRate: this.vatRate,
  isActive: true,
  _archivedAt: null,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, populates session and request objects, prepares internal structures for parameter handling and workflow execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads input parameters, normalizes missing values, applies default type casting, and stores them in the API context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager transforms parameters, computes derived values, flattens or remaps arrays/objects, and adjusts formats for downstream processing.


---




### [4] Step : checkParameters

Manager executes built-in validations: required field checks, type enforcement, and basic business rules. Prevents operation if validation fails.


---




### [5] Step : checkBasicAuth

Manager performs authentication and authorization checks: verifies session, user roles, permissions, and tenant restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildDataClause

Manager constructs the final data object for creation, fills auto-generated fields (IDs, timestamps, owner fields), and ensures schema consistency.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [7] Step : mainCreateOperation

Manager executes the database insert operation, updates indexes/caches, and triggers internal post-processing like linked default records.


---




### [8] Step : buildOutput

Manager shapes the response: masks sensitive fields, resolves linked references, and formats output according to API contract.


---




### [9] Step : sendResponse

Manager sends the response to the client and finalizes internal tasks like flushing logs or updating session state.


---




### [10] Step : raiseApiEvent

Manager triggers API-level events (Kafka, WebSocket, async workflows) as the final internal step.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `createInvoiceItem` api has got 3 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.body?.["invoiceId"] |
| productOrServiceId  | ID  | true | request.body?.["productOrServiceId"] |
| quantity  | Double  | true | request.body?.["quantity"] |

### REST Request
To access the api you can use the **REST** controller with the path **POST  /v1/invoiceitems**
```js
  axios({
    method: 'POST',
    url: '/v1/invoiceitems',
    data: {
            invoiceId:"ID",  
            productOrServiceId:"ID",  
            quantity:"Double",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoiceItem`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="invoicemanagement-service-business-api-deleteinvoice-api-design"></a>

### Business API Design Specification - `Delete Invoice`


# Business API Design Specification - `Delete Invoice`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `deleteInvoice` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `deleteInvoice` Business API is designed to handle a `delete` operation on the `Invoice` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Soft delete/deactivate an invoice (remains for audit/history, removes from normal use). Owner/Accountant only.

## API Frontend Description By The Backend Architect

Allow delete/deactivation from invoice list/details. Deletion is always soft (record preserved).

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `invoice-deleted` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `deleteInvoice` Business API includes a REST controller that can be triggered via the following route:

`/v1/invoices/:invoiceId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `deleteInvoice` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `deleteInvoice` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceId`                             | `ID`   | `Yes` | `-` | `urlpath` | `invoiceId` |
| **Description:**                                | This id paremeter is used to select the required data object that will be deleted |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `deleteInvoice` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant]`




---



## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.invoiceId},{businessId:this.businessId,isActive:true}]}
```





## Delete Options
Use these options to set `delete` specific settings.

**useSoftDelete**: true
If true, the record will be marked as deleted `(isActive: false)` instead of removed. The implementation depends on the data object’s soft delete configuration.





   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, prepares request/session objects, and sets up internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads and normalizes parameters, applies defaults, and stores them in the context for downstream steps.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager executes parameter transform scripts, computes derived values, and remaps objects or arrays as needed for later processing.


---




### [4] Step : checkParameters

Manager runs built-in validations including required field checks, type enforcement, and deletion preconditions. Stops execution if validation fails.


---




### [5] Step : checkBasicAuth

Manager validates session, user roles, permissions, and tenant-specific access rules to enforce basic auth restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Manager generates the query conditions, applies ownership and parent checks, and ensures the clause is correct for the delete operation.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : fetchInstance

Manager fetches the target record, applies filters from WHERE clause, and writes the instance to the context for further checks.


---




### [8] Step : checkInstance

Manager performs object-level validations such as lock status, soft-delete eligibility, and multi-step approval enforcement.


---




### [9] Step : mainDeleteOperation

Manager executes the delete query, updates related indexes/caches, and handles soft/hard delete logic according to configuration.


You can use the following settings to change some behavior of this step.
`deleteOptions`
---




### [10] Step : buildOutput

Manager shapes the response payload, masks sensitive fields, and formats related cleanup results for output.


---




### [11] Step : sendResponse

Manager delivers the response to the client and finalizes any temporary internal structures.


---




### [12] Step : raiseApiEvent

Manager triggers asynchronous API events, notifies queues or streams, and performs final cleanup for the workflow.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `deleteInvoice` api has got 1 regular client parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.params?.["invoiceId"] |

### REST Request
To access the api you can use the **REST** controller with the path **DELETE  /v1/invoices/:invoiceId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/invoices/${invoiceId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoice`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="invoicemanagement-service-business-api-deleteinvoiceitem-api-design"></a>

### Business API Design Specification - `Delete Invoiceitem`


# Business API Design Specification - `Delete Invoiceitem`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `deleteInvoiceItem` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `deleteInvoiceItem` Business API is designed to handle a `delete` operation on the `InvoiceItem` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Remove an invoice line item. Soft delete by default. Only Owner/Accountant allowed; item remains for reporting/audit.

## API Frontend Description By The Backend Architect

Delete removes item from invoice's current views but keeps for reporting/history. Adjust totals on invoice accordingly.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `invoiceitem-deleted` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `deleteInvoiceItem` Business API includes a REST controller that can be triggered via the following route:

`/v1/invoiceitems/:invoiceItemId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `deleteInvoiceItem` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `deleteInvoiceItem` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceItemId`                             | `ID`   | `Yes` | `-` | `urlpath` | `invoiceItemId` |
| **Description:**                                | This id paremeter is used to select the required data object that will be deleted |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `deleteInvoiceItem` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant]`




---



## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.invoiceItemId},{businessId:this.businessId,isActive:true}]}
```





## Delete Options
Use these options to set `delete` specific settings.

**useSoftDelete**: true
If true, the record will be marked as deleted `(isActive: false)` instead of removed. The implementation depends on the data object’s soft delete configuration.





   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, prepares request/session objects, and sets up internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads and normalizes parameters, applies defaults, and stores them in the context for downstream steps.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager executes parameter transform scripts, computes derived values, and remaps objects or arrays as needed for later processing.


---




### [4] Step : checkParameters

Manager runs built-in validations including required field checks, type enforcement, and deletion preconditions. Stops execution if validation fails.


---




### [5] Step : checkBasicAuth

Manager validates session, user roles, permissions, and tenant-specific access rules to enforce basic auth restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Manager generates the query conditions, applies ownership and parent checks, and ensures the clause is correct for the delete operation.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : fetchInstance

Manager fetches the target record, applies filters from WHERE clause, and writes the instance to the context for further checks.


---




### [8] Step : checkInstance

Manager performs object-level validations such as lock status, soft-delete eligibility, and multi-step approval enforcement.


---




### [9] Step : mainDeleteOperation

Manager executes the delete query, updates related indexes/caches, and handles soft/hard delete logic according to configuration.


You can use the following settings to change some behavior of this step.
`deleteOptions`
---




### [10] Step : buildOutput

Manager shapes the response payload, masks sensitive fields, and formats related cleanup results for output.


---




### [11] Step : sendResponse

Manager delivers the response to the client and finalizes any temporary internal structures.


---




### [12] Step : raiseApiEvent

Manager triggers asynchronous API events, notifies queues or streams, and performs final cleanup for the workflow.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `deleteInvoiceItem` api has got 1 regular client parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceItemId  | ID  | true | request.params?.["invoiceItemId"] |

### REST Request
To access the api you can use the **REST** controller with the path **DELETE  /v1/invoiceitems/:invoiceItemId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/invoiceitems/${invoiceItemId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoiceItem`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="invoicemanagement-service-business-api-getinvoice-api-design"></a>

### Business API Design Specification - `Get Invoice`


# Business API Design Specification - `Get Invoice`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `getInvoice` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `getInvoice` Business API is designed to handle a `get` operation on the `Invoice` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Fetch a detailed invoice by ID, including all items and partner details. All business users have read access within business context.

## API Frontend Description By The Backend Architect

Display invoice header, itemized line items, customer (sales) or supplier (purchase) info, summary totals and auto-calculated status. Status should match payments up to the time of request.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `invoice-retrived` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `true`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `getInvoice` Business API includes a REST controller that can be triggered via the following route:

`/v1/invoices/:invoiceId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `getInvoice` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `getInvoice` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceId`                             | `ID`   | `Yes` | `-` | `urlpath` | `invoiceId` |
| **Description:**                                | This id paremeter is used to query the required data object. |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `getInvoice` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant`, `user]`




---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

``


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.invoiceId},{businessId:this.businessId,isActive:true}]}
```







## Get Options
Use these options to set `get` specific settings.

**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.





   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Extracts parameters from request and Redis, applies defaults, and writes them to context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Executes parameter transformation scripts, applies type coercion, merges derived values, and reshapes inputs for downstream milestones.


---




### [4] Step : checkParameters

Validates required and custom parameters, enforcing business-specific rules and constraints.


---




### [5] Step : checkBasicAuth

Performs login, role, and permission checks, and applies dynamic object-level access rules.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Builds the WHERE clause for fetching the object and applies additional scoped filters if configured.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainGetOperation

Executes the database fetch, retrieves the object, and stores it in context for enrichment or further checks.


You can use the following settings to change some behavior of this step.
`selectClause`, `getOptions`
---




### [8] Step : checkInstance

Performs instance-level validations, such as ownership, existence, or access conditions.


---




### [9] Step : buildOutput

Assembles the response from the object, applies masking, formatting, and injects additional metadata if needed.


---




### [10] Step : sendResponse

Delivers the response to the controller for client delivery.


---




### [11] Step : raiseApiEvent

Triggers optional API-level events after workflow completion, sending messages to integrations like Kafka if configured.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `getInvoice` api has got 1 regular client parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.params?.["invoiceId"] |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/invoices/:invoiceId**
```js
  axios({
    method: 'GET',
    url: `/v1/invoices/${invoiceId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoice`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID",
		"items": [
			{
				"description": "String",
				"quantity": "Double",
				"total": "Double",
				"unitPrice": "Double",
				"vatAmount": "Double",
				"vatRate": "Double"
			},
			{},
			{}
		],
		"customer": {
			"contactEmail": "String",
			"contactName": "String",
			"name": "String"
		},
		"supplier": {
			"contactEmail": "String",
			"contactName": "String",
			"name": "String"
		}
	}
}
```  

---

<a id="invoicemanagement-service-business-api-getinvoiceitem-api-design"></a>

### Business API Design Specification - `Get Invoiceitem`


# Business API Design Specification - `Get Invoiceitem`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `getInvoiceItem` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `getInvoiceItem` Business API is designed to handle a `get` operation on the `InvoiceItem` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Get details for a single invoice item (line details with product/service info). All business users have access within scope (for invoice display and workflows).

## API Frontend Description By The Backend Architect

Show item description, product/service name, quantity, unit price, VAT, and subtotal/total (with calculations). Allow link to product/service catalog for further details.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `invoiceitem-retrived` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `getInvoiceItem` Business API includes a REST controller that can be triggered via the following route:

`/v1/invoiceitems/:invoiceItemId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `getInvoiceItem` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `getInvoiceItem` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceItemId`                             | `ID`   | `Yes` | `-` | `urlpath` | `invoiceItemId` |
| **Description:**                                | This id paremeter is used to query the required data object. |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `getInvoiceItem` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant`, `user]`




---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

``


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.invoiceItemId},{businessId:this.businessId,isActive:true}]}
```







## Get Options
Use these options to set `get` specific settings.

**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.





   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Extracts parameters from request and Redis, applies defaults, and writes them to context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Executes parameter transformation scripts, applies type coercion, merges derived values, and reshapes inputs for downstream milestones.


---




### [4] Step : checkParameters

Validates required and custom parameters, enforcing business-specific rules and constraints.


---




### [5] Step : checkBasicAuth

Performs login, role, and permission checks, and applies dynamic object-level access rules.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Builds the WHERE clause for fetching the object and applies additional scoped filters if configured.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainGetOperation

Executes the database fetch, retrieves the object, and stores it in context for enrichment or further checks.


You can use the following settings to change some behavior of this step.
`selectClause`, `getOptions`
---




### [8] Step : checkInstance

Performs instance-level validations, such as ownership, existence, or access conditions.


---




### [9] Step : buildOutput

Assembles the response from the object, applies masking, formatting, and injects additional metadata if needed.


---




### [10] Step : sendResponse

Delivers the response to the controller for client delivery.


---




### [11] Step : raiseApiEvent

Triggers optional API-level events after workflow completion, sending messages to integrations like Kafka if configured.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `getInvoiceItem` api has got 1 regular client parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceItemId  | ID  | true | request.params?.["invoiceItemId"] |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/invoiceitems/:invoiceItemId**
```js
  axios({
    method: 'GET',
    url: `/v1/invoiceitems/${invoiceItemId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoiceItem`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID",
		"productOrService": {
			"currency": "String",
			"name": "String",
			"price": "Double",
			"sku": "String",
			"type": "Enum",
			"type_idx": "Integer",
			"vatRate": "Double"
		}
	}
}
```  

---

<a id="invoicemanagement-service-business-api-listinvoiceitems-api-design"></a>

### Business API Design Specification - `List Invoiceitems`


# Business API Design Specification - `List Invoiceitems`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `listInvoiceItems` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `listInvoiceItems` Business API is designed to handle a `list` operation on the `InvoiceItem` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

List all line items for given invoice or with filter. Used for invoice display, checks, audits. All business roles permitted to read within tenant scope.

## API Frontend Description By The Backend Architect

Present all invoice items for invoice details screen, permit search by invoice, product/service or description; paginate for large sets. Enable inline item addition (if permitted).

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `invoiceitems-listed` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `listInvoiceItems` Business API includes a REST controller that can be triggered via the following route:

`/v1/invoiceitems`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `listInvoiceItems` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `listInvoiceItems` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.


### Filter Parameters

The `listInvoiceItems` api supports 1 optional filter parameter for filtering list results using URL query parameters. These parameters are only available for `list` type APIs.

#### `invoiceId` Filter

**Type:** `ID`  
**Description:** Reference to parent invoice (ensures item belongs to this invoice).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property:**
- Single value: `?invoiceId=<value>`
- Multiple values: `?invoiceId=<value1>&invoiceId=<value2>`
- Null check: `?invoiceId=null`

**Examples:**
```javascript
// Get records with a specific ID
GET /v1/invoiceitems?invoiceId=550e8400-e29b-41d4-a716-446655440000

// Get records with multiple IDs (use multiple parameters)
GET /v1/invoiceitems?invoiceId=550e8400-e29b-41d4-a716-446655440000&invoiceId=660e8400-e29b-41d4-a716-446655440001

// Get records without this field
GET /v1/invoiceitems?invoiceId=null
```



  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `listInvoiceItems` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant`, `user]`




---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

``


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{businessId:this.businessId,isActive:true}
```









## List Options
Defines list-specific options including filtering logic, default sorting, and result customization for APIs that return multiple records.

**List Sort By**
Sort order definitions for the result set. Multiple fields can be provided with direction (asc/desc).

[ createdAt asc ]


**List Group By**
Grouping definitions for the result set. This is typically used for visual or report-based grouping.

*The list is not grouped.*



**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.


**Permission Filter**
Optional filter that applies permission constraints dynamically based on session or object roles. So that the list items are filtered by the user's OBAC or ABAC permissions.

*Permission filter is not active at the moment. Follow Mindbricks updates to be able to use it.*

## Pagination Options
Contains settings to configure pagination behavior for `list` APIs. Includes options like page size, offset, cursor support, and total count inclusion.



   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Reads request and Redis parameters, applies defaults, and writes them to context for downstream processing.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Transforms and normalizes parameters, derives dependent values, and reshapes inputs for the main list query.


---




### [4] Step : checkParameters

Executes validation logic on required and custom parameters, enforcing business rules and cross-field consistency.


---




### [5] Step : checkBasicAuth

Performs role-based access checks and applies dynamic membership or session-based restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Constructs the main query WHERE clause and applies optional filters or scoped access controls.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainListOperation

Executes the paginated database query, retrieves the list, and stores results in context for enrichment.


You can use the following settings to change some behavior of this step.
`selectClause`, `listOptions`, `paginationOptions`
---




### [8] Step : buildOutput

Assembles the list response, sanitizes sensitive fields, applies transformations, and injects extra context if needed.


---




### [9] Step : sendResponse

Sends the paginated list to the client through the controller.


---




### [10] Step : raiseApiEvent

Triggers optional post-workflow events, such as Kafka messages, logs, or system notifications.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `listInvoiceItems` api has 1 filter parameter available for filtering list results. See the [Filter Parameters](#filter-parameters) section above for detailed usage examples.

| Filter Parameter       | Type                   | Array Property | Description                   |
| ---------------------- | ---------------------- | -------------- | ----------------------------- |
| invoiceId  | ID  | No | Reference to parent invoice (ensures item belongs to this invoice). |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/invoiceitems**
```js
  axios({
    method: 'GET',
    url: '/v1/invoiceitems',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section for usage examples)
        // invoiceId: '<value>' // Filter by invoiceId
            }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoiceItems`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItems",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoiceItems": [
		{
			"id": "ID",
			"description": "String",
			"invoiceId": "ID",
			"productOrServiceId": "ID",
			"quantity": "Double",
			"total": "Double",
			"unitPrice": "Double",
			"vatAmount": "Double",
			"vatRate": "Double",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"productOrService": [
				{
					"currency": "String",
					"name": "String",
					"price": "Double",
					"sku": "String",
					"type": "Enum",
					"type_idx": "Integer",
					"vatRate": "Double"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```  

---

<a id="invoicemanagement-service-business-api-listinvoices-api-design"></a>

### Business API Design Specification - `List Invoices`


# Business API Design Specification - `List Invoices`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `listInvoices` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `listInvoices` Business API is designed to handle a `list` operation on the `Invoice` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

List/search invoices for the current business, with filtering by type, date, partner, and status. All business users may view within context.

## API Frontend Description By The Backend Architect

Show invoice list with filtering/search by type, partner, status, date range (on issueDate/dueDate). Display summary fields and enable quick navigation to invoice details or edit (if permitted).

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `invoices-listed` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `listInvoices` Business API includes a REST controller that can be triggered via the following route:

`/v1/invoices`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `listInvoices` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `listInvoices` Business API has 7 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.


### Filter Parameters

The `listInvoices` api supports 7 optional filter parameters for filtering list results using URL query parameters. These parameters are only available for `list` type APIs.

#### `customerId` Filter

**Type:** `ID`  
**Description:** Referenced customer (for sales invoice; null for purchase invoice).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property:**
- Single value: `?customerId=<value>`
- Multiple values: `?customerId=<value1>&customerId=<value2>`
- Null check: `?customerId=null`

**Examples:**
```javascript
// Get records with a specific ID
GET /v1/invoices?customerId=550e8400-e29b-41d4-a716-446655440000

// Get records with multiple IDs (use multiple parameters)
GET /v1/invoices?customerId=550e8400-e29b-41d4-a716-446655440000&customerId=660e8400-e29b-41d4-a716-446655440001

// Get records without this field
GET /v1/invoices?customerId=null
```



#### `dueDate` Filter

**Type:** `Date`  
**Description:** Date by which payment for this invoice is due.  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Date filtering matches records where the date falls within the specified day, ignoring time portion):**
- Single date: `?dueDate=2024-01-15`
- Multiple dates: `?dueDate=2024-01-15&dueDate=2024-01-20`
- Special operators: `?dueDate=$today`, `?dueDate=$week`, `?dueDate=$month`
- Local timezone: `?dueDate=$ltoday`, `?dueDate=$lweek`, `?dueDate=$leq-2024-01-15`, `?dueDate=$lin-2024-01-15&dueDate=$lin-2024-01-20`
- Null check: `?dueDate=null`

**Special Date Operators:**
- `$today` - Today (server timezone)
- `$ltoday` - Today (user's local timezone)
- `$week` - This week (server timezone)
- `$lweek` - This week (user's local timezone)
- `$month` - This month (server timezone)
- `$leq-<date>` - Specific date (user's local timezone)
- `$lin-<date>` - Date in array (user's local timezone, use multiple parameters)

**Date Formats:**
Dates can be provided in ISO 8601 format (`2024-01-15`, `2024-01-15T10:30:00Z`) or as timestamps (`1705324800000`).

**Examples:**
```javascript
// Get records created on a specific date
GET /v1/invoices?dueDate=2024-01-15

// Get records created on multiple dates (use multiple parameters)
GET /v1/invoices?dueDate=2024-01-15&dueDate=2024-01-20

// Get records created today (server timezone)
GET /v1/invoices?dueDate=$today

// Get records created today (user's local timezone)
GET /v1/invoices?dueDate=$ltoday

// Get records created this week (server timezone)
GET /v1/invoices?dueDate=$week

// Get records created this week (user's local timezone)
GET /v1/invoices?dueDate=$lweek

// Get records created this month
GET /v1/invoices?dueDate=$month

// Get records created on a specific date (user's local timezone)
GET /v1/invoices?dueDate=$leq-2024-01-15

// Get records created on multiple dates (user's local timezone, use multiple parameters)
GET /v1/invoices?dueDate=$lin-2024-01-15&dueDate=$lin-2024-01-20

// Get records without this field
GET /v1/invoices?dueDate=null
```


#### `invoiceNumber` Filter

**Type:** `String`  
**Description:** A unique identifier (number/code) for this invoice within a business.  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Case-Insensitive Partial Matching):**
- Single value: `?invoiceNumber=<value>` (matches any string containing the value, case-insensitive)
- Multiple values: `?invoiceNumber=<value1>&invoiceNumber=<value2>` (matches records containing any of the values)
- Null check: `?invoiceNumber=null`

**Examples:**
```javascript
// Find records with "john" in the field (case-insensitive partial match)
GET /v1/invoices?invoiceNumber=john
// Matches: "John", "Johnny", "johnson", "McJohn", etc.

// Find records with multiple values (use multiple parameters)
GET /v1/invoices?invoiceNumber=laptop&invoiceNumber=phone&invoiceNumber=tablet
// Matches records containing "laptop", "phone", or "tablet" anywhere in the field

// Find records without this field
GET /v1/invoices?invoiceNumber=null
```


#### `issueDate` Filter

**Type:** `Date`  
**Description:** Date this invoice was issued.  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Date filtering matches records where the date falls within the specified day, ignoring time portion):**
- Single date: `?issueDate=2024-01-15`
- Multiple dates: `?issueDate=2024-01-15&issueDate=2024-01-20`
- Special operators: `?issueDate=$today`, `?issueDate=$week`, `?issueDate=$month`
- Local timezone: `?issueDate=$ltoday`, `?issueDate=$lweek`, `?issueDate=$leq-2024-01-15`, `?issueDate=$lin-2024-01-15&issueDate=$lin-2024-01-20`
- Null check: `?issueDate=null`

**Special Date Operators:**
- `$today` - Today (server timezone)
- `$ltoday` - Today (user's local timezone)
- `$week` - This week (server timezone)
- `$lweek` - This week (user's local timezone)
- `$month` - This month (server timezone)
- `$leq-<date>` - Specific date (user's local timezone)
- `$lin-<date>` - Date in array (user's local timezone, use multiple parameters)

**Date Formats:**
Dates can be provided in ISO 8601 format (`2024-01-15`, `2024-01-15T10:30:00Z`) or as timestamps (`1705324800000`).

**Examples:**
```javascript
// Get records created on a specific date
GET /v1/invoices?issueDate=2024-01-15

// Get records created on multiple dates (use multiple parameters)
GET /v1/invoices?issueDate=2024-01-15&issueDate=2024-01-20

// Get records created today (server timezone)
GET /v1/invoices?issueDate=$today

// Get records created today (user's local timezone)
GET /v1/invoices?issueDate=$ltoday

// Get records created this week (server timezone)
GET /v1/invoices?issueDate=$week

// Get records created this week (user's local timezone)
GET /v1/invoices?issueDate=$lweek

// Get records created this month
GET /v1/invoices?issueDate=$month

// Get records created on a specific date (user's local timezone)
GET /v1/invoices?issueDate=$leq-2024-01-15

// Get records created on multiple dates (user's local timezone, use multiple parameters)
GET /v1/invoices?issueDate=$lin-2024-01-15&issueDate=$lin-2024-01-20

// Get records without this field
GET /v1/invoices?issueDate=null
```


#### `status` Filter

**Type:** `Enum`  
**Description:** Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate.  
**Location:** Query Parameter

**Usage:**

- Single value: `?status=<value>` (case-insensitive)
- Multiple values: `?status=<value1>&status=<value2>`
- Null check: `?status=null`

**Examples:**
```javascript
// Get records with specific enum value
GET /v1/invoices?status=active

// Get records with multiple enum values (use multiple parameters)
GET /v1/invoices?status=active&status=pending

// Get records without this field
GET /v1/invoices?status=null
```



#### `supplierId` Filter

**Type:** `ID`  
**Description:** Referenced supplier (for purchase invoice; null for sales invoice).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property:**
- Single value: `?supplierId=<value>`
- Multiple values: `?supplierId=<value1>&supplierId=<value2>`
- Null check: `?supplierId=null`

**Examples:**
```javascript
// Get records with a specific ID
GET /v1/invoices?supplierId=550e8400-e29b-41d4-a716-446655440000

// Get records with multiple IDs (use multiple parameters)
GET /v1/invoices?supplierId=550e8400-e29b-41d4-a716-446655440000&supplierId=660e8400-e29b-41d4-a716-446655440001

// Get records without this field
GET /v1/invoices?supplierId=null
```



#### `type` Filter

**Type:** `Enum`  
**Description:** Invoice nature; 'sales'=outgoing, 'purchase'=incoming.  
**Location:** Query Parameter

**Usage:**

- Single value: `?type=<value>` (case-insensitive)
- Multiple values: `?type=<value1>&type=<value2>`
- Null check: `?type=null`

**Examples:**
```javascript
// Get records with specific enum value
GET /v1/invoices?type=active

// Get records with multiple enum values (use multiple parameters)
GET /v1/invoices?type=active&type=pending

// Get records without this field
GET /v1/invoices?type=null
```



  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `listInvoices` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant`, `user]`




---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

``


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{businessId:this.businessId,isActive:true}
```









## List Options
Defines list-specific options including filtering logic, default sorting, and result customization for APIs that return multiple records.

**List Sort By**
Sort order definitions for the result set. Multiple fields can be provided with direction (asc/desc).

[ issueDate desc ]


**List Group By**
Grouping definitions for the result set. This is typically used for visual or report-based grouping.

*The list is not grouped.*



**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.


**Permission Filter**
Optional filter that applies permission constraints dynamically based on session or object roles. So that the list items are filtered by the user's OBAC or ABAC permissions.

*Permission filter is not active at the moment. Follow Mindbricks updates to be able to use it.*

## Pagination Options
Contains settings to configure pagination behavior for `list` APIs. Includes options like page size, offset, cursor support, and total count inclusion.



   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Reads request and Redis parameters, applies defaults, and writes them to context for downstream processing.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Transforms and normalizes parameters, derives dependent values, and reshapes inputs for the main list query.


---




### [4] Step : checkParameters

Executes validation logic on required and custom parameters, enforcing business rules and cross-field consistency.


---




### [5] Step : checkBasicAuth

Performs role-based access checks and applies dynamic membership or session-based restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Constructs the main query WHERE clause and applies optional filters or scoped access controls.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainListOperation

Executes the paginated database query, retrieves the list, and stores results in context for enrichment.


You can use the following settings to change some behavior of this step.
`selectClause`, `listOptions`, `paginationOptions`
---




### [8] Step : buildOutput

Assembles the list response, sanitizes sensitive fields, applies transformations, and injects extra context if needed.


---




### [9] Step : sendResponse

Sends the paginated list to the client through the controller.


---




### [10] Step : raiseApiEvent

Triggers optional post-workflow events, such as Kafka messages, logs, or system notifications.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `listInvoices` api has 7 filter parameters available for filtering list results. See the [Filter Parameters](#filter-parameters) section above for detailed usage examples.

| Filter Parameter       | Type                   | Array Property | Description                   |
| ---------------------- | ---------------------- | -------------- | ----------------------------- |
| customerId  | ID  | No | Referenced customer (for sales invoice; null for purchase invoice). |
| dueDate  | Date  | No | Date by which payment for this invoice is due. |
| invoiceNumber  | String  | No | A unique identifier (number/code) for this invoice within a business. |
| issueDate  | Date  | No | Date this invoice was issued. |
| status  | Enum  | No | Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate. |
| supplierId  | ID  | No | Referenced supplier (for purchase invoice; null for sales invoice). |
| type  | Enum  | No | Invoice nature; 'sales'=outgoing, 'purchase'=incoming. |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/invoices**
```js
  axios({
    method: 'GET',
    url: '/v1/invoices',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section for usage examples)
        // customerId: '<value>' // Filter by customerId
        // dueDate: '<value>' // Filter by dueDate
        // invoiceNumber: '<value>' // Filter by invoiceNumber
        // issueDate: '<value>' // Filter by issueDate
        // status: '<value>' // Filter by status
        // supplierId: '<value>' // Filter by supplierId
        // type: '<value>' // Filter by type
            }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoices`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoices",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoices": [
		{
			"id": "ID",
			"currency": "String",
			"customerId": "ID",
			"dueDate": "Date",
			"invoiceNumber": "String",
			"issueDate": "Date",
			"notes": "Text",
			"status": "Enum",
			"status_idx": "Integer",
			"supplierId": "ID",
			"totalAmount": "Double",
			"type": "Enum",
			"type_idx": "Integer",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"items": [
				{
					"description": "String",
					"quantity": "Double",
					"total": "Double",
					"unitPrice": "Double",
					"vatAmount": "Double",
					"vatRate": "Double"
				},
				{},
				{}
			],
			"customer": [
				{
					"contactEmail": "String",
					"contactName": "String",
					"name": "String"
				},
				{},
				{}
			],
			"supplier": [
				{
					"contactEmail": "String",
					"contactName": "String",
					"name": "String"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```  

---

<a id="invoicemanagement-service-business-api-updateinvoice-api-design"></a>

### Business API Design Specification - `Update Invoice`


# Business API Design Specification - `Update Invoice`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `updateInvoice` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `updateInvoice` Business API is designed to handle a `update` operation on the `Invoice` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Update invoice details (e.g., dates, partner, notes); recalculate totals and enforce type/partner links. Owner/Accountant only.

## API Frontend Description By The Backend Architect

Allow editing of fields except invoice type. Changing partner: must match rules (sales: customer; purchase: supplier). Totals always refresh after updating. No direct status edit; status recalculated on payment update.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `invoice-updated` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `updateInvoice` Business API includes a REST controller that can be triggered via the following route:

`/v1/invoices/:invoiceId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `updateInvoice` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `updateInvoice` Business API has 8 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceId`                             | `ID`   | `Yes` | `-` | `urlpath` | `invoiceId` |
| **Description:**                                | This id paremeter is used to select the required data object that will be updated |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `currency`                             | `String`   | `Yes` | `-` | `body` | `currency` |
| **Description:**                                | Currency code for all values in invoice and its items (e.g., 'USD'). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `customerId`                             | `ID`   | `No` | `-` | `body` | `customerId` |
| **Description:**                                | Referenced customer (for sales invoice; null for purchase invoice). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `dueDate`                             | `Date`   | `Yes` | `-` | `body` | `dueDate` |
| **Description:**                                | Date by which payment for this invoice is due. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceNumber`                             | `String`   | `Yes` | `-` | `body` | `invoiceNumber` |
| **Description:**                                | A unique identifier (number/code) for this invoice within a business. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `issueDate`                             | `Date`   | `Yes` | `-` | `body` | `issueDate` |
| **Description:**                                | Date this invoice was issued. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `notes`                             | `Text`   | `No` | `-` | `body` | `notes` |
| **Description:**                                | Internal notes about the invoice, never publicly exposed. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `supplierId`                             | `ID`   | `No` | `-` | `body` | `supplierId` |
| **Description:**                                | Referenced supplier (for purchase invoice; null for sales invoice). |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `updateInvoice` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant]`




---



## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.invoiceId},{businessId:this.businessId,isActive:true}]}
```




## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 


An update data clause populates all update-allowed properties of a data object, however the null properties (that are not provided by client) are ignored in db layer.


**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  currency: this.currency,
  customerId: this.customerId,
  dueDate: this.dueDate,
  invoiceNumber: this.invoiceNumber,
  issueDate: this.issueDate,
  notes: this.notes,
  supplierId: this.supplierId,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, prepares request and session objects, and sets up internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads parameters from the request or Redis, applies defaults, and writes them into context for downstream milestones.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager executes parameter transform scripts and derives any helper values or reshaped payloads into the context.


---




### [4] Step : checkParameters

Manager validates required parameters, checks ID formats (UUID/ObjectId), and ensures all preconditions for update are met.


---




### [5] Step : checkBasicAuth

Manager performs login verification, role, and permission checks, enforcing tenant and access rules before update.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Manager constructs the WHERE clause used to identify the record to update, applying ownership and parent checks if necessary.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : fetchInstance

Manager fetches the existing record from the database and writes it to the context for validation or enrichment.


---




### [8] Step : checkInstance

Manager performs instance-level validations, including ownership, existence, lock status, or other pre-update checks.


---




### [9] Step : buildDataClause

Manager prepares the data clause for the update, applying transformations or enhancements before persisting.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [10] Step : mainUpdateOperation

Manager executes the update operation with the WHERE and data clauses. Database-level events are raised if configured.


---




### [11] Step : buildOutput

Manager assembles the response object from the update result, masking fields or injecting additional metadata.


---




### [12] Step : sendResponse

Manager sends the response back to the controller for delivery to the client.


---




### [13] Step : raiseApiEvent

Manager triggers API-level events, sending relevant messages to Kafka or other integrations if configured.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `updateInvoice` api has got 8 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceId  | ID  | true | request.params?.["invoiceId"] |
| currency  | String  | true | request.body?.["currency"] |
| customerId  | ID  | false | request.body?.["customerId"] |
| dueDate  | Date  | true | request.body?.["dueDate"] |
| invoiceNumber  | String  | true | request.body?.["invoiceNumber"] |
| issueDate  | Date  | true | request.body?.["issueDate"] |
| notes  | Text  | false | request.body?.["notes"] |
| supplierId  | ID  | false | request.body?.["supplierId"] |

### REST Request
To access the api you can use the **REST** controller with the path **PATCH  /v1/invoices/:invoiceId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/invoices/${invoiceId}`,
    data: {
            currency:"String",  
            customerId:"ID",  
            dueDate:"Date",  
            invoiceNumber:"String",  
            issueDate:"Date",  
            notes:"Text",  
            supplierId:"ID",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoice`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoice",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"invoice": {
		"id": "ID",
		"currency": "String",
		"customerId": "ID",
		"dueDate": "Date",
		"invoiceNumber": "String",
		"issueDate": "Date",
		"notes": "Text",
		"status": "Enum",
		"status_idx": "Integer",
		"supplierId": "ID",
		"totalAmount": "Double",
		"type": "Enum",
		"type_idx": "Integer",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="invoicemanagement-service-business-api-updateinvoiceitem-api-design"></a>

### Business API Design Specification - `Update Invoiceitem`


# Business API Design Specification - `Update Invoiceitem`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `updateInvoiceItem` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `updateInvoiceItem` Business API is designed to handle a `update` operation on the `InvoiceItem` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Update an existing invoice line item (description, quantity, unit price, VAT). Owner/Accountant only.

## API Frontend Description By The Backend Architect

Editable fields: description, quantity, unitPrice, vatRate. Totals/VAT recalc on any change. Editing productOrServiceId updates downstream values. UI should limit changes if invoice is paid/partial/overdue.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `invoiceitem-updated` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `updateInvoiceItem` Business API includes a REST controller that can be triggered via the following route:

`/v1/invoiceitems/:invoiceItemId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `updateInvoiceItem` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `updateInvoiceItem` Business API has 6 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceItemId`                             | `ID`   | `Yes` | `-` | `urlpath` | `invoiceItemId` |
| **Description:**                                | This id paremeter is used to select the required data object that will be updated |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `description`                             | `String`   | `No` | `-` | `body` | `description` |
| **Description:**                                | Optional text/override for item description (default: product/service name). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `productOrServiceId`                             | `ID`   | `Yes` | `-` | `body` | `productOrServiceId` |
| **Description:**                                | Reference to product/service used in this line item. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `quantity`                             | `Double`   | `Yes` | `-` | `body` | `quantity` |
| **Description:**                                | Quantity of product/service being invoiced. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `unitPrice`                             | `Double`   | `Yes` | `-` | `body` | `unitPrice` |
| **Description:**                                | The (net) unit price for this item (auto-fetched from product/service at time of insert, overridable). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `vatRate`                             | `Double`   | `Yes` | `-` | `body` | `vatRate` |
| **Description:**                                | VAT rate (%) applied for this item (auto-fetched from product/service, overridable if allowed). |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `updateInvoiceItem` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, accountant, tenantOwner, superAdmin]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant]`




---



## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.invoiceItemId},{businessId:this.businessId,isActive:true}]}
```




## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 


An update data clause populates all update-allowed properties of a data object, however the null properties (that are not provided by client) are ignored in db layer.


**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  description: this.description,
  productOrServiceId: this.productOrServiceId,
  quantity: this.quantity,
  unitPrice: this.unitPrice,
  vatRate: this.vatRate,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, prepares request and session objects, and sets up internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads parameters from the request or Redis, applies defaults, and writes them into context for downstream milestones.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager executes parameter transform scripts and derives any helper values or reshaped payloads into the context.


---




### [4] Step : checkParameters

Manager validates required parameters, checks ID formats (UUID/ObjectId), and ensures all preconditions for update are met.


---




### [5] Step : checkBasicAuth

Manager performs login verification, role, and permission checks, enforcing tenant and access rules before update.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Manager constructs the WHERE clause used to identify the record to update, applying ownership and parent checks if necessary.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : fetchInstance

Manager fetches the existing record from the database and writes it to the context for validation or enrichment.


---




### [8] Step : checkInstance

Manager performs instance-level validations, including ownership, existence, lock status, or other pre-update checks.


---




### [9] Step : buildDataClause

Manager prepares the data clause for the update, applying transformations or enhancements before persisting.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [10] Step : mainUpdateOperation

Manager executes the update operation with the WHERE and data clauses. Database-level events are raised if configured.


---




### [11] Step : buildOutput

Manager assembles the response object from the update result, masking fields or injecting additional metadata.


---




### [12] Step : sendResponse

Manager sends the response back to the controller for delivery to the client.


---




### [13] Step : raiseApiEvent

Manager triggers API-level events, sending relevant messages to Kafka or other integrations if configured.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `updateInvoiceItem` api has got 3 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| invoiceItemId  | ID  | true | request.params?.["invoiceItemId"] |
| productOrServiceId  | ID  | true | request.body?.["productOrServiceId"] |
| quantity  | Double  | true | request.body?.["quantity"] |

### REST Request
To access the api you can use the **REST** controller with the path **PATCH  /v1/invoiceitems/:invoiceItemId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/invoiceitems/${invoiceItemId}`,
    data: {
            productOrServiceId:"ID",  
            quantity:"Double",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoiceItem`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItem",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"invoiceItem": {
		"id": "ID",
		"description": "String",
		"invoiceId": "ID",
		"productOrServiceId": "ID",
		"quantity": "Double",
		"total": "Double",
		"unitPrice": "Double",
		"vatAmount": "Double",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="invoicemanagement-service-business-api--fetchlistinvoice-api-design"></a>

### Business API Design Specification - `_fetch Listinvoice`


# Business API Design Specification - `_fetch Listinvoice`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `_fetchListInvoice` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `_fetchListInvoice` Business API is designed to handle a `list` operation on the `Invoice` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

System API to fetch list of invoice records for frontend application. Auto-generated, not visible in design.


## API Options 

* **Auto Params** : `false`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `false`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `_fetchListInvoice` Business API includes a REST controller that can be triggered via the following route:

`/v1/_fetchlistinvoice`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `_fetchListInvoice` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `_fetchListInvoice` Business API has 7 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.


### Filter Parameters

The `_fetchListInvoice` api supports 7 optional filter parameters for filtering list results using URL query parameters. These parameters are only available for `list` type APIs.

#### `customerId` Filter

**Type:** `ID`  
**Description:** Referenced customer (for sales invoice; null for purchase invoice).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property:**
- Single value: `?customerId=<value>`
- Multiple values: `?customerId=<value1>&customerId=<value2>`
- Null check: `?customerId=null`

**Examples:**
```javascript
// Get records with a specific ID
GET /v1/_fetchlistinvoice?customerId=550e8400-e29b-41d4-a716-446655440000

// Get records with multiple IDs (use multiple parameters)
GET /v1/_fetchlistinvoice?customerId=550e8400-e29b-41d4-a716-446655440000&customerId=660e8400-e29b-41d4-a716-446655440001

// Get records without this field
GET /v1/_fetchlistinvoice?customerId=null
```



#### `dueDate` Filter

**Type:** `Date`  
**Description:** Date by which payment for this invoice is due.  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Date filtering matches records where the date falls within the specified day, ignoring time portion):**
- Single date: `?dueDate=2024-01-15`
- Multiple dates: `?dueDate=2024-01-15&dueDate=2024-01-20`
- Special operators: `?dueDate=$today`, `?dueDate=$week`, `?dueDate=$month`
- Local timezone: `?dueDate=$ltoday`, `?dueDate=$lweek`, `?dueDate=$leq-2024-01-15`, `?dueDate=$lin-2024-01-15&dueDate=$lin-2024-01-20`
- Null check: `?dueDate=null`

**Special Date Operators:**
- `$today` - Today (server timezone)
- `$ltoday` - Today (user's local timezone)
- `$week` - This week (server timezone)
- `$lweek` - This week (user's local timezone)
- `$month` - This month (server timezone)
- `$leq-<date>` - Specific date (user's local timezone)
- `$lin-<date>` - Date in array (user's local timezone, use multiple parameters)

**Date Formats:**
Dates can be provided in ISO 8601 format (`2024-01-15`, `2024-01-15T10:30:00Z`) or as timestamps (`1705324800000`).

**Examples:**
```javascript
// Get records created on a specific date
GET /v1/_fetchlistinvoice?dueDate=2024-01-15

// Get records created on multiple dates (use multiple parameters)
GET /v1/_fetchlistinvoice?dueDate=2024-01-15&dueDate=2024-01-20

// Get records created today (server timezone)
GET /v1/_fetchlistinvoice?dueDate=$today

// Get records created today (user's local timezone)
GET /v1/_fetchlistinvoice?dueDate=$ltoday

// Get records created this week (server timezone)
GET /v1/_fetchlistinvoice?dueDate=$week

// Get records created this week (user's local timezone)
GET /v1/_fetchlistinvoice?dueDate=$lweek

// Get records created this month
GET /v1/_fetchlistinvoice?dueDate=$month

// Get records created on a specific date (user's local timezone)
GET /v1/_fetchlistinvoice?dueDate=$leq-2024-01-15

// Get records created on multiple dates (user's local timezone, use multiple parameters)
GET /v1/_fetchlistinvoice?dueDate=$lin-2024-01-15&dueDate=$lin-2024-01-20

// Get records without this field
GET /v1/_fetchlistinvoice?dueDate=null
```


#### `invoiceNumber` Filter

**Type:** `String`  
**Description:** A unique identifier (number/code) for this invoice within a business.  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Case-Insensitive Partial Matching):**
- Single value: `?invoiceNumber=<value>` (matches any string containing the value, case-insensitive)
- Multiple values: `?invoiceNumber=<value1>&invoiceNumber=<value2>` (matches records containing any of the values)
- Null check: `?invoiceNumber=null`

**Examples:**
```javascript
// Find records with "john" in the field (case-insensitive partial match)
GET /v1/_fetchlistinvoice?invoiceNumber=john
// Matches: "John", "Johnny", "johnson", "McJohn", etc.

// Find records with multiple values (use multiple parameters)
GET /v1/_fetchlistinvoice?invoiceNumber=laptop&invoiceNumber=phone&invoiceNumber=tablet
// Matches records containing "laptop", "phone", or "tablet" anywhere in the field

// Find records without this field
GET /v1/_fetchlistinvoice?invoiceNumber=null
```


#### `issueDate` Filter

**Type:** `Date`  
**Description:** Date this invoice was issued.  
**Location:** Query Parameter

**Usage:**

**Non-Array Property (Date filtering matches records where the date falls within the specified day, ignoring time portion):**
- Single date: `?issueDate=2024-01-15`
- Multiple dates: `?issueDate=2024-01-15&issueDate=2024-01-20`
- Special operators: `?issueDate=$today`, `?issueDate=$week`, `?issueDate=$month`
- Local timezone: `?issueDate=$ltoday`, `?issueDate=$lweek`, `?issueDate=$leq-2024-01-15`, `?issueDate=$lin-2024-01-15&issueDate=$lin-2024-01-20`
- Null check: `?issueDate=null`

**Special Date Operators:**
- `$today` - Today (server timezone)
- `$ltoday` - Today (user's local timezone)
- `$week` - This week (server timezone)
- `$lweek` - This week (user's local timezone)
- `$month` - This month (server timezone)
- `$leq-<date>` - Specific date (user's local timezone)
- `$lin-<date>` - Date in array (user's local timezone, use multiple parameters)

**Date Formats:**
Dates can be provided in ISO 8601 format (`2024-01-15`, `2024-01-15T10:30:00Z`) or as timestamps (`1705324800000`).

**Examples:**
```javascript
// Get records created on a specific date
GET /v1/_fetchlistinvoice?issueDate=2024-01-15

// Get records created on multiple dates (use multiple parameters)
GET /v1/_fetchlistinvoice?issueDate=2024-01-15&issueDate=2024-01-20

// Get records created today (server timezone)
GET /v1/_fetchlistinvoice?issueDate=$today

// Get records created today (user's local timezone)
GET /v1/_fetchlistinvoice?issueDate=$ltoday

// Get records created this week (server timezone)
GET /v1/_fetchlistinvoice?issueDate=$week

// Get records created this week (user's local timezone)
GET /v1/_fetchlistinvoice?issueDate=$lweek

// Get records created this month
GET /v1/_fetchlistinvoice?issueDate=$month

// Get records created on a specific date (user's local timezone)
GET /v1/_fetchlistinvoice?issueDate=$leq-2024-01-15

// Get records created on multiple dates (user's local timezone, use multiple parameters)
GET /v1/_fetchlistinvoice?issueDate=$lin-2024-01-15&issueDate=$lin-2024-01-20

// Get records without this field
GET /v1/_fetchlistinvoice?issueDate=null
```


#### `status` Filter

**Type:** `Enum`  
**Description:** Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate.  
**Location:** Query Parameter

**Usage:**

- Single value: `?status=<value>` (case-insensitive)
- Multiple values: `?status=<value1>&status=<value2>`
- Null check: `?status=null`

**Examples:**
```javascript
// Get records with specific enum value
GET /v1/_fetchlistinvoice?status=active

// Get records with multiple enum values (use multiple parameters)
GET /v1/_fetchlistinvoice?status=active&status=pending

// Get records without this field
GET /v1/_fetchlistinvoice?status=null
```



#### `supplierId` Filter

**Type:** `ID`  
**Description:** Referenced supplier (for purchase invoice; null for sales invoice).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property:**
- Single value: `?supplierId=<value>`
- Multiple values: `?supplierId=<value1>&supplierId=<value2>`
- Null check: `?supplierId=null`

**Examples:**
```javascript
// Get records with a specific ID
GET /v1/_fetchlistinvoice?supplierId=550e8400-e29b-41d4-a716-446655440000

// Get records with multiple IDs (use multiple parameters)
GET /v1/_fetchlistinvoice?supplierId=550e8400-e29b-41d4-a716-446655440000&supplierId=660e8400-e29b-41d4-a716-446655440001

// Get records without this field
GET /v1/_fetchlistinvoice?supplierId=null
```



#### `type` Filter

**Type:** `Enum`  
**Description:** Invoice nature; 'sales'=outgoing, 'purchase'=incoming.  
**Location:** Query Parameter

**Usage:**

- Single value: `?type=<value>` (case-insensitive)
- Multiple values: `?type=<value1>&type=<value2>`
- Null check: `?type=null`

**Examples:**
```javascript
// Get records with specific enum value
GET /v1/_fetchlistinvoice?type=active

// Get records with multiple enum values (use multiple parameters)
GET /v1/_fetchlistinvoice?type=active&type=pending

// Get records without this field
GET /v1/_fetchlistinvoice?type=null
```



  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `_fetchListInvoice` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[superAdmin`, `admin]`




---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

``


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{businessId:this.businessId,isActive:true}
```









## List Options
Defines list-specific options including filtering logic, default sorting, and result customization for APIs that return multiple records.

**List Sort By**
Sort order definitions for the result set. Multiple fields can be provided with direction (asc/desc).

[ createdAt desc ]


**List Group By**
Grouping definitions for the result set. This is typically used for visual or report-based grouping.

*The list is not grouped.*



**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.


**Permission Filter**
Optional filter that applies permission constraints dynamically based on session or object roles. So that the list items are filtered by the user's OBAC or ABAC permissions.

*Permission filter is not active at the moment. Follow Mindbricks updates to be able to use it.*

## Pagination Options
Contains settings to configure pagination behavior for `list` APIs. Includes options like page size, offset, cursor support, and total count inclusion.



   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Reads request and Redis parameters, applies defaults, and writes them to context for downstream processing.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Transforms and normalizes parameters, derives dependent values, and reshapes inputs for the main list query.


---




### [4] Step : checkParameters

Executes validation logic on required and custom parameters, enforcing business rules and cross-field consistency.


---




### [5] Step : checkBasicAuth

Performs role-based access checks and applies dynamic membership or session-based restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Constructs the main query WHERE clause and applies optional filters or scoped access controls.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainListOperation

Executes the paginated database query, retrieves the list, and stores results in context for enrichment.


You can use the following settings to change some behavior of this step.
`selectClause`, `listOptions`, `paginationOptions`
---




### [8] Step : buildOutput

Assembles the list response, sanitizes sensitive fields, applies transformations, and injects extra context if needed.


---




### [9] Step : sendResponse

Sends the paginated list to the client through the controller.


---




### [10] Step : raiseApiEvent

Triggers optional post-workflow events, such as Kafka messages, logs, or system notifications.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `_fetchListInvoice` api has 7 filter parameters available for filtering list results. See the [Filter Parameters](#filter-parameters) section above for detailed usage examples.

| Filter Parameter       | Type                   | Array Property | Description                   |
| ---------------------- | ---------------------- | -------------- | ----------------------------- |
| customerId  | ID  | No | Referenced customer (for sales invoice; null for purchase invoice). |
| dueDate  | Date  | No | Date by which payment for this invoice is due. |
| invoiceNumber  | String  | No | A unique identifier (number/code) for this invoice within a business. |
| issueDate  | Date  | No | Date this invoice was issued. |
| status  | Enum  | No | Derived status of invoice: unpaid/partial/paid/overdue, based on payment records and dueDate. |
| supplierId  | ID  | No | Referenced supplier (for purchase invoice; null for sales invoice). |
| type  | Enum  | No | Invoice nature; 'sales'=outgoing, 'purchase'=incoming. |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistinvoice**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistinvoice',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section for usage examples)
        // customerId: '<value>' // Filter by customerId
        // dueDate: '<value>' // Filter by dueDate
        // invoiceNumber: '<value>' // Filter by invoiceNumber
        // issueDate: '<value>' // Filter by issueDate
        // status: '<value>' // Filter by status
        // supplierId: '<value>' // Filter by supplierId
        // type: '<value>' // Filter by type
            }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoices`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoices",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoices": [
		{
			"id": "ID",
			"currency": "String",
			"customerId": "ID",
			"dueDate": "Date",
			"invoiceNumber": "String",
			"issueDate": "Date",
			"notes": "Text",
			"status": "Enum",
			"status_idx": "Integer",
			"supplierId": "ID",
			"totalAmount": "Double",
			"type": "Enum",
			"type_idx": "Integer",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"customer": [
				{
					"address": "Text",
					"contactEmail": "String",
					"contactName": "String",
					"name": "String",
					"notes": "Text",
					"phone": "String",
					"taxNumber": "String",
					"businessId": "ID"
				},
				{},
				{}
			],
			"supplier": [
				{
					"address": "Text",
					"contactEmail": "String",
					"contactName": "String",
					"name": "String",
					"notes": "Text",
					"phone": "String",
					"taxNumber": "String"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```  

---

<a id="invoicemanagement-service-business-api--fetchlistinvoiceitem-api-design"></a>

### Business API Design Specification - `_fetch Listinvoiceitem`


# Business API Design Specification - `_fetch Listinvoiceitem`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `_fetchListInvoiceItem` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `_fetchListInvoiceItem` Business API is designed to handle a `list` operation on the `InvoiceItem` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

System API to fetch list of invoiceItem records for frontend application. Auto-generated, not visible in design.


## API Options 

* **Auto Params** : `false`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `false`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `_fetchListInvoiceItem` Business API includes a REST controller that can be triggered via the following route:

`/v1/_fetchlistinvoiceitem`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `_fetchListInvoiceItem` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `_fetchListInvoiceItem` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.


### Filter Parameters

The `_fetchListInvoiceItem` api supports 1 optional filter parameter for filtering list results using URL query parameters. These parameters are only available for `list` type APIs.

#### `invoiceId` Filter

**Type:** `ID`  
**Description:** Reference to parent invoice (ensures item belongs to this invoice).  
**Location:** Query Parameter

**Usage:**

**Non-Array Property:**
- Single value: `?invoiceId=<value>`
- Multiple values: `?invoiceId=<value1>&invoiceId=<value2>`
- Null check: `?invoiceId=null`

**Examples:**
```javascript
// Get records with a specific ID
GET /v1/_fetchlistinvoiceitem?invoiceId=550e8400-e29b-41d4-a716-446655440000

// Get records with multiple IDs (use multiple parameters)
GET /v1/_fetchlistinvoiceitem?invoiceId=550e8400-e29b-41d4-a716-446655440000&invoiceId=660e8400-e29b-41d4-a716-446655440001

// Get records without this field
GET /v1/_fetchlistinvoiceitem?invoiceId=null
```



  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `_fetchListInvoiceItem` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[superAdmin`, `admin]`




---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

``


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{businessId:this.businessId,isActive:true}
```









## List Options
Defines list-specific options including filtering logic, default sorting, and result customization for APIs that return multiple records.

**List Sort By**
Sort order definitions for the result set. Multiple fields can be provided with direction (asc/desc).

[ createdAt desc ]


**List Group By**
Grouping definitions for the result set. This is typically used for visual or report-based grouping.

*The list is not grouped.*



**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.


**Permission Filter**
Optional filter that applies permission constraints dynamically based on session or object roles. So that the list items are filtered by the user's OBAC or ABAC permissions.

*Permission filter is not active at the moment. Follow Mindbricks updates to be able to use it.*

## Pagination Options
Contains settings to configure pagination behavior for `list` APIs. Includes options like page size, offset, cursor support, and total count inclusion.



   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Reads request and Redis parameters, applies defaults, and writes them to context for downstream processing.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Transforms and normalizes parameters, derives dependent values, and reshapes inputs for the main list query.


---




### [4] Step : checkParameters

Executes validation logic on required and custom parameters, enforcing business rules and cross-field consistency.


---




### [5] Step : checkBasicAuth

Performs role-based access checks and applies dynamic membership or session-based restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Constructs the main query WHERE clause and applies optional filters or scoped access controls.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainListOperation

Executes the paginated database query, retrieves the list, and stores results in context for enrichment.


You can use the following settings to change some behavior of this step.
`selectClause`, `listOptions`, `paginationOptions`
---




### [8] Step : buildOutput

Assembles the list response, sanitizes sensitive fields, applies transformations, and injects extra context if needed.


---




### [9] Step : sendResponse

Sends the paginated list to the client through the controller.


---




### [10] Step : raiseApiEvent

Triggers optional post-workflow events, such as Kafka messages, logs, or system notifications.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `_fetchListInvoiceItem` api has 1 filter parameter available for filtering list results. See the [Filter Parameters](#filter-parameters) section above for detailed usage examples.

| Filter Parameter       | Type                   | Array Property | Description                   |
| ---------------------- | ---------------------- | -------------- | ----------------------------- |
| invoiceId  | ID  | No | Reference to parent invoice (ensures item belongs to this invoice). |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistinvoiceitem**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistinvoiceitem',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section for usage examples)
        // invoiceId: '<value>' // Filter by invoiceId
            }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`invoiceItems`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "invoiceItems",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"invoiceItems": [
		{
			"id": "ID",
			"description": "String",
			"invoiceId": "ID",
			"productOrServiceId": "ID",
			"quantity": "Double",
			"total": "Double",
			"unitPrice": "Double",
			"vatAmount": "Double",
			"vatRate": "Double",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID",
			"invoice": [
				{
					"currency": "String",
					"customerId": "ID",
					"dueDate": "Date",
					"invoiceNumber": "String",
					"issueDate": "Date",
					"notes": "Text",
					"status": "Enum",
					"status_idx": "Integer",
					"supplierId": "ID",
					"totalAmount": "Double",
					"type": "Enum",
					"type_idx": "Integer"
				},
				{},
				{}
			],
			"productOrService": [
				{
					"currency": "String",
					"description": "Text",
					"name": "String",
					"notes": "Text",
					"price": "Double",
					"sku": "String",
					"type": "Enum",
					"type_idx": "Integer",
					"vatRate": "Double"
				},
				{},
				{}
			]
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```  

---

# PaymentManagement Service

<a id="paymentmanagement-service-service-design"></a>

## Service Design Specification



# Service Design Specification
**fintrack-paymentmanagement-service** documentation
**Version:** `1.0.1`

## Scope

This document provides a structured architectural overview of the `paymentManagement` microservice, detailing its configuration, data model, authorization logic, business rules, and API design. It has been automatically generated based on the service definition within Mindbricks, ensuring that the information reflects the source of truth used during code generation and deployment.

The document is intended to serve multiple audiences:

* **Service architects** can use it to validate design decisions and ensure alignment with broader architectural goals.
* **Developers and maintainers** will find it useful for understanding the structure and behavior of the service, facilitating easier debugging, feature extension, and integration with other systems.
* **Stakeholders and reviewers** can use it to gain a clear understanding of the service's capabilities and domain logic.

> **Note for Frontend Developers**: While this document is valuable for understanding business logic and data interactions, please refer to the [Service API Documentation](#) for endpoint-level specifications and integration details.

> **Note for Backend Developers**: Since the code for this service is automatically generated by Mindbricks, you typically won't need to implement or modify it manually. However, this document is especially valuable when you're building other services—whether within Mindbricks or externally—that need to interact with or depend on this service. It provides a clear reference to the service's data contracts, business rules, and API structure, helping ensure compatibility and correct integration.



## `PaymentManagement` Service Settings [**Edit**](paymentmanagement/serviceSettings)

Handles recording and lifecycle management of payments for invoices or as general/unallocated entries. Ensures invoice payment state is synchronized after each payment operation, supports strict business (tenant) isolation, and underpins core financial workflows in FinTrack.

### Service Overview

This service is configured to listen for HTTP requests on port `3004`, 
serving both the main API interface and default administrative endpoints.

The following routes are available by default:

* **API Test Interface (API Face):** `/`
* **Swagger Documentation:** `/swagger`
* **Postman Collection Download:** `/getPostmanCollection`
* **Health Checks:** `/health` and `/admin/health`
* **Current Session Info:** `/currentuser`
* **Favicon:** `/favicon.ico`

The service uses a **PostgreSQL** database for data storage, with the database name set to `fintrack-paymentmanagement-service`.

This service is accessible via the following environment-specific URLs:

* **Preview:** `https://fintrack.prw.mindbricks.com/paymentmanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/paymentmanagement-api`
* **Production:** `https://fintrack.mindbricks.co/paymentmanagement-api`

                                 

### Authentication & Security
- **Login Required**: Yes

This service requires user authentication for access. It supports both JWT and RSA-based authentication mechanisms, ensuring secure user sessions and data integrity.
If a crud route also is configured to require login, 
it will check a valid JWT token in the request query/header/bearer/cookie. If the token is valid, it will extract the user information from the token and make the fetched session data available in the request context.

  
### Service Data Objects
The service uses a **PostgreSQL** database for data storage, with the database name set to `fintrack-paymentmanagement-service`.

Data deletion is managed using a **soft delete** strategy. Instead of removing records from the database, they are flagged as inactive by setting the `isActive` field to `false`.



| Object Name | Description | Public Access | Tenant Level  | 
|-------------|-------------|---------------| --------------| 
| `payment` | Represents any payment (linked to an invoice or general/unallocated) made or received by the business. Tracks linkage, amount, method, payer, and reference. Tenant-isolated. Triggers invoice status recalculation on changes. | accessProtected |  Yes | 




## payment Data Object

### Object Overview
**Description:** Represents any payment (linked to an invoice or general/unallocated) made or received by the business. Tracks linkage, amount, method, payer, and reference. Tenant-isolated. Triggers invoice status recalculation on changes.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessProtected — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.








### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `amount` | Double | Yes | The amount of the payment, in invoice or business operating currency. Must be positive and required. |
| `currency` | String | Yes | ISO currency code (e.g., &#39;USD&#39;, &#39;EUR&#39;) used for this payment. Must match business or invoice. Required. |
| `date` | Date | Yes | Date the payment was recorded. Used for reporting, filtering, and cash flow tracking. Required. |
| `invoiceId` | ID | No | Reference to the associated invoice (if payment is linked); null for general/unallocated payment. |
| `method` | String | No | Payment method (e.g., bank transfer, cash, card, cheque, online, etc). Free text; used for reporting/reconciliation. Optional. |
| `notes` | Text | No | Internal comments (operator notes, clarifications, etc.). Optional. |
| `payerName` | String | No | Name of the payer or payee (customer, vendor, or other party). Useful for general/unlinked payments. Optional, for tracking. |
| `reference` | String | No | Payment reference or transaction ID (for reconciliation with bank/etc). Optional. |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **amount**: 0.0
- **currency**: 'default'
- **date**: new Date()
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`amount` `currency` `date` `invoiceId` `method` `notes` `payerName` `reference`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

 

 

### Elastic Search Indexing

`amount` `currency` `date` `invoiceId` `method` `payerName` `reference` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`date` `invoiceId` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.




### Cache Select Properties

`date`

Cache select properties are used to collect data from Redis entity cache with a different key than the data object id.
This allows you to cache data that is not directly related to the data object id, but a frequently used filter.


### Secondary Key Properties

`invoiceId` `businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.


### Relation Properties

`invoiceId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **invoiceId**: ID
Relation to `invoice`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: No





### Filter Properties

`amount` `currency` `date` `invoiceId` `method` `reference` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **amount**: Double  has a filter named `amount`

- **currency**: String  has a filter named `currency`

- **date**: Date  has a filter named `date`

- **invoiceId**: ID  has a filter named `invoiceId`

- **method**: String  has a filter named `method`

- **reference**: String  has a filter named `reference`

- **businessId**: ID  has a filter named `businessId`







## Business Logic


paymentManagement has got 5 Business APIs to manage its internal and crud logic. 
For the details of each business API refer to its chapter.

* [Create Payment](/businessLogic/createpayment)

* [Delete Payment](/businessLogic/deletepayment)

* [Get Payment](/businessLogic/getpayment)

* [List Payments](/businessLogic/listpayments)

* [Update Payment](/businessLogic/updatepayment)



## Edge Controllers



### m2mCreatePayment

**Configuration:**
- **Function Name**: `m2mCreatePayment`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/payment/create`
- **Method**: 

---

### m2mBulkCreatePayment

**Configuration:**
- **Function Name**: `m2mBulkCreatePayment`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/payment/bulk-create`
- **Method**: 

---

### m2mUpdatePaymentById

**Configuration:**
- **Function Name**: `m2mUpdatePaymentById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/payment/update/:id`
- **Method**: 

---

### m2mDeletePaymentById

**Configuration:**
- **Function Name**: `m2mDeletePaymentById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/payment/delete/:id`
- **Method**: 

---

### m2mUpdatePaymentByQuery

**Configuration:**
- **Function Name**: `m2mUpdatePaymentByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/payment/update-by-query`
- **Method**: 

---

### m2mDeletePaymentByQuery

**Configuration:**
- **Function Name**: `m2mDeletePaymentByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/payment/delete-by-query`
- **Method**: 

---

### m2mUpdatePaymentByIdList

**Configuration:**
- **Function Name**: `m2mUpdatePaymentByIdList`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/payment/update-by-id-list`
- **Method**: 

---



---

## Service Library


### Functions

No general functions defined.


### Hook Functions

No hook functions defined.


### Edge Functions


#### m2mCreatePayment.js
```js
module.exports = async (request) => {
        const { createPayment } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const data = request.body?.data || request.data || request;
        const result = await createPayment(data, context);
        return { status: 200, content: result };
      }
```

#### m2mBulkCreatePayment.js
```js
module.exports = async (request) => {
        const { createBulkPayment } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataList = request.body?.dataList || request.dataList || (Array.isArray(request.body) ? request.body : [request.body]);
        if (!Array.isArray(dataList) || dataList.length === 0) {
          return { status: 400, message: "dataList must be a non-empty array" };
        }
        const result = await createBulkPayment(dataList, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdatePaymentById.js
```js
module.exports = async (request) => {
        const { updatePaymentById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.id) delete dataClause.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await updatePaymentById(id, dataClause, context);
        return { status: 200, content: result };
      }
```

#### m2mDeletePaymentById.js
```js
module.exports = async (request) => {
        const { deletePaymentById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await deletePaymentById(id, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdatePaymentByQuery.js
```js
module.exports = async (request) => {
        const { updatePaymentByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await updatePaymentByQuery(dataClause, query, context);
        return { status: 200, content: result };
      }
```

#### m2mDeletePaymentByQuery.js
```js
module.exports = async (request) => {
        const { deletePaymentByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await deletePaymentByQuery(query, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdatePaymentByIdList.js
```js
module.exports = async (request) => {
        const { updatePaymentByIdList } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const idList = request.body?.idList || request.idList || [];
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.idList) delete dataClause.idList;
        if (!Array.isArray(idList) || idList.length === 0) {
          return { status: 400, message: "idList must be a non-empty array" };
        }
        const result = await updatePaymentByIdList(idList, dataClause, context);
        return { status: 200, content: result };
      }
```



### Templates

No templates defined.


### Assets

No assets defined.


### Public Assets

No public assets defined.



---




### Event Emission


---

## Integration Patterns

## Deployment Considerations

### Environment Configuration
- **HTTP Port**: `3004`
- **Database Type**: MongoDB
- **Global Soft Delete**: Enabled




## Implementation Guidelines

### Development Workflow
1. **Data Model Implementation**: Generate database schema from data object definitions
2. **CRUD Route Generation**: Implement auto-generated routes with custom logic
3. **Custom Logic Integration**: Implement hook functions and edge functions
4. **Authentication Integration**: Configure with project-level authentication
5. **Testing**: Unit and integration testing for all components

### Code Generation Expectations
- **Database Schema**: Auto-generated from data objects and relationships
- **API Routes**: REST endpoints with customizable behavior
- **Validation Logic**: Input validation from property definitions
- **Access Control**: Authentication and authorization middleware

### Custom Code Integration Points
- **Hook Functions**: Lifecycle-specific custom logic
- **Edge Functions**: Full request/response control
- **Library Functions**: Reusable business logic
- **Templates**: Dynamic content rendering

### Testing Strategy

#### Unit Testing
- Test all custom library functions
- Test validation logic and business rules
- Test hook function implementations

#### Integration Testing
- Test API endpoints with authentication scenarios
- Test database operations and transactions
- Test external integrations
- Test event emission and Kafka integration

#### Performance Testing
- Load test high-traffic endpoints
- Test caching effectiveness
- Monitor database query performance
- Test scalability under load

---

## Appendices

### Data Type Reference
| Type | Description | Storage |
|------|-------------|---------|
| ID | Unique identifier | UUID (SQL) / ObjectID (NoSQL) |
| String | Short text (≤255 chars) | VARCHAR |
| Text | Long-form text | TEXT |
| Integer | 32-bit whole numbers | INT |
| Boolean | True/false values | BOOLEAN |
| Double | 64-bit floating point | DOUBLE |
| Float | 32-bit floating point | FLOAT |
| Short | 16-bit integers | SMALLINT |
| Object | JSON object | JSONB (PostgreSQL) / Object (MongoDB) |
| Date | ISO 8601 timestamp | TIMESTAMP |
| Enum | Fixed numeric values | SMALLINT with lookup |

### Enum Value Mappings

#### Request Locations
- `0`: Bearer token in Authorization header
- `1`: Cookie value
- `2`: Custom HTTP header
- `3`: Query parameter
- `4`: Request body property
- `5`: URL path parameter
- `6`: Session data
- `7`: Root request object

#### HTTP Methods
- `0`: GET
- `1`: POST
- `2`: PUT
- `3`: PATCH
- `4`: DELETE


### Edge Function Signature
```javascript
async function edgeFunction(request) {
  // Custom request processing
  // Return response object or throw error
  return {
    data: {},
    status: 200,
    message: "Success"
  };
}
```

---

*This document was generated from the service architecture definition and should be kept in sync with implementation changes.*

---

<a id="paymentmanagement-service-rest-api-guide"></a>

## REST API GUIDE 

 

# REST API GUIDE 
## fintrack-paymentmanagement-service
**Version:** `1.0.1`

Handles recording and lifecycle management of payments for invoices or as general/unallocated entries. Ensures invoice payment state is synchronized after each payment operation, supports strict business (tenant) isolation, and underpins core financial workflows in FinTrack.

## Architectural Design Credit and Contact Information

The architectural design of this microservice is credited to . 
For inquiries, feedback, or further information regarding the architecture, please direct your communication to:

Email: 

We encourage open communication and welcome any questions or discussions related to the architectural aspects of this microservice.

## Documentation Scope

Welcome to the official documentation for the PaymentManagement Service's REST API. This document is designed to provide a comprehensive guide to interfacing with our PaymentManagement Service exclusively through RESTful API endpoints.

**Intended Audience**

This documentation is intended for developers and integrators who are looking to interact with the PaymentManagement Service via HTTP requests for purposes such as creating, updating, deleting and querying PaymentManagement objects.

**Overview**

Within these pages, you will find detailed information on how to effectively utilize the REST API, including authentication methods, request and response formats, endpoint descriptions, and examples of common use cases.

Beyond REST
It's important to note that the PaymentManagement Service also supports alternative methods of interaction, such as gRPC and messaging via a Message Broker. These communication methods are beyond the scope of this document. For information regarding these protocols, please refer to their respective documentation.

## Authentication And Authorization

To ensure secure access to the PaymentManagement service's protected endpoints, a project-wide access token is required. This token serves as the primary method for authenticating requests to our service. However, it's important to note that access control varies across different routes:

**Protected API**: 
Certain API (routes) require specific authorization levels. Access to these routes is contingent upon the possession of a valid access token that meets the route-specific authorization criteria. Unauthorized requests to these routes will be rejected.

**Public API **: 
The service also includes public API (routes) that are accessible without authentication. These public endpoints are designed for open access and do not require an access token.

### Token Locations
When including your access token in a request, ensure it is placed in one of the following specified locations. The service will sequentially search these locations for the token, utilizing the first one it encounters.

| Location               | Token Name / Param Name      |
| ---------------------- | ---------------------------- |
| Query                  | access_token                 |
| Authorization Header   | Bearer                       |
| Header                 | fintrack-access-token|
| Header                 | fintrack-access-token-{businessCodename}|
| Cookie                 | fintrack-access-token-{businessCodename}|


Please ensure the token is correctly placed in one of these locations, using the appropriate label as indicated. The service prioritizes these locations in the order listed, processing the first token it successfully identifies.


## Api Definitions
This section outlines the API endpoints available within the PaymentManagement service. Each endpoint can receive parameters through various methods, meticulously described in the following definitions. It's important to understand the flexibility in how parameters can be included in requests to effectively interact with the PaymentManagement service.

This service is configured to listen for HTTP requests on port `3004`, 
serving both the main API interface and default administrative endpoints.

The following routes are available by default:

* **API Test Interface (API Face):** `/`
* **Swagger Documentation:** `/swagger`
* **Postman Collection Download:** `/getPostmanCollection`
* **Health Checks:** `/health` and `/admin/health`
* **Current Session Info:** `/currentuser`
* **Favicon:** `/favicon.ico`

This service is accessible via the following environment-specific URLs:

* **Preview:** `https://fintrack.prw.mindbricks.com/paymentmanagement-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/paymentmanagement-api`
* **Production:** `https://fintrack.mindbricks.co/paymentmanagement-api`

**Parameter Inclusion Methods:**
Parameters can be incorporated into API requests in several ways, each with its designated location. Understanding these methods is crucial for correctly constructing your requests:

**Query Parameters:** Included directly in the URL's query string.

**Path Parameters:** Embedded within the URL's path.

**Body Parameters:** Sent within the JSON body of the request.

**Session Parameters:** Automatically read from the session object. This method is used for parameters that are intrinsic to the user's session, such as userId. When using an API that involves session parameters, you can omit these from your request. The service will automatically bind them to the API layer, provided that a session is associated with your request.

**Note on Session Parameters:**
Session parameters represent a unique method of parameter inclusion, relying on the context of the user's session. A common example of a session parameter is userId, which the service automatically associates with your request when a session exists. This feature ensures seamless integration of user-specific data without manual input for each request.

By adhering to the specified parameter inclusion methods, you can effectively utilize the PaymentManagement service's API endpoints. For detailed information on each endpoint, including required parameters and their accepted locations, refer to the individual API definitions below.

### Common Parameters

The `PaymentManagement` service's business API support several common parameters designed to modify and enhance the behavior of API requests. These parameters are not individually listed in the API route definitions to avoid repetition. Instead, refer to this section to understand how to leverage these common behaviors across different routes. Note that all common parameters should be included in the query part of the URL.

### Supported Common Parameters:

- **getJoins (BOOLEAN)**: Controls whether to retrieve associated objects along with the main object. By default, `getJoins` is assumed to be `true`. Set it to `false` if you prefer to receive only the main fields of an object, excluding its associations.

- **excludeCQRS (BOOLEAN)**: Applicable only when `getJoins` is `true`. By default, `excludeCQRS` is set to `false`. Enabling this parameter (`true`) omits non-local associations, which are typically more resource-intensive as they require querying external services like ElasticSearch for additional information. Use this to optimize response times and resource usage.

- **requestId (String)**: Identifies a request to enable tracking through the service's log chain. A random hex string of 32 characters is assigned by default. If you wish to use a custom `requestId`, simply include it in your query parameters.

- **caching (BOOLEAN)**: Determines the use of caching for query API. By default, caching is enabled (`true`). To ensure the freshest data directly from the database, set this parameter to `false`, bypassing the cache.

- **cacheTTL (Integer)**: Specifies the Time-To-Live (TTL) for query caching, in seconds. This is particularly useful for adjusting the default caching duration (5 minutes) for `get list` queries. Setting a custom `cacheTTL` allows you to fine-tune the cache lifespan to meet your needs.

- **pageNumber (Integer)**: For paginated `get list` API's, this parameter selects which page of results to retrieve. The default is `1`, indicating the first page. To disable pagination and retrieve all results, set `pageNumber` to `0`.

- **pageRowCount (Integer)**: In conjunction with paginated API's, this parameter defines the number of records per page. The default value is `25`. Adjusting `pageRowCount` allows you to control the volume of data returned in a single request.

By utilizing these common parameters, you can tailor the behavior of API requests to suit your specific requirements, ensuring optimal performance and usability of the `PaymentManagement` service.


  ### Multi Tenant Architecture

  The `PaymentManagement` service operates within a multi tenant architecture.
  The service is designed to support multiple tenants, each with its distinct data and configuration. This architecture ensures that data is securely isolated between tenants, preventing unauthorized access and maintaining data integrity.
  The service tenant is called `business` and identified as `businessId`.
  Other than platform users like superAdmin, saasAdmin and saasUser that belong to the root tenant, the tenant creators(owners) and users will all be associated with an business tenant.
  When users login their scope will be isolated only to include one tenant data they below. So user may acces only this logined tennat through out the session. After loging in to e specific tenant, users should include the tenant id in their request to access the tenant data. In each request they may access different tenant data if they belong them. 


  #### Key Points:
  
  - **Tenant-Specific Requests**: It is imperative that each request specifies the tenant it pertains to. This is crucial because most API's are designed to interact exclusively with objects that are part of the specified tenant sandbox.
  - **User Distinction**: The requesting user must have a registration for that tenant. The service searches for a `business` specific token (cookie or bearer) using the provided `business`Id in the request header. Note that to be able to login and use multiple tenant's sites a user must register for them all.
  - **Request Header Parameter**: When making a request, include the desired `businessId` in the request header using the parameter name ``. This signals to the service which domain context to apply for the request processing. Alternatively, you can include the tenant id in the query parameters with the name `businessId`.
  - **Root Tenant**: As all multi tenant architectures this application also has a default root tenant which created automatically. If there is no tenant mark for the request, the request are assumed as to the root tenant. Root tenant is also the hub for registering tenant creating and their owner users. When users register themselves in the root tenant, an (business) will alos be created with the given data in the request body and the user will be asssociated with this new tenant record as the `tenantAdmin`. 
  - **Superadmin account**: A super admin account is created with the given credentials in the design so that there is an absolute user which has all rights in the root tenant and other tenants. This account is used to create and manage all other tenants in the system. 
    - **Tenant Registration**: The `PaymentManagement` service allows for the creation of new tenants only through admin account of the root tenant. So if a new business record is needed, the superadmin or admin roles of the root should create then new tenant and assign any user as the owner of it.
  
  #### Implementation:

  When the user logins there may be few ways for Mindbricks to recognize and set the tenant id in the session.
  1. Mindbricks will check the url of the login request if it matches tenant url.
  2. Mindbricks will check the `` has the tenant id.
  3. Mindbricks will check if the user is associated with a `business` in the data model.
  After you login a tenant successfully, ensure that your requests accurately target objects that fall within the tenant scope set during the login session.
  Ensure your requests are correctly formatted to include the domain sandbox information in the header. This enables the `PaymentManagement` service to accurately identify the domain context, facilitating proper access control and data management based on the user's permissions and the specified domain.  
  ```js
  axios({
    method: 'GET',
    headers: {
      '': 'Your-businessId-here'
    }
    url: "/someroutepath",
    data: {
      "someData":"someData"
    },
    params: {
      "aParam":"aParam"
    }
  });
  ````     
  By adhering to this domain sandbox model, the `PaymentManagement` service maintains a secure and organized structure for handling requests across different domains, ensuring that operations are performed within the correct contextual boundaries.

### Error Response

If a request encounters an issue, whether due to a logical fault or a technical problem, the service responds with a standardized JSON error structure. The HTTP status code within this response indicates the nature of the error, utilizing commonly recognized codes for clarity:

- **400 Bad Request**: The request was improperly formatted or contained invalid parameters, preventing the server from processing it.
- **401 Unauthorized**: The request lacked valid authentication credentials or the credentials provided do not grant access to the requested resource.
- **404 Not Found**: The requested resource was not found on the server.
- **500 Internal Server Error**: The server encountered an unexpected condition that prevented it from fulfilling the request.

Each error response is structured to provide meaningful insight into the problem, assisting in diagnosing and resolving issues efficiently.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```` 

### Object Structure of a Successfull Response

When the `PaymentManagement` service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope not only contains the data but also includes essential metadata, such as configuration details and pagination information, to enrich the response and provide context to the client.

**Key Characteristics of the Response Envelope:**

- **Data Presentation**: Depending on the nature of the request, the service returns either a single data object or an array of objects encapsulated within the JSON envelope.
  - **Creation and Update API**: These API routes return the unmodified (pure) form of the data object(s), without any associations to other data objects.
  - **Delete API**: Even though the data is removed from the database, the last known state of the data object(s) is returned in its pure form.
  - **Get Requests**: A single data object is returned in JSON format.
  - **Get List Requests**: An array of data objects is provided, reflecting a collection of resources.

- **Data Structure and Joins**: The complexity of the data structure in the response can vary based on the API's architectural design and the join options specified in the request. The architecture might inherently limit join operations, or they might be dynamically controlled through query parameters.
  - **Pure Data Forms**: In some cases, the response mirrors the exact structure found in the primary data table, without extensions.
  - **Extended Data Forms**: Alternatively, responses might include data extended through joins with tables within the same service or aggregated from external sources, such as ElasticSearch indices related to other services.
  - **Join Varieties**: The extensions might involve one-to-one joins, resulting in single object associations, or one-to-many joins, leading to an array of objects. In certain instances, the data might even feature nested inclusions from other data objects.

**Design Considerations**: The structure of a API's response data is meticulously crafted during the service's architectural planning. This design ensures that responses adequately reflect the intended data relationships and service logic, providing clients with rich and meaningful information.

**Brief Data**: Certain API's return a condensed version of the object data, intentionally selecting only specific fields deemed useful for that request. In such instances, the API documentation will detail the properties included in the response, guiding developers on what to expect.

### API Response Structure

The API utilizes a standardized JSON envelope to encapsulate responses. This envelope is designed to consistently deliver both the requested data and essential metadata, ensuring that clients can efficiently interpret and utilize the response.

**HTTP Status Codes:**

- **200 OK**: This status code is returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request has been processed successfully.
- **201 Created**: This status code is specific to CREATE operations, signifying that the requested resource has been successfully created.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling the successful execution of the request. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
````

- **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation performed.

**Handling Errors:**

For details on handling error scenarios and understanding the structure of error responses, please refer to the "Error Response" section provided earlier in this documentation. It outlines how error conditions are communicated, including the use of HTTP status codes and standardized JSON structures for error messages.

## Resources 
PaymentManagement service provides the following resources which are stored in its own database as a data object. Note that a resource for an api access is a data object for the service.

### Payment resource

*Resource Definition* : Represents any payment (linked to an invoice or general/unallocated) made or received by the business. Tracks linkage, amount, method, payer, and reference. Tenant-isolated. Triggers invoice status recalculation on changes.
*Payment Resource Properties* 
| Name | Type | Required | Default | Definition | 
| ---- | ---- | -------- | ------- | ---------- |
| **amount** | Double |  |  | *The amount of the payment, in invoice or business operating currency. Must be positive and required.* |
| **currency** | String |  |  | *ISO currency code (e.g., &#39;USD&#39;, &#39;EUR&#39;) used for this payment. Must match business or invoice. Required.* |
| **date** | Date |  |  | *Date the payment was recorded. Used for reporting, filtering, and cash flow tracking. Required.* |
| **invoiceId** | ID |  |  | *Reference to the associated invoice (if payment is linked); null for general/unallocated payment.* |
| **method** | String |  |  | *Payment method (e.g., bank transfer, cash, card, cheque, online, etc). Free text; used for reporting/reconciliation. Optional.* |
| **notes** | Text |  |  | *Internal comments (operator notes, clarifications, etc.). Optional.* |
| **payerName** | String |  |  | *Name of the payer or payee (customer, vendor, or other party). Useful for general/unlinked payments. Optional, for tracking.* |
| **reference** | String |  |  | *Payment reference or transaction ID (for reconciliation with bank/etc). Optional.* |
| **businessId** | ID |  |  | *An ID value to represent the tenant id of the business* |
## Business Api
### `Create Payment` API
Record a new payment optionally linked to an invoice. Triggers invoice status update if linked. Only owner/accountant roles can create payments.

**API Frontend Description By The Backend Architect**

When a payment is created in the UI, if linked to an invoice, the UI should refresh invoice status after API success. Payment amount/date/currency must be validated before submit. Confirmations may be shown for large payments or if an overpayment is being attempted.

**Rest Route**

The `createPayment` API REST controller can be triggered via the following route:

`/v1/payments`


**Rest Request Parameters**


The `createPayment` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| amount  | Double  | true | request.body?.["amount"] |
| currency  | String  | true | request.body?.["currency"] |
| date  | Date  | true | request.body?.["date"] |
| invoiceId  | ID  | false | request.body?.["invoiceId"] |
| method  | String  | false | request.body?.["method"] |
| notes  | Text  | false | request.body?.["notes"] |
| payerName  | String  | false | request.body?.["payerName"] |
| reference  | String  | false | request.body?.["reference"] |
**amount** : The amount of the payment, in invoice or business operating currency. Must be positive and required.
**currency** : ISO currency code (e.g., 'USD', 'EUR') used for this payment. Must match business or invoice. Required.
**date** : Date the payment was recorded. Used for reporting, filtering, and cash flow tracking. Required.
**invoiceId** : Reference to the associated invoice (if payment is linked); null for general/unallocated payment.
**method** : Payment method (e.g., bank transfer, cash, card, cheque, online, etc). Free text; used for reporting/reconciliation. Optional.
**notes** : Internal comments (operator notes, clarifications, etc.). Optional.
**payerName** : Name of the payer or payee (customer, vendor, or other party). Useful for general/unlinked payments. Optional, for tracking.
**reference** : Payment reference or transaction ID (for reconciliation with bank/etc). Optional.


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/payments**
```js
  axios({
    method: 'POST',
    url: '/v1/payments',
    data: {
            amount:"Double",  
            currency:"String",  
            date:"Date",  
            invoiceId:"ID",  
            method:"String",  
            notes:"Text",  
            payerName:"String",  
            reference:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"id": "ID",
		"amount": "Double",
		"currency": "String",
		"date": "Date",
		"invoiceId": "ID",
		"method": "String",
		"notes": "Text",
		"payerName": "String",
		"reference": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Payment` API
Delete (soft-delete) a payment entry. If linked to invoice, recalculates and updates invoice status afterwards. Restricted to owner/accountant.

**API Frontend Description By The Backend Architect**

UI should warn/confirm before deletion, as deletion can change linked invoice status. Deleted payments hidden in UI and reporting by default. After delete, reload linked invoice(s) as needed in app.

**Rest Route**

The `deletePayment` API REST controller can be triggered via the following route:

`/v1/payments/:paymentId`


**Rest Request Parameters**


The `deletePayment` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| paymentId  | ID  | true | request.params?.["paymentId"] |
**paymentId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/payments/:paymentId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/payments/${paymentId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"id": "ID",
		"amount": "Double",
		"currency": "String",
		"date": "Date",
		"invoiceId": "ID",
		"method": "String",
		"notes": "Text",
		"payerName": "String",
		"reference": "String",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Payment` API
Retrieve a single payment (by ID) belonging to business. Enriches response with invoice number and status if linked. Any business user may view.

**API Frontend Description By The Backend Architect**

Payment detail view should display invoice info (number, status, amount) if linked, else indicate 'General Payment.' For audit, can show create/update timestamps.

**Rest Route**

The `getPayment` API REST controller can be triggered via the following route:

`/v1/payments/:paymentId`


**Rest Request Parameters**


The `getPayment` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| paymentId  | ID  | true | request.params?.["paymentId"] |
**paymentId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/payments/:paymentId**
```js
  axios({
    method: 'GET',
    url: `/v1/payments/${paymentId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"invoice": {
			"dueDate": "Date",
			"invoiceNumber": "String",
			"status": "Enum",
			"status_idx": "Integer",
			"totalAmount": "Double",
			"type": "Enum",
			"type_idx": "Integer"
		},
		"isActive": true
	}
}
```
### `List Payments` API
List all payments, filterable by date, amount, method, invoice linkage, or reference for business. Can include invoice number/status via join for display/reporting. All roles with business login.

**API Frontend Description By The Backend Architect**

List all payments in business. Allow grid filter/search by date, method, amount, invoice number, and reference. Totals and exports can filter by time period in UI. Invoice columns optional if linked. Row click may open payment detail or associated invoice.

**Rest Route**

The `listPayments` API REST controller can be triggered via the following route:

`/v1/payments`


**Rest Request Parameters**
The `listPayments` api has got no request parameters.    



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/payments**
```js
  axios({
    method: 'GET',
    url: '/v1/payments',
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payments",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"payments": [
		{
			"invoice": [
				{
					"dueDate": "Date",
					"invoiceNumber": "String",
					"status": "Enum",
					"status_idx": "Integer",
					"totalAmount": "Double",
					"type": "Enum",
					"type_idx": "Integer"
				},
				{},
				{}
			],
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Payment` API
Update a payment record. If linked to invoice, recalculates total payments and updates status. Owners/Accountants only.

**API Frontend Description By The Backend Architect**

Payment may be updated in UI grid or detail form. Changing invoice link or amount/date triggers invoice status update for previous and/or new invoice link. UI should handle complex update scenarios consultatively.

**Rest Route**

The `updatePayment` API REST controller can be triggered via the following route:

`/v1/payments/:paymentId`


**Rest Request Parameters**


The `updatePayment` api has got 9 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| paymentId  | ID  | true | request.params?.["paymentId"] |
| amount  | Double  | false | request.body?.["amount"] |
| currency  | String  | false | request.body?.["currency"] |
| date  | Date  | false | request.body?.["date"] |
| invoiceId  | ID  | false | request.body?.["invoiceId"] |
| method  | String  | false | request.body?.["method"] |
| notes  | Text  | false | request.body?.["notes"] |
| payerName  | String  | false | request.body?.["payerName"] |
| reference  | String  | false | request.body?.["reference"] |
**paymentId** : This id paremeter is used to select the required data object that will be updated
**amount** : The amount of the payment, in invoice or business operating currency. Must be positive and required.
**currency** : ISO currency code (e.g., 'USD', 'EUR') used for this payment. Must match business or invoice. Required.
**date** : Date the payment was recorded. Used for reporting, filtering, and cash flow tracking. Required.
**invoiceId** : Reference to the associated invoice (if payment is linked); null for general/unallocated payment.
**method** : Payment method (e.g., bank transfer, cash, card, cheque, online, etc). Free text; used for reporting/reconciliation. Optional.
**notes** : Internal comments (operator notes, clarifications, etc.). Optional.
**payerName** : Name of the payer or payee (customer, vendor, or other party). Useful for general/unlinked payments. Optional, for tracking.
**reference** : Payment reference or transaction ID (for reconciliation with bank/etc). Optional.


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/payments/:paymentId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/payments/${paymentId}`,
    data: {
            amount:"Double",  
            currency:"String",  
            date:"Date",  
            invoiceId:"ID",  
            method:"String",  
            notes:"Text",  
            payerName:"String",  
            reference:"String",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"id": "ID",
		"amount": "Double",
		"currency": "String",
		"date": "Date",
		"invoiceId": "ID",
		"method": "String",
		"notes": "Text",
		"payerName": "String",
		"reference": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```


### Authentication Specific Routes



### Common Routes

### Route: currentuser

*Route Definition*: Retrieves the currently authenticated user's session information.

*Route Type*: sessionInfo

*Access Route*: `GET /currentuser`

#### Parameters

This route does **not** require any request parameters.

#### Behavior

- Returns the authenticated session object associated with the current access token.
- If no valid session exists, responds with a 401 Unauthorized.

```js
// Sample GET /currentuser call
axios.get("/currentuser", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````
**Success Response**
Returns the session object, including user-related data and token information.
````
{
  "sessionId": "9cf23fa8-07d4-4e7c-80a6-ec6d6ac96bb9",
  "userId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  "email": "user@example.com",
  "fullname": "John Doe",
  "roleId": "user",
  "tenantId": "abc123",
  "accessToken": "jwt-token-string",
  ...
}
````
**Error Response**
**401 Unauthorized:** No active session found.
````
{
  "status": "ERR",
  "message": "No login found"
}
````

**Notes**
* This route is typically used by frontend or mobile applications to fetch the current session state after login.
* The returned session includes key user identity fields, tenant information (if applicable), and the access token for further authenticated requests.
* Always ensure a valid access token is provided in the request to retrieve the session.

### Route: permissions

`*Route Definition*`: Retrieves all effective permission records assigned to the currently authenticated user.

`*Route Type*`: permissionFetch

*Access Route*: `GET /permissions`

#### Parameters

This route does **not** require any request parameters.

#### Behavior

- Fetches all active permission records (`givenPermissions` entries) associated with the current user session.
- Returns a full array of permission objects.
- Requires a valid session (`access token`) to be available.

```js
// Sample GET /permissions call
axios.get("/permissions", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````
**Success Response**

Returns an array of permission objects.
```json
[
  {
    "id": "perm1",
    "permissionName": "adminPanel.access",
    "roleId": "admin",
    "subjectUserId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
    "subjectUserGroupId": null,
    "objectId": null,
    "canDo": true,
    "tenantCodename": "store123"
  },
  {
    "id": "perm2",
    "permissionName": "orders.manage",
    "roleId": null,
    "subjectUserId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
    "subjectUserGroupId": null,
    "objectId": null,
    "canDo": true,
    "tenantCodename": "store123"
  }
]
````
Each object reflects a single permission grant, aligned with the givenPermissions model:

- `**permissionName**`: The permission the user has.
- `**roleId**`: If the permission was granted through a role.
-` **subjectUserId**`: If directly granted to the user.
- `**subjectUserGroupId**`: If granted through a group.
- `**objectId**`: If tied to a specific object (OBAC).
- `**canDo**`: True or false flag to represent if permission is active or restricted.

**Error Responses**
* **401 Unauthorized**: No active session found.
```json
{
  "status": "ERR",
  "message": "No login found"
}
````
* **500 Internal Server Error**: Unexpected error fetching permissions.

**Notes**
* The /permissions route is available across all backend services generated by Mindbricks, not just the auth service.
* Auth service: Fetches permissions freshly from the live database (givenPermissions table).
* Other services: Typically use a cached or projected view of permissions stored in a common ElasticSearch store, optimized for faster authorization checks.

> **Tip**:
> Applications can cache permission results client-side or server-side, but should occasionally refresh by calling this endpoint, especially after login or permission-changing operations.

### Route: permissions/:permissionName

*Route Definition*: Checks whether the current user has access to a specific permission, and provides a list of scoped object exceptions or inclusions.

*Route Type*: permissionScopeCheck

*Access Route*: `GET /permissions/:permissionName`

#### Parameters

| Parameter         | Type   | Required | Population             |
|------------------|--------|----------|------------------------|
| permissionName   | String | Yes      | `request.params.permissionName` |

#### Behavior

- Evaluates whether the current user **has access** to the given `permissionName`.
- Returns a structured object indicating:
  - Whether the permission is generally granted (`canDo`)
  - Which object IDs are explicitly included or excluded from access (`exceptions`)
- Requires a valid session (`access token`).

```js
// Sample GET /permissions/orders.manage
axios.get("/permissions/orders.manage", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````

**Success Response**

```json
{
  "canDo": true,
  "exceptions": [
    "a1f2e3d4-xxxx-yyyy-zzzz-object1",
    "b2c3d4e5-xxxx-yyyy-zzzz-object2"
  ]
}
````

* If `canDo` is `true`, the user generally has the permission, but not for the objects listed in `exceptions` (i.e., restrictions).
* If `canDo` is `false`, the user does not have the permission by default — but only for the objects in `exceptions`, they do have permission (i.e., selective overrides).
* The exceptions array contains valid **UUID strings**, each corresponding to an object ID (typically from the data model targeted by the permission).

## Copyright
All sources, documents and other digital materials are copyright of .

## About Us
For more information please visit our website: .

.
.


---

<a id="paymentmanagement-service-event-guide"></a>

## EVENT GUIDE

# EVENT GUIDE
## fintrack-paymentmanagement-service

Handles recording and lifecycle management of payments for invoices or as general/unallocated entries. Ensures invoice payment state is synchronized after each payment operation, supports strict business (tenant) isolation, and underpins core financial workflows in FinTrack.

## Architectural Design Credit and Contact Information

The architectural design of this microservice is credited to . For inquiries, feedback, or further information regarding the architecture, please direct your communication to:

Email: 

We encourage open communication and welcome any questions or discussions related to the architectural aspects of this microservice.

# Documentation Scope

Welcome to the official documentation for the `PaymentManagement` Service Event descriptions. This guide is dedicated to detailing how to subscribe to and listen for state changes within the `PaymentManagement` Service, offering an exclusive focus on event subscription mechanisms.

**Intended Audience**

This documentation is aimed at developers and integrators looking to monitor `PaymentManagement` Service state changes. It is especially relevant for those wishing to implement or enhance business logic based on interactions with `PaymentManagement` objects.

**Overview**

This section provides detailed instructions on monitoring service events, covering payload structures and demonstrating typical use cases through examples.

# Authentication and Authorization

Access to the `PaymentManagement` service's events is facilitated through the project's Kafka server, which is not accessible to the public. Subscription to a Kafka topic requires being on the same network and possessing valid Kafka user credentials.  This document presupposes that readers have existing access to the Kafka server.

Additionally, the service offers a public subscription option via REST for real-time data management in frontend applications, secured through REST API authentication and authorization mechanisms. To subscribe to service events via the REST API, please consult the Realtime REST API Guide.

# Database Events

Database events are triggered at the database layer, automatically and atomically, in response to any modifications at the data level. These events serve to notify subscribers about the creation, update, or deletion of objects within the database, distinct from any overarching business logic. 

Listening to database events is particularly beneficial for those focused on tracking changes at the database level. A typical use case for subscribing to database events is to replicate the data store of one service within another service's scope, ensuring data consistency and syncronization across services.

For example, while a business operation such as "approve membership" might generate a high-level business event like `membership-approved`, the underlying database changes could involve multiple state updates to different entities. These might be published as separate events, such as `dbevent-member-updated` and `dbevent-user-updated`, reflecting the granular changes at the database level.

Such detailed eventing provides a robust foundation for building responsive, data-driven applications, enabling fine-grained observability and reaction to the dynamics of the data landscape. It also facilitates the architectural pattern of event sourcing, where state changes are captured as a sequence of events, allowing for high-fidelity data replication and history replay for analytical or auditing purposes.

## DbEvent payment-created

**Event topic**: `fintrack-paymentmanagement-service-dbevent-payment-created`

This event is triggered upon the creation of a `payment` data object in the database. The event payload encompasses the newly created data, encapsulated within the root of the paylod.

**Event payload**: 
```json
{"id":"ID","amount":"Double","currency":"String","date":"Date","invoiceId":"ID","method":"String","notes":"Text","payerName":"String","reference":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  
## DbEvent payment-updated

**Event topic**: `fintrack-paymentmanagement-service-dbevent-payment-updated`

Activation of this event follows the update of a `payment` data object. The payload contains the updated information under the `payment` attribute, along with the original data prior to update, labeled as `old_payment` and also you can find the old and new versions of updated-only portion of the data..

**Event payload**: 
```json
{
old_payment:{"id":"ID","amount":"Double","currency":"String","date":"Date","invoiceId":"ID","method":"String","notes":"Text","payerName":"String","reference":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
payment:{"id":"ID","amount":"Double","currency":"String","date":"Date","invoiceId":"ID","method":"String","notes":"Text","payerName":"String","reference":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
oldDataValues,
newDataValues
}
``` 
## DbEvent payment-deleted

**Event topic**: `fintrack-paymentmanagement-service-dbevent-payment-deleted`

This event announces the deletion of a `payment` data object, covering both hard deletions (permanent removal) and soft deletions (where the `isActive` attribute is set to false). Regardless of the deletion type, the event payload will present the data as it was immediately before deletion, highlighting an `isActive` status of false for soft deletions.

**Event payload**: 
```json
{"id":"ID","amount":"Double","currency":"String","date":"Date","invoiceId":"ID","method":"String","notes":"Text","payerName":"String","reference":"String","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  


# ElasticSearch Index Events

Within the `PaymentManagement` service, most data objects are mirrored in ElasticSearch indices, ensuring these indices remain syncronized with their database counterparts through creation, updates, and deletions. These indices serve dual purposes: they act as a data source for external services and furnish aggregated data tailored to enhance frontend user experiences. Consequently, an ElasticSearch index might encapsulate data in its original form or aggregate additional information from other data objects. 

These aggregations can include both one-to-one and one-to-many relationships not only with database objects within the same service but also across different services. This capability allows developers to access comprehensive, aggregated data efficiently. By subscribing to ElasticSearch index events, developers are notified when an index is updated and can directly obtain the aggregated entity within the event payload, bypassing the need for separate ElasticSearch queries.

It's noteworthy that some services may augment another service's index by appending to the entity’s `extends` object. In such scenarios, an `*-extended` event will contain only the newly added data. Should you require the complete dataset, you would need to retrieve the full ElasticSearch index entity using the provided ID.

This approach to indexing and event handling facilitates a modular, interconnected architecture where services can seamlessly integrate and react to changes, enriching the overall data ecosystem and enabling more dynamic, responsive applications.



## Index Event payment-created

**Event topic**: `elastic-index-fintrack_payment-created`

**Event payload**:
```json
{"id":"ID","amount":"Double","currency":"String","date":"Date","invoiceId":"ID","method":"String","notes":"Text","payerName":"String","reference":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event payment-updated

**Event topic**: `elastic-index-fintrack_payment-created`

**Event payload**:
```json
{"id":"ID","amount":"Double","currency":"String","date":"Date","invoiceId":"ID","method":"String","notes":"Text","payerName":"String","reference":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event payment-deleted

**Event topic**: `elastic-index-fintrack_payment-deleted`

**Event payload**:
```json
{"id":"ID","amount":"Double","currency":"String","date":"Date","invoiceId":"ID","method":"String","notes":"Text","payerName":"String","reference":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event payment-extended

**Event topic**: `elastic-index-fintrack_payment-extended`

**Event payload**:
```js
{
  id: id,
  extends: {
    [extendName]: "Object",
    [extendName + "_count"]: "Number",
  },
}
``` 

# Route Events

Route events are emitted following the successful execution of a route. While most routes perform CRUD (Create, Read, Update, Delete) operations on data objects, resulting in route events that closely resemble database events, there are distinctions worth noting. A single route execution might trigger multiple CRUD actions and ElasticSearch indexing operations. However, for those primarily concerned with the overarching business logic and its outcomes, listening to the consolidated route event, published once at the conclusion of the route's execution, is more pertinent.

Moreover, routes often deliver aggregated data beyond the primary database object, catering to specific client needs. For instance, creating a data object via a route might not only return the entity's data but also route-specific metrics, such as the executing user's permissions related to the entity. Alternatively, a route might automatically generate default child entities following the creation of a parent object. Consequently, the route event encapsulates a unified dataset encompassing both the parent and its children, in contrast to individual events triggered for each entity created. Therefore, subscribing to route events can offer a richer, more contextually relevant set of information aligned with business logic.

The payload of a route event mirrors the REST response JSON of the route, providing a direct and comprehensive reflection of the data and metadata communicated to the client. This ensures that subscribers to route events receive a payload that encapsulates both the primary data involved and any additional information deemed significant at the business level, facilitating a deeper understanding and integration of the service's functional outcomes.


## Route Event payment-created

**Event topic** : `fintrack-paymentmanagement-service-payment-created`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `payment` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`payment`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"201","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"payment","method":"POST","action":"create","appVersion":"Version","rowCount":1,"payment":{"id":"ID","amount":"Double","currency":"String","date":"Date","invoiceId":"ID","method":"String","notes":"Text","payerName":"String","reference":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event payment-deleted

**Event topic** : `fintrack-paymentmanagement-service-payment-deleted`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `payment` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`payment`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"payment","method":"DELETE","action":"delete","appVersion":"Version","rowCount":1,"payment":{"id":"ID","amount":"Double","currency":"String","date":"Date","invoiceId":"ID","method":"String","notes":"Text","payerName":"String","reference":"String","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event payment-retrived

**Event topic** : `fintrack-paymentmanagement-service-payment-retrived`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `payment` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`payment`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"payment","method":"GET","action":"get","appVersion":"Version","rowCount":1,"payment":{"invoice":{"dueDate":"Date","invoiceNumber":"String","status":"Enum","status_idx":"Integer","totalAmount":"Double","type":"Enum","type_idx":"Integer"},"isActive":true}}
```  
## Route Event payments-listed

**Event topic** : `fintrack-paymentmanagement-service-payments-listed`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `payments` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`payments`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"payments","method":"GET","action":"list","appVersion":"Version","rowCount":"\"Number\"","payments":[{"invoice":[{"dueDate":"Date","invoiceNumber":"String","status":"Enum","status_idx":"Integer","totalAmount":"Double","type":"Enum","type_idx":"Integer"},{},{}],"isActive":true},{},{}],"paging":{"pageNumber":"Number","pageRowCount":"NUmber","totalRowCount":"Number","pageCount":"Number"},"filters":[],"uiPermissions":[]}
```  
## Route Event payment-updated

**Event topic** : `fintrack-paymentmanagement-service-payment-updated`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `payment` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`payment`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"payment","method":"PATCH","action":"update","appVersion":"Version","rowCount":1,"payment":{"id":"ID","amount":"Double","currency":"String","date":"Date","invoiceId":"ID","method":"String","notes":"Text","payerName":"String","reference":"String","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  




# Copyright
All sources, documents and other digital materials are copyright of .

# About Us
For more information please visit our website: .

.
.


---

## Data Objects

<a id="paymentmanagement-service-payment-design"></a>

### Service Design Specification - Object Design for payment

# Service Design Specification - Object Design for payment
**fintrack-paymentmanagement-service** documentation

## Document Overview
This document outlines the object design for the `payment` model in our application. It includes details about the model's attributes, relationships, and any specific validation or business logic that applies.

## payment Data Object

### Object Overview
**Description:** Represents any payment (linked to an invoice or general/unallocated) made or received by the business. Tracks linkage, amount, method, payer, and reference. Tenant-isolated. Triggers invoice status recalculation on changes.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessProtected — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.








### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `amount` | Double | Yes | The amount of the payment, in invoice or business operating currency. Must be positive and required. |
| `currency` | String | Yes | ISO currency code (e.g., &#39;USD&#39;, &#39;EUR&#39;) used for this payment. Must match business or invoice. Required. |
| `date` | Date | Yes | Date the payment was recorded. Used for reporting, filtering, and cash flow tracking. Required. |
| `invoiceId` | ID | No | Reference to the associated invoice (if payment is linked); null for general/unallocated payment. |
| `method` | String | No | Payment method (e.g., bank transfer, cash, card, cheque, online, etc). Free text; used for reporting/reconciliation. Optional. |
| `notes` | Text | No | Internal comments (operator notes, clarifications, etc.). Optional. |
| `payerName` | String | No | Name of the payer or payee (customer, vendor, or other party). Useful for general/unlinked payments. Optional, for tracking. |
| `reference` | String | No | Payment reference or transaction ID (for reconciliation with bank/etc). Optional. |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **amount**: 0.0
- **currency**: 'default'
- **date**: new Date()
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`amount` `currency` `date` `invoiceId` `method` `notes` `payerName` `reference`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

 

 

### Elastic Search Indexing

`amount` `currency` `date` `invoiceId` `method` `payerName` `reference` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`date` `invoiceId` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.




### Cache Select Properties

`date`

Cache select properties are used to collect data from Redis entity cache with a different key than the data object id.
This allows you to cache data that is not directly related to the data object id, but a frequently used filter.


### Secondary Key Properties

`invoiceId` `businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.


### Relation Properties

`invoiceId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **invoiceId**: ID
Relation to `invoice`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: No





### Filter Properties

`amount` `currency` `date` `invoiceId` `method` `reference` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **amount**: Double  has a filter named `amount`

- **currency**: String  has a filter named `currency`

- **date**: Date  has a filter named `date`

- **invoiceId**: ID  has a filter named `invoiceId`

- **method**: String  has a filter named `method`

- **reference**: String  has a filter named `reference`

- **businessId**: ID  has a filter named `businessId`



  

---

## Business APIs

<a id="paymentmanagement-service-business-api-createpayment-api-design"></a>

### Business API Design Specification - `Create Payment`


# Business API Design Specification - `Create Payment`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `createPayment` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `createPayment` Business API is designed to handle a `create` operation on the `Payment` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Record a new payment optionally linked to an invoice. Triggers invoice status update if linked. Only owner/accountant roles can create payments.

## API Frontend Description By The Backend Architect

When a payment is created in the UI, if linked to an invoice, the UI should refresh invoice status after API success. Payment amount/date/currency must be validated before submit. Confirmations may be shown for large payments or if an overpayment is being attempted.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `payment-created` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `createPayment` Business API includes a REST controller that can be triggered via the following route:

`/v1/payments`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `createPayment` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `createPayment` Business API has 9 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `paymentId`                             | `ID`   | `No` | `-` | `body` | `paymentId` |
| **Description:**                                | This id paremeter is used to create the data object with a given specific id. Leave null for automatic id. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `amount`                             | `Double`   | `Yes` | `-` | `body` | `amount` |
| **Description:**                                | The amount of the payment, in invoice or business operating currency. Must be positive and required. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `currency`                             | `String`   | `Yes` | `-` | `body` | `currency` |
| **Description:**                                | ISO currency code (e.g., 'USD', 'EUR') used for this payment. Must match business or invoice. Required. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `date`                             | `Date`   | `Yes` | `-` | `body` | `date` |
| **Description:**                                | Date the payment was recorded. Used for reporting, filtering, and cash flow tracking. Required. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceId`                             | `ID`   | `No` | `-` | `body` | `invoiceId` |
| **Description:**                                | Reference to the associated invoice (if payment is linked); null for general/unallocated payment. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `method`                             | `String`   | `No` | `-` | `body` | `method` |
| **Description:**                                | Payment method (e.g., bank transfer, cash, card, cheque, online, etc). Free text; used for reporting/reconciliation. Optional. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `notes`                             | `Text`   | `No` | `-` | `body` | `notes` |
| **Description:**                                | Internal comments (operator notes, clarifications, etc.). Optional. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `payerName`                             | `String`   | `No` | `-` | `body` | `payerName` |
| **Description:**                                | Name of the payer or payee (customer, vendor, or other party). Useful for general/unlinked payments. Optional, for tracking. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `reference`                             | `String`   | `No` | `-` | `body` | `reference` |
| **Description:**                                | Payment reference or transaction ID (for reconciliation with bank/etc). Optional. |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `createPayment` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant]`




---





## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 



**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  id: this.paymentId,
  businessId: this.businessId,
  amount: this.amount,
  currency: this.currency,
  date: this.date,
  invoiceId: this.invoiceId,
  method: this.method,
  notes: this.notes,
  payerName: this.payerName,
  reference: this.reference,
  isActive: true,
  _archivedAt: null,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, populates session and request objects, prepares internal structures for parameter handling and workflow execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads input parameters, normalizes missing values, applies default type casting, and stores them in the API context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager transforms parameters, computes derived values, flattens or remaps arrays/objects, and adjusts formats for downstream processing.


---




### [4] Step : checkParameters

Manager executes built-in validations: required field checks, type enforcement, and basic business rules. Prevents operation if validation fails.


---




### [5] Step : checkBasicAuth

Manager performs authentication and authorization checks: verifies session, user roles, permissions, and tenant restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildDataClause

Manager constructs the final data object for creation, fills auto-generated fields (IDs, timestamps, owner fields), and ensures schema consistency.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [7] Step : mainCreateOperation

Manager executes the database insert operation, updates indexes/caches, and triggers internal post-processing like linked default records.


---




### [8] Step : buildOutput

Manager shapes the response: masks sensitive fields, resolves linked references, and formats output according to API contract.


---




### [9] Step : sendResponse

Manager sends the response to the client and finalizes internal tasks like flushing logs or updating session state.


---




### [10] Step : raiseApiEvent

Manager triggers API-level events (Kafka, WebSocket, async workflows) as the final internal step.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `createPayment` api has got 8 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| amount  | Double  | true | request.body?.["amount"] |
| currency  | String  | true | request.body?.["currency"] |
| date  | Date  | true | request.body?.["date"] |
| invoiceId  | ID  | false | request.body?.["invoiceId"] |
| method  | String  | false | request.body?.["method"] |
| notes  | Text  | false | request.body?.["notes"] |
| payerName  | String  | false | request.body?.["payerName"] |
| reference  | String  | false | request.body?.["reference"] |

### REST Request
To access the api you can use the **REST** controller with the path **POST  /v1/payments**
```js
  axios({
    method: 'POST',
    url: '/v1/payments',
    data: {
            amount:"Double",  
            currency:"String",  
            date:"Date",  
            invoiceId:"ID",  
            method:"String",  
            notes:"Text",  
            payerName:"String",  
            reference:"String",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`payment`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"id": "ID",
		"amount": "Double",
		"currency": "String",
		"date": "Date",
		"invoiceId": "ID",
		"method": "String",
		"notes": "Text",
		"payerName": "String",
		"reference": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="paymentmanagement-service-business-api-deletepayment-api-design"></a>

### Business API Design Specification - `Delete Payment`


# Business API Design Specification - `Delete Payment`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `deletePayment` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `deletePayment` Business API is designed to handle a `delete` operation on the `Payment` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Delete (soft-delete) a payment entry. If linked to invoice, recalculates and updates invoice status afterwards. Restricted to owner/accountant.

## API Frontend Description By The Backend Architect

UI should warn/confirm before deletion, as deletion can change linked invoice status. Deleted payments hidden in UI and reporting by default. After delete, reload linked invoice(s) as needed in app.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `payment-deleted` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `deletePayment` Business API includes a REST controller that can be triggered via the following route:

`/v1/payments/:paymentId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `deletePayment` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `deletePayment` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `paymentId`                             | `ID`   | `Yes` | `-` | `urlpath` | `paymentId` |
| **Description:**                                | This id paremeter is used to select the required data object that will be deleted |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `deletePayment` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant]`




---



## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.paymentId},{businessId:this.businessId,isActive:true}]}
```





## Delete Options
Use these options to set `delete` specific settings.

**useSoftDelete**: true
If true, the record will be marked as deleted `(isActive: false)` instead of removed. The implementation depends on the data object’s soft delete configuration.





   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, prepares request/session objects, and sets up internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads and normalizes parameters, applies defaults, and stores them in the context for downstream steps.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager executes parameter transform scripts, computes derived values, and remaps objects or arrays as needed for later processing.


---




### [4] Step : checkParameters

Manager runs built-in validations including required field checks, type enforcement, and deletion preconditions. Stops execution if validation fails.


---




### [5] Step : checkBasicAuth

Manager validates session, user roles, permissions, and tenant-specific access rules to enforce basic auth restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Manager generates the query conditions, applies ownership and parent checks, and ensures the clause is correct for the delete operation.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : fetchInstance

Manager fetches the target record, applies filters from WHERE clause, and writes the instance to the context for further checks.


---




### [8] Step : checkInstance

Manager performs object-level validations such as lock status, soft-delete eligibility, and multi-step approval enforcement.


---




### [9] Step : mainDeleteOperation

Manager executes the delete query, updates related indexes/caches, and handles soft/hard delete logic according to configuration.


You can use the following settings to change some behavior of this step.
`deleteOptions`
---




### [10] Step : buildOutput

Manager shapes the response payload, masks sensitive fields, and formats related cleanup results for output.


---




### [11] Step : sendResponse

Manager delivers the response to the client and finalizes any temporary internal structures.


---




### [12] Step : raiseApiEvent

Manager triggers asynchronous API events, notifies queues or streams, and performs final cleanup for the workflow.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `deletePayment` api has got 1 regular client parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| paymentId  | ID  | true | request.params?.["paymentId"] |

### REST Request
To access the api you can use the **REST** controller with the path **DELETE  /v1/payments/:paymentId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/payments/${paymentId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`payment`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"id": "ID",
		"amount": "Double",
		"currency": "String",
		"date": "Date",
		"invoiceId": "ID",
		"method": "String",
		"notes": "Text",
		"payerName": "String",
		"reference": "String",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="paymentmanagement-service-business-api-getpayment-api-design"></a>

### Business API Design Specification - `Get Payment`


# Business API Design Specification - `Get Payment`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `getPayment` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `getPayment` Business API is designed to handle a `get` operation on the `Payment` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Retrieve a single payment (by ID) belonging to business. Enriches response with invoice number and status if linked. Any business user may view.

## API Frontend Description By The Backend Architect

Payment detail view should display invoice info (number, status, amount) if linked, else indicate 'General Payment.' For audit, can show create/update timestamps.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `payment-retrived` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `getPayment` Business API includes a REST controller that can be triggered via the following route:

`/v1/payments/:paymentId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `getPayment` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `getPayment` Business API has 1 parameter that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `paymentId`                             | `ID`   | `Yes` | `-` | `urlpath` | `paymentId` |
| **Description:**                                | This id paremeter is used to query the required data object. |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `getPayment` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`






---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

`id`,`invoiceId`,`businessId`,`date`,`amount`,`currency`,`method`,`payerName`,`reference`,`notes`


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.paymentId},{businessId:this.businessId,isActive:true}]}
```







## Get Options
Use these options to set `get` specific settings.

**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.





   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Extracts parameters from request and Redis, applies defaults, and writes them to context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Executes parameter transformation scripts, applies type coercion, merges derived values, and reshapes inputs for downstream milestones.


---




### [4] Step : checkParameters

Validates required and custom parameters, enforcing business-specific rules and constraints.


---




### [5] Step : checkBasicAuth

Performs login, role, and permission checks, and applies dynamic object-level access rules.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Builds the WHERE clause for fetching the object and applies additional scoped filters if configured.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainGetOperation

Executes the database fetch, retrieves the object, and stores it in context for enrichment or further checks.


You can use the following settings to change some behavior of this step.
`selectClause`, `getOptions`
---




### [8] Step : checkInstance

Performs instance-level validations, such as ownership, existence, or access conditions.


---




### [9] Step : buildOutput

Assembles the response from the object, applies masking, formatting, and injects additional metadata if needed.


---




### [10] Step : sendResponse

Delivers the response to the controller for client delivery.


---




### [11] Step : raiseApiEvent

Triggers optional API-level events after workflow completion, sending messages to integrations like Kafka if configured.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `getPayment` api has got 1 regular client parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| paymentId  | ID  | true | request.params?.["paymentId"] |

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/payments/:paymentId**
```js
  axios({
    method: 'GET',
    url: `/v1/payments/${paymentId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`payment`** object in the respones. However, some properties may be omitted based on the object's internal logic.

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"invoice": {
			"dueDate": "Date",
			"invoiceNumber": "String",
			"status": "Enum",
			"status_idx": "Integer",
			"totalAmount": "Double",
			"type": "Enum",
			"type_idx": "Integer"
		},
		"isActive": true
	}
}
```  

---

<a id="paymentmanagement-service-business-api-listpayments-api-design"></a>

### Business API Design Specification - `List Payments`


# Business API Design Specification - `List Payments`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `listPayments` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `listPayments` Business API is designed to handle a `list` operation on the `Payment` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

List all payments, filterable by date, amount, method, invoice linkage, or reference for business. Can include invoice number/status via join for display/reporting. All roles with business login.

## API Frontend Description By The Backend Architect

List all payments in business. Allow grid filter/search by date, method, amount, invoice number, and reference. Totals and exports can filter by time period in UI. Invoice columns optional if linked. Row click may open payment detail or associated invoice.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `payments-listed` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `listPayments` Business API includes a REST controller that can be triggered via the following route:

`/v1/payments`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `listPayments` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters


The `listPayments` Business API does not require any parameters to be provided from the controllers.

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `listPayments` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`






---


## Select Clause
Specifies which fields will be selected from the main data object during a `get` or `list` operation. Leave blank to select all properties. This applies only to `get` and `list` type APIs.",

`id`,`invoiceId`,`businessId`,`date`,`amount`,`currency`,`method`,`payerName`,`reference`,`notes`


## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{businessId:this.businessId,isActive:true}
```









## List Options
Defines list-specific options including filtering logic, default sorting, and result customization for APIs that return multiple records.

**List Sort By**
Sort order definitions for the result set. Multiple fields can be provided with direction (asc/desc).

[ date desc ]


**List Group By**
Grouping definitions for the result set. This is typically used for visual or report-based grouping.

*The list is not grouped.*



**setAsRead**: 
An optional array of field-value mappings that will be updated after the read operation. Useful for marking items as read or viewed.

No `setAsread` field-value pair is configured.


**Permission Filter**
Optional filter that applies permission constraints dynamically based on session or object roles. So that the list items are filtered by the user's OBAC or ABAC permissions.

*Permission filter is not active at the moment. Follow Mindbricks updates to be able to use it.*

## Pagination Options
Contains settings to configure pagination behavior for `list` APIs. Includes options like page size, offset, cursor support, and total count inclusion.



   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Initializes context with request and session objects. Prepares internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Reads request and Redis parameters, applies defaults, and writes them to context for downstream processing.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Transforms and normalizes parameters, derives dependent values, and reshapes inputs for the main list query.


---




### [4] Step : checkParameters

Executes validation logic on required and custom parameters, enforcing business rules and cross-field consistency.


---




### [5] Step : checkBasicAuth

Performs role-based access checks and applies dynamic membership or session-based restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Constructs the main query WHERE clause and applies optional filters or scoped access controls.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : mainListOperation

Executes the paginated database query, retrieves the list, and stores results in context for enrichment.


You can use the following settings to change some behavior of this step.
`selectClause`, `listOptions`, `paginationOptions`
---




### [8] Step : buildOutput

Assembles the list response, sanitizes sensitive fields, applies transformations, and injects extra context if needed.


---




### [9] Step : sendResponse

Sends the paginated list to the client through the controller.


---




### [10] Step : raiseApiEvent

Triggers optional post-workflow events, such as Kafka messages, logs, or system notifications.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.
The `listPayments` api has got no visible parameters.    

### REST Request
To access the api you can use the **REST** controller with the path **GET  /v1/payments**
```js
  axios({
    method: 'GET',
    url: '/v1/payments',
    data: {
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`payments`** object in the respones. However, some properties may be omitted based on the object's internal logic.

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payments",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"payments": [
		{
			"invoice": [
				{
					"dueDate": "Date",
					"invoiceNumber": "String",
					"status": "Enum",
					"status_idx": "Integer",
					"totalAmount": "Double",
					"type": "Enum",
					"type_idx": "Integer"
				},
				{},
				{}
			],
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```  

---

<a id="paymentmanagement-service-business-api-updatepayment-api-design"></a>

### Business API Design Specification - `Update Payment`


# Business API Design Specification - `Update Payment`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `updatePayment` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `updatePayment` Business API is designed to handle a `update` operation on the `Payment` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Update a payment record. If linked to invoice, recalculates total payments and updates status. Owners/Accountants only.

## API Frontend Description By The Backend Architect

Payment may be updated in UI grid or detail form. Changing invoice link or amount/date triggers invoice status update for previous and/or new invoice link. UI should handle complex update scenarios consultatively.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `payment-updated` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `updatePayment` Business API includes a REST controller that can be triggered via the following route:

`/v1/payments/:paymentId`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `updatePayment` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `updatePayment` Business API has 9 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `paymentId`                             | `ID`   | `Yes` | `-` | `urlpath` | `paymentId` |
| **Description:**                                | This id paremeter is used to select the required data object that will be updated |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `amount`                             | `Double`   | `No` | `-` | `body` | `amount` |
| **Description:**                                | The amount of the payment, in invoice or business operating currency. Must be positive and required. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `currency`                             | `String`   | `No` | `-` | `body` | `currency` |
| **Description:**                                | ISO currency code (e.g., 'USD', 'EUR') used for this payment. Must match business or invoice. Required. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `date`                             | `Date`   | `No` | `-` | `body` | `date` |
| **Description:**                                | Date the payment was recorded. Used for reporting, filtering, and cash flow tracking. Required. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `invoiceId`                             | `ID`   | `No` | `-` | `body` | `invoiceId` |
| **Description:**                                | Reference to the associated invoice (if payment is linked); null for general/unallocated payment. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `method`                             | `String`   | `No` | `-` | `body` | `method` |
| **Description:**                                | Payment method (e.g., bank transfer, cash, card, cheque, online, etc). Free text; used for reporting/reconciliation. Optional. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `notes`                             | `Text`   | `No` | `-` | `body` | `notes` |
| **Description:**                                | Internal comments (operator notes, clarifications, etc.). Optional. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `payerName`                             | `String`   | `No` | `-` | `body` | `payerName` |
| **Description:**                                | Name of the payer or payee (customer, vendor, or other party). Useful for general/unlinked payments. Optional, for tracking. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `reference`                             | `String`   | `No` | `-` | `body` | `reference` |
| **Description:**                                | Payment reference or transaction ID (for reconciliation with bank/etc). Optional. |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `updatePayment` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[superAdmin, tenantOwner]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[owner`, `accountant]`




---



## Where Clause
Defines the criteria used to locate the target record(s) for the main operation. This is expressed as a query object and applies to `get`, `list`, `update`, and `delete` APIs. All API types except `list` are expected to affect a single record.

*If nothing is configured for (get, update, delete) the id fields will be the select criteria.*

**Select By**: 
A list of fields that must be matched exactly as part of the WHERE clause. This is not a filter — it is a required selection rule. In single-record APIs (`get`, `update`, `delete`), it defines how a unique record is located. In `list` APIs, it scopes the results to only entries matching the given values.
Note that `selectBy` fields will be ignored if `fullWhereClause` is set.

*The business api configuration has no `selectBy` setting.*


**Full Where Clause** 
An MScript query expression that overrides all default WHERE clause logic. Use this for fully customized queries.
When `fullWhereClause` is set, `selectBy` is ignored, however additional selects will still be applied to final where clause.

The business api configuration has no `fullWhereClause` setting.


**Additional Clauses**
A list of conditionally applied MScript query fragments. These clauses are appended only if their conditions evaluate to true. If no condition is set it will be applied to the where clause directly.

The business api configuration has no additionalClauses setting.


**Actual Where Clause** 
This where clause is built using whereClause configuration (if set) and default business logic.

```js
{$and:[{id:this.paymentId},{businessId:this.businessId,isActive:true}]}
```




## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 


An update data clause populates all update-allowed properties of a data object, however the null properties (that are not provided by client) are ignored in db layer.


**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  amount: this.amount,
  currency: this.currency,
  date: this.date,
  invoiceId: this.invoiceId,
  method: this.method,
  notes: this.notes,
  payerName: this.payerName,
  reference: this.reference,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, prepares request and session objects, and sets up internal structures for parameter handling and milestone execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads parameters from the request or Redis, applies defaults, and writes them into context for downstream milestones.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager executes parameter transform scripts and derives any helper values or reshaped payloads into the context.


---




### [4] Step : checkParameters

Manager validates required parameters, checks ID formats (UUID/ObjectId), and ensures all preconditions for update are met.


---




### [5] Step : checkBasicAuth

Manager performs login verification, role, and permission checks, enforcing tenant and access rules before update.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildWhereClause

Manager constructs the WHERE clause used to identify the record to update, applying ownership and parent checks if necessary.


You can use the following settings to change some behavior of this step.
`whereClause`
---




### [7] Step : fetchInstance

Manager fetches the existing record from the database and writes it to the context for validation or enrichment.


---




### [8] Step : checkInstance

Manager performs instance-level validations, including ownership, existence, lock status, or other pre-update checks.


---




### [9] Step : buildDataClause

Manager prepares the data clause for the update, applying transformations or enhancements before persisting.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [10] Step : mainUpdateOperation

Manager executes the update operation with the WHERE and data clauses. Database-level events are raised if configured.


---




### [11] Step : buildOutput

Manager assembles the response object from the update result, masking fields or injecting additional metadata.


---




### [12] Step : sendResponse

Manager sends the response back to the controller for delivery to the client.


---




### [13] Step : raiseApiEvent

Manager triggers API-level events, sending relevant messages to Kafka or other integrations if configured.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `updatePayment` api has got 9 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| paymentId  | ID  | true | request.params?.["paymentId"] |
| amount  | Double  | false | request.body?.["amount"] |
| currency  | String  | false | request.body?.["currency"] |
| date  | Date  | false | request.body?.["date"] |
| invoiceId  | ID  | false | request.body?.["invoiceId"] |
| method  | String  | false | request.body?.["method"] |
| notes  | Text  | false | request.body?.["notes"] |
| payerName  | String  | false | request.body?.["payerName"] |
| reference  | String  | false | request.body?.["reference"] |

### REST Request
To access the api you can use the **REST** controller with the path **PATCH  /v1/payments/:paymentId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/payments/${paymentId}`,
    data: {
            amount:"Double",  
            currency:"String",  
            date:"Date",  
            invoiceId:"ID",  
            method:"String",  
            notes:"Text",  
            payerName:"String",  
            reference:"String",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`payment`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "payment",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"payment": {
		"id": "ID",
		"amount": "Double",
		"currency": "String",
		"date": "Date",
		"invoiceId": "ID",
		"method": "String",
		"notes": "Text",
		"payerName": "String",
		"reference": "String",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

# ProductCatalog Service

<a id="productcatalog-service-service-design"></a>

## Service Design Specification



# Service Design Specification
**fintrack-productcatalog-service** documentation
**Version:** `1.0.1`

## Scope

This document provides a structured architectural overview of the `productCatalog` microservice, detailing its configuration, data model, authorization logic, business rules, and API design. It has been automatically generated based on the service definition within Mindbricks, ensuring that the information reflects the source of truth used during code generation and deployment.

The document is intended to serve multiple audiences:

* **Service architects** can use it to validate design decisions and ensure alignment with broader architectural goals.
* **Developers and maintainers** will find it useful for understanding the structure and behavior of the service, facilitating easier debugging, feature extension, and integration with other systems.
* **Stakeholders and reviewers** can use it to gain a clear understanding of the service's capabilities and domain logic.

> **Note for Frontend Developers**: While this document is valuable for understanding business logic and data interactions, please refer to the [Service API Documentation](#) for endpoint-level specifications and integration details.

> **Note for Backend Developers**: Since the code for this service is automatically generated by Mindbricks, you typically won't need to implement or modify it manually. However, this document is especially valuable when you're building other services—whether within Mindbricks or externally—that need to interact with or depend on this service. It provides a clear reference to the service's data contracts, business rules, and API structure, helping ensure compatibility and correct integration.



## `ProductCatalog` Service Settings [**Edit**](productcatalog/serviceSettings)

Handles CRUD operations for products and services offered by the business. Makes products/services available for invoice itemization and supports future extensions (e.g., category, inventory, VAT config).

### Service Overview

This service is configured to listen for HTTP requests on port `3000`, 
serving both the main API interface and default administrative endpoints.

The following routes are available by default:

* **API Test Interface (API Face):** `/`
* **Swagger Documentation:** `/swagger`
* **Postman Collection Download:** `/getPostmanCollection`
* **Health Checks:** `/health` and `/admin/health`
* **Current Session Info:** `/currentuser`
* **Favicon:** `/favicon.ico`

The service uses a **PostgreSQL** database for data storage, with the database name set to `fintrack-productcatalog-service`.

This service is accessible via the following environment-specific URLs:

* **Preview:** `https://fintrack.prw.mindbricks.com/productcatalog-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/productcatalog-api`
* **Production:** `https://fintrack.mindbricks.co/productcatalog-api`

                                 

### Authentication & Security
- **Login Required**: Yes

This service requires user authentication for access. It supports both JWT and RSA-based authentication mechanisms, ensuring secure user sessions and data integrity.
If a crud route also is configured to require login, 
it will check a valid JWT token in the request query/header/bearer/cookie. If the token is valid, it will extract the user information from the token and make the fetched session data available in the request context.

  
### Service Data Objects
The service uses a **PostgreSQL** database for data storage, with the database name set to `fintrack-productcatalog-service`.

Data deletion is managed using a **soft delete** strategy. Instead of removing records from the database, they are flagged as inactive by setting the `isActive` field to `false`.



| Object Name | Description | Public Access | Tenant Level  | 
|-------------|-------------|---------------| --------------| 
| `productOrService` | Represents a business-specific product or service available for use in invoices. Each entry is owned/scoped exclusively by one business (tenant) and can be searched, filtered, or extended as needed. | accessPrivate |  Yes | 




## productOrService Data Object

### Object Overview
**Description:** Represents a business-specific product or service available for use in invoices. Each entry is owned/scoped exclusively by one business (tenant) and can be searched, filtered, or extended as needed.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessPrivate — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.




### Composite Indexes

- **businessSkuUnique**: [businessId, sku] 
This composite index is defined to optimize query performance for complex queries involving multiple fields.

The index also defines a conflict resolution strategy for duplicate key violations.

When a new record would violate this composite index, the following action will be taken:

**On Duplicate**: `throwError`

An error will be thrown, preventing the insertion of conflicting data.






### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `currency` | String | Yes | The ISO currency code (e.g., &#39;USD&#39;, &#39;EUR&#39;, &#39;GBP&#39;). Every item must be priced in a defined currency; business default applies for new entries. |
| `description` | Text | No | Detailed or extended description for internal use and clarity in catalog and invoice dialogs. |
| `name` | String | Yes | Product or service display name, visible in invoice selection and catalog. |
| `notes` | Text | No | Internal notes and comments for this product/service, not exposed to external partners or customers. |
| `price` | Double | Yes | Unit price/cost for the product or service (decimal). |
| `sku` | String | Yes | Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection. |
| `type` | Enum | Yes | Specifies whether the entry is a product (physical good) or a service (intangible). |
| `vatRate` | Double | Yes | VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%). |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **currency**: 'default'
- **name**: 'default'
- **price**: 0.0
- **sku**: 'default'
- **type**: "product"
- **vatRate**: 0
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`currency` `description` `name` `notes` `price` `sku` `type` `vatRate`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

### Enum Properties
Enum properties are defined with a set of allowed values, ensuring that only valid options can be assigned to them. 
The enum options value will be stored as strings in the database, 
but when a data object is created an addtional property with the same name plus an idx suffix will be created, which will hold the index of the selected enum option.
You can use the index property to sort by the enum value or when your enum options represent a sequence of values.

- **type**: [product, service]

 

 

### Elastic Search Indexing

`currency` `description` `name` `price` `sku` `type` `vatRate` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`name` `sku` `type` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.





### Secondary Key Properties

`businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.






### Filter Properties

`currency` `name` `price` `sku` `type` `vatRate` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **currency**: String  has a filter named `currency`

- **name**: String  has a filter named `name`

- **price**: Double  has a filter named `price`

- **sku**: String  has a filter named `sku`

- **type**: Enum  has a filter named `type`

- **vatRate**: Double  has a filter named `vatRate`

- **businessId**: ID  has a filter named `businessId`







## Business Logic


productCatalog has got 6 Business APIs to manage its internal and crud logic. 
For the details of each business API refer to its chapter.

* [Create Productorservice](/businessLogic/createproductorservice)

* [Delete Productorservice](/businessLogic/deleteproductorservice)

* [Get Productorservice](/businessLogic/getproductorservice)

* [List Productorservices](/businessLogic/listproductorservices)

* [Update Productorservice](/businessLogic/updateproductorservice)

* [_fetch Listproductorservice](/businessLogic/_fetchlistproductorservice)



## Edge Controllers



### m2mCreateProductOrService

**Configuration:**
- **Function Name**: `m2mCreateProductOrService`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/productorservice/create`
- **Method**: 

---

### m2mBulkCreateProductOrService

**Configuration:**
- **Function Name**: `m2mBulkCreateProductOrService`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/productorservice/bulk-create`
- **Method**: 

---

### m2mUpdateProductOrServiceById

**Configuration:**
- **Function Name**: `m2mUpdateProductOrServiceById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/productorservice/update/:id`
- **Method**: 

---

### m2mDeleteProductOrServiceById

**Configuration:**
- **Function Name**: `m2mDeleteProductOrServiceById`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/productorservice/delete/:id`
- **Method**: 

---

### m2mUpdateProductOrServiceByQuery

**Configuration:**
- **Function Name**: `m2mUpdateProductOrServiceByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/productorservice/update-by-query`
- **Method**: 

---

### m2mDeleteProductOrServiceByQuery

**Configuration:**
- **Function Name**: `m2mDeleteProductOrServiceByQuery`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/productorservice/delete-by-query`
- **Method**: 

---

### m2mUpdateProductOrServiceByIdList

**Configuration:**
- **Function Name**: `m2mUpdateProductOrServiceByIdList`
- **Login Required**: No

**REST Settings:**
- **Path**: `/m2m/productorservice/update-by-id-list`
- **Method**: 

---



---

## Service Library


### Functions

No general functions defined.


### Hook Functions

No hook functions defined.


### Edge Functions


#### m2mCreateProductOrService.js
```js
module.exports = async (request) => {
        const { createProductOrService } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const data = request.body?.data || request.data || request;
        const result = await createProductOrService(data, context);
        return { status: 200, content: result };
      }
```

#### m2mBulkCreateProductOrService.js
```js
module.exports = async (request) => {
        const { createBulkProductOrService } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataList = request.body?.dataList || request.dataList || (Array.isArray(request.body) ? request.body : [request.body]);
        if (!Array.isArray(dataList) || dataList.length === 0) {
          return { status: 400, message: "dataList must be a non-empty array" };
        }
        const result = await createBulkProductOrService(dataList, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateProductOrServiceById.js
```js
module.exports = async (request) => {
        const { updateProductOrServiceById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.id) delete dataClause.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await updateProductOrServiceById(id, dataClause, context);
        return { status: 200, content: result };
      }
```

#### m2mDeleteProductOrServiceById.js
```js
module.exports = async (request) => {
        const { deleteProductOrServiceById } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const id = request.body?.id || request.params?.id || request.id;
        if (!id) {
          return { status: 400, message: "ID is required" };
        }
        const result = await deleteProductOrServiceById(id, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateProductOrServiceByQuery.js
```js
module.exports = async (request) => {
        const { updateProductOrServiceByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await updateProductOrServiceByQuery(dataClause, query, context);
        return { status: 200, content: result };
      }
```

#### m2mDeleteProductOrServiceByQuery.js
```js
module.exports = async (request) => {
        const { deleteProductOrServiceByQuery } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const query = request.body?.query || request.query || {};
        if (!query || typeof query !== "object" || Object.keys(query).length === 0) {
          return { status: 400, message: "Query is required and must be a non-empty object" };
        }
        const result = await deleteProductOrServiceByQuery(query, context);
        return { status: 200, content: result };
      }
```

#### m2mUpdateProductOrServiceByIdList.js
```js
module.exports = async (request) => {
        const { updateProductOrServiceByIdList } = require("dbLayer");
        const context = { session: request.session, requestId: request.requestId };
        const idList = request.body?.idList || request.idList || [];
        const dataClause = request.body?.dataClause || request.dataClause || request.body;
        if (dataClause && dataClause.idList) delete dataClause.idList;
        if (!Array.isArray(idList) || idList.length === 0) {
          return { status: 400, message: "idList must be a non-empty array" };
        }
        const result = await updateProductOrServiceByIdList(idList, dataClause, context);
        return { status: 200, content: result };
      }
```



### Templates

No templates defined.


### Assets

No assets defined.


### Public Assets

No public assets defined.



---




### Event Emission


---

## Integration Patterns

## Deployment Considerations

### Environment Configuration
- **HTTP Port**: `3000`
- **Database Type**: MongoDB
- **Global Soft Delete**: Enabled




## Implementation Guidelines

### Development Workflow
1. **Data Model Implementation**: Generate database schema from data object definitions
2. **CRUD Route Generation**: Implement auto-generated routes with custom logic
3. **Custom Logic Integration**: Implement hook functions and edge functions
4. **Authentication Integration**: Configure with project-level authentication
5. **Testing**: Unit and integration testing for all components

### Code Generation Expectations
- **Database Schema**: Auto-generated from data objects and relationships
- **API Routes**: REST endpoints with customizable behavior
- **Validation Logic**: Input validation from property definitions
- **Access Control**: Authentication and authorization middleware

### Custom Code Integration Points
- **Hook Functions**: Lifecycle-specific custom logic
- **Edge Functions**: Full request/response control
- **Library Functions**: Reusable business logic
- **Templates**: Dynamic content rendering

### Testing Strategy

#### Unit Testing
- Test all custom library functions
- Test validation logic and business rules
- Test hook function implementations

#### Integration Testing
- Test API endpoints with authentication scenarios
- Test database operations and transactions
- Test external integrations
- Test event emission and Kafka integration

#### Performance Testing
- Load test high-traffic endpoints
- Test caching effectiveness
- Monitor database query performance
- Test scalability under load

---

## Appendices

### Data Type Reference
| Type | Description | Storage |
|------|-------------|---------|
| ID | Unique identifier | UUID (SQL) / ObjectID (NoSQL) |
| String | Short text (≤255 chars) | VARCHAR |
| Text | Long-form text | TEXT |
| Integer | 32-bit whole numbers | INT |
| Boolean | True/false values | BOOLEAN |
| Double | 64-bit floating point | DOUBLE |
| Float | 32-bit floating point | FLOAT |
| Short | 16-bit integers | SMALLINT |
| Object | JSON object | JSONB (PostgreSQL) / Object (MongoDB) |
| Date | ISO 8601 timestamp | TIMESTAMP |
| Enum | Fixed numeric values | SMALLINT with lookup |

### Enum Value Mappings

#### Request Locations
- `0`: Bearer token in Authorization header
- `1`: Cookie value
- `2`: Custom HTTP header
- `3`: Query parameter
- `4`: Request body property
- `5`: URL path parameter
- `6`: Session data
- `7`: Root request object

#### HTTP Methods
- `0`: GET
- `1`: POST
- `2`: PUT
- `3`: PATCH
- `4`: DELETE


### Edge Function Signature
```javascript
async function edgeFunction(request) {
  // Custom request processing
  // Return response object or throw error
  return {
    data: {},
    status: 200,
    message: "Success"
  };
}
```

---

*This document was generated from the service architecture definition and should be kept in sync with implementation changes.*

---

<a id="productcatalog-service-rest-api-guide"></a>

## REST API GUIDE 

 

# REST API GUIDE 
## fintrack-productcatalog-service
**Version:** `1.0.1`

Handles CRUD operations for products and services offered by the business. Makes products/services available for invoice itemization and supports future extensions (e.g., category, inventory, VAT config).

## Architectural Design Credit and Contact Information

The architectural design of this microservice is credited to . 
For inquiries, feedback, or further information regarding the architecture, please direct your communication to:

Email: 

We encourage open communication and welcome any questions or discussions related to the architectural aspects of this microservice.

## Documentation Scope

Welcome to the official documentation for the ProductCatalog Service's REST API. This document is designed to provide a comprehensive guide to interfacing with our ProductCatalog Service exclusively through RESTful API endpoints.

**Intended Audience**

This documentation is intended for developers and integrators who are looking to interact with the ProductCatalog Service via HTTP requests for purposes such as creating, updating, deleting and querying ProductCatalog objects.

**Overview**

Within these pages, you will find detailed information on how to effectively utilize the REST API, including authentication methods, request and response formats, endpoint descriptions, and examples of common use cases.

Beyond REST
It's important to note that the ProductCatalog Service also supports alternative methods of interaction, such as gRPC and messaging via a Message Broker. These communication methods are beyond the scope of this document. For information regarding these protocols, please refer to their respective documentation.

## Authentication And Authorization

To ensure secure access to the ProductCatalog service's protected endpoints, a project-wide access token is required. This token serves as the primary method for authenticating requests to our service. However, it's important to note that access control varies across different routes:

**Protected API**: 
Certain API (routes) require specific authorization levels. Access to these routes is contingent upon the possession of a valid access token that meets the route-specific authorization criteria. Unauthorized requests to these routes will be rejected.

**Public API **: 
The service also includes public API (routes) that are accessible without authentication. These public endpoints are designed for open access and do not require an access token.

### Token Locations
When including your access token in a request, ensure it is placed in one of the following specified locations. The service will sequentially search these locations for the token, utilizing the first one it encounters.

| Location               | Token Name / Param Name      |
| ---------------------- | ---------------------------- |
| Query                  | access_token                 |
| Authorization Header   | Bearer                       |
| Header                 | fintrack-access-token|
| Header                 | fintrack-access-token-{businessCodename}|
| Cookie                 | fintrack-access-token-{businessCodename}|


Please ensure the token is correctly placed in one of these locations, using the appropriate label as indicated. The service prioritizes these locations in the order listed, processing the first token it successfully identifies.


## Api Definitions
This section outlines the API endpoints available within the ProductCatalog service. Each endpoint can receive parameters through various methods, meticulously described in the following definitions. It's important to understand the flexibility in how parameters can be included in requests to effectively interact with the ProductCatalog service.

This service is configured to listen for HTTP requests on port `3000`, 
serving both the main API interface and default administrative endpoints.

The following routes are available by default:

* **API Test Interface (API Face):** `/`
* **Swagger Documentation:** `/swagger`
* **Postman Collection Download:** `/getPostmanCollection`
* **Health Checks:** `/health` and `/admin/health`
* **Current Session Info:** `/currentuser`
* **Favicon:** `/favicon.ico`

This service is accessible via the following environment-specific URLs:

* **Preview:** `https://fintrack.prw.mindbricks.com/productcatalog-api`
* **Staging:** `https://fintrack-stage.mindbricks.co/productcatalog-api`
* **Production:** `https://fintrack.mindbricks.co/productcatalog-api`

**Parameter Inclusion Methods:**
Parameters can be incorporated into API requests in several ways, each with its designated location. Understanding these methods is crucial for correctly constructing your requests:

**Query Parameters:** Included directly in the URL's query string.

**Path Parameters:** Embedded within the URL's path.

**Body Parameters:** Sent within the JSON body of the request.

**Session Parameters:** Automatically read from the session object. This method is used for parameters that are intrinsic to the user's session, such as userId. When using an API that involves session parameters, you can omit these from your request. The service will automatically bind them to the API layer, provided that a session is associated with your request.

**Note on Session Parameters:**
Session parameters represent a unique method of parameter inclusion, relying on the context of the user's session. A common example of a session parameter is userId, which the service automatically associates with your request when a session exists. This feature ensures seamless integration of user-specific data without manual input for each request.

By adhering to the specified parameter inclusion methods, you can effectively utilize the ProductCatalog service's API endpoints. For detailed information on each endpoint, including required parameters and their accepted locations, refer to the individual API definitions below.

### Common Parameters

The `ProductCatalog` service's business API support several common parameters designed to modify and enhance the behavior of API requests. These parameters are not individually listed in the API route definitions to avoid repetition. Instead, refer to this section to understand how to leverage these common behaviors across different routes. Note that all common parameters should be included in the query part of the URL.

### Supported Common Parameters:

- **getJoins (BOOLEAN)**: Controls whether to retrieve associated objects along with the main object. By default, `getJoins` is assumed to be `true`. Set it to `false` if you prefer to receive only the main fields of an object, excluding its associations.

- **excludeCQRS (BOOLEAN)**: Applicable only when `getJoins` is `true`. By default, `excludeCQRS` is set to `false`. Enabling this parameter (`true`) omits non-local associations, which are typically more resource-intensive as they require querying external services like ElasticSearch for additional information. Use this to optimize response times and resource usage.

- **requestId (String)**: Identifies a request to enable tracking through the service's log chain. A random hex string of 32 characters is assigned by default. If you wish to use a custom `requestId`, simply include it in your query parameters.

- **caching (BOOLEAN)**: Determines the use of caching for query API. By default, caching is enabled (`true`). To ensure the freshest data directly from the database, set this parameter to `false`, bypassing the cache.

- **cacheTTL (Integer)**: Specifies the Time-To-Live (TTL) for query caching, in seconds. This is particularly useful for adjusting the default caching duration (5 minutes) for `get list` queries. Setting a custom `cacheTTL` allows you to fine-tune the cache lifespan to meet your needs.

- **pageNumber (Integer)**: For paginated `get list` API's, this parameter selects which page of results to retrieve. The default is `1`, indicating the first page. To disable pagination and retrieve all results, set `pageNumber` to `0`.

- **pageRowCount (Integer)**: In conjunction with paginated API's, this parameter defines the number of records per page. The default value is `25`. Adjusting `pageRowCount` allows you to control the volume of data returned in a single request.

By utilizing these common parameters, you can tailor the behavior of API requests to suit your specific requirements, ensuring optimal performance and usability of the `ProductCatalog` service.


  ### Multi Tenant Architecture

  The `ProductCatalog` service operates within a multi tenant architecture.
  The service is designed to support multiple tenants, each with its distinct data and configuration. This architecture ensures that data is securely isolated between tenants, preventing unauthorized access and maintaining data integrity.
  The service tenant is called `business` and identified as `businessId`.
  Other than platform users like superAdmin, saasAdmin and saasUser that belong to the root tenant, the tenant creators(owners) and users will all be associated with an business tenant.
  When users login their scope will be isolated only to include one tenant data they below. So user may acces only this logined tennat through out the session. After loging in to e specific tenant, users should include the tenant id in their request to access the tenant data. In each request they may access different tenant data if they belong them. 


  #### Key Points:
  
  - **Tenant-Specific Requests**: It is imperative that each request specifies the tenant it pertains to. This is crucial because most API's are designed to interact exclusively with objects that are part of the specified tenant sandbox.
  - **User Distinction**: The requesting user must have a registration for that tenant. The service searches for a `business` specific token (cookie or bearer) using the provided `business`Id in the request header. Note that to be able to login and use multiple tenant's sites a user must register for them all.
  - **Request Header Parameter**: When making a request, include the desired `businessId` in the request header using the parameter name ``. This signals to the service which domain context to apply for the request processing. Alternatively, you can include the tenant id in the query parameters with the name `businessId`.
  - **Root Tenant**: As all multi tenant architectures this application also has a default root tenant which created automatically. If there is no tenant mark for the request, the request are assumed as to the root tenant. Root tenant is also the hub for registering tenant creating and their owner users. When users register themselves in the root tenant, an (business) will alos be created with the given data in the request body and the user will be asssociated with this new tenant record as the `tenantAdmin`. 
  - **Superadmin account**: A super admin account is created with the given credentials in the design so that there is an absolute user which has all rights in the root tenant and other tenants. This account is used to create and manage all other tenants in the system. 
    - **Tenant Registration**: The `ProductCatalog` service allows for the creation of new tenants only through admin account of the root tenant. So if a new business record is needed, the superadmin or admin roles of the root should create then new tenant and assign any user as the owner of it.
  
  #### Implementation:

  When the user logins there may be few ways for Mindbricks to recognize and set the tenant id in the session.
  1. Mindbricks will check the url of the login request if it matches tenant url.
  2. Mindbricks will check the `` has the tenant id.
  3. Mindbricks will check if the user is associated with a `business` in the data model.
  After you login a tenant successfully, ensure that your requests accurately target objects that fall within the tenant scope set during the login session.
  Ensure your requests are correctly formatted to include the domain sandbox information in the header. This enables the `ProductCatalog` service to accurately identify the domain context, facilitating proper access control and data management based on the user's permissions and the specified domain.  
  ```js
  axios({
    method: 'GET',
    headers: {
      '': 'Your-businessId-here'
    }
    url: "/someroutepath",
    data: {
      "someData":"someData"
    },
    params: {
      "aParam":"aParam"
    }
  });
  ````     
  By adhering to this domain sandbox model, the `ProductCatalog` service maintains a secure and organized structure for handling requests across different domains, ensuring that operations are performed within the correct contextual boundaries.

### Error Response

If a request encounters an issue, whether due to a logical fault or a technical problem, the service responds with a standardized JSON error structure. The HTTP status code within this response indicates the nature of the error, utilizing commonly recognized codes for clarity:

- **400 Bad Request**: The request was improperly formatted or contained invalid parameters, preventing the server from processing it.
- **401 Unauthorized**: The request lacked valid authentication credentials or the credentials provided do not grant access to the requested resource.
- **404 Not Found**: The requested resource was not found on the server.
- **500 Internal Server Error**: The server encountered an unexpected condition that prevented it from fulfilling the request.

Each error response is structured to provide meaningful insight into the problem, assisting in diagnosing and resolving issues efficiently.

```js
{
  "result": "ERR",
  "status": 400,
  "message": "errMsg_organizationIdisNotAValidID",
  "errCode": 400,
  "date": "2024-03-19T12:13:54.124Z",
  "detail": "String"
}
```` 

### Object Structure of a Successfull Response

When the `ProductCatalog` service processes requests successfully, it wraps the requested resource(s) within a JSON envelope. This envelope not only contains the data but also includes essential metadata, such as configuration details and pagination information, to enrich the response and provide context to the client.

**Key Characteristics of the Response Envelope:**

- **Data Presentation**: Depending on the nature of the request, the service returns either a single data object or an array of objects encapsulated within the JSON envelope.
  - **Creation and Update API**: These API routes return the unmodified (pure) form of the data object(s), without any associations to other data objects.
  - **Delete API**: Even though the data is removed from the database, the last known state of the data object(s) is returned in its pure form.
  - **Get Requests**: A single data object is returned in JSON format.
  - **Get List Requests**: An array of data objects is provided, reflecting a collection of resources.

- **Data Structure and Joins**: The complexity of the data structure in the response can vary based on the API's architectural design and the join options specified in the request. The architecture might inherently limit join operations, or they might be dynamically controlled through query parameters.
  - **Pure Data Forms**: In some cases, the response mirrors the exact structure found in the primary data table, without extensions.
  - **Extended Data Forms**: Alternatively, responses might include data extended through joins with tables within the same service or aggregated from external sources, such as ElasticSearch indices related to other services.
  - **Join Varieties**: The extensions might involve one-to-one joins, resulting in single object associations, or one-to-many joins, leading to an array of objects. In certain instances, the data might even feature nested inclusions from other data objects.

**Design Considerations**: The structure of a API's response data is meticulously crafted during the service's architectural planning. This design ensures that responses adequately reflect the intended data relationships and service logic, providing clients with rich and meaningful information.

**Brief Data**: Certain API's return a condensed version of the object data, intentionally selecting only specific fields deemed useful for that request. In such instances, the API documentation will detail the properties included in the response, guiding developers on what to expect.

### API Response Structure

The API utilizes a standardized JSON envelope to encapsulate responses. This envelope is designed to consistently deliver both the requested data and essential metadata, ensuring that clients can efficiently interpret and utilize the response.

**HTTP Status Codes:**

- **200 OK**: This status code is returned for successful GET, LIST, UPDATE, or DELETE operations, indicating that the request has been processed successfully.
- **201 Created**: This status code is specific to CREATE operations, signifying that the requested resource has been successfully created.

**Success Response Format:**

For successful operations, the response includes a `"status": "OK"` property, signaling the successful execution of the request. The structure of a successful response is outlined below:

```json
{
  "status":"OK",
  "statusCode": 200,   
  "elapsedMs":126,
  "ssoTime":120,
  "source": "db",
  "cacheKey": "hexCode",
  "userId": "ID",
  "sessionId": "ID",
  "requestId": "ID",
  "dataName":"products",
  "method":"GET",
  "action":"list",
  "appVersion":"Version",
  "rowCount":3
  "products":[{},{},{}],
  "paging": {
    "pageNumber":1, 
    "pageRowCount":25, 
    "totalRowCount":3,
    "pageCount":1
  },
  "filters": [],
  "uiPermissions": []
}
````

- **`products`**: In this example, this key contains the actual response content, which may be a single object or an array of objects depending on the operation performed.

**Handling Errors:**

For details on handling error scenarios and understanding the structure of error responses, please refer to the "Error Response" section provided earlier in this documentation. It outlines how error conditions are communicated, including the use of HTTP status codes and standardized JSON structures for error messages.

## Resources 
ProductCatalog service provides the following resources which are stored in its own database as a data object. Note that a resource for an api access is a data object for the service.

### ProductOrService resource

*Resource Definition* : Represents a business-specific product or service available for use in invoices. Each entry is owned/scoped exclusively by one business (tenant) and can be searched, filtered, or extended as needed.
*ProductOrService Resource Properties* 
| Name | Type | Required | Default | Definition | 
| ---- | ---- | -------- | ------- | ---------- |
| **currency** | String |  |  | *The ISO currency code (e.g., &#39;USD&#39;, &#39;EUR&#39;, &#39;GBP&#39;). Every item must be priced in a defined currency; business default applies for new entries.* |
| **description** | Text |  |  | *Detailed or extended description for internal use and clarity in catalog and invoice dialogs.* |
| **name** | String |  |  | *Product or service display name, visible in invoice selection and catalog.* |
| **notes** | Text |  |  | *Internal notes and comments for this product/service, not exposed to external partners or customers.* |
| **price** | Double |  |  | *Unit price/cost for the product or service (decimal).* |
| **sku** | String |  |  | *Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection.* |
| **type** | Enum |  |  | *Specifies whether the entry is a product (physical good) or a service (intangible).* |
| **vatRate** | Double |  |  | *VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%).* |
| **businessId** | ID |  |  | *An ID value to represent the tenant id of the business* |
#### Enum Properties
Enum properties are represented as strings in the database. The values are mapped to their corresponding names in the application layer.
##### type Enum Property
*Property Definition* : Specifies whether the entry is a product (physical good) or a service (intangible).*Enum Options*
| Name | Value | Index | 
| ---- | ----- | ----- |
| **product** | `"product""` | 0 | 
| **service** | `"service""` | 1 | 
## Business Api
### `Create Productorservice` API
Create a new product or service entry scoped to the current business. Only Owner/Accountant may create.

**API Frontend Description By The Backend Architect**

- Only Owners and Accountants can add new products/services via this API.\n- Input must specify all required product fields: type, name, sku (unique in business), price, currency, and VAT rate.\n- SKU is checked for uniqueness within business context before creation.\n- On success, product/service is added and available for invoice selection; frontends may refresh catalog views automatically.\n- If SKU conflict, API returns error highlighting duplication.

**Rest Route**

The `createProductOrService` API REST controller can be triggered via the following route:

`/v1/productorservices`


**Rest Request Parameters**


The `createProductOrService` api has got 8 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| currency  | String  | true | request.body?.["currency"] |
| description  | Text  | false | request.body?.["description"] |
| name  | String  | true | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| price  | Double  | true | request.body?.["price"] |
| sku  | String  | true | request.body?.["sku"] |
| type  | Enum  | true | request.body?.["type"] |
| vatRate  | Double  | true | request.body?.["vatRate"] |
**currency** : The ISO currency code (e.g., 'USD', 'EUR', 'GBP'). Every item must be priced in a defined currency; business default applies for new entries.
**description** : Detailed or extended description for internal use and clarity in catalog and invoice dialogs.
**name** : Product or service display name, visible in invoice selection and catalog.
**notes** : Internal notes and comments for this product/service, not exposed to external partners or customers.
**price** : Unit price/cost for the product or service (decimal).
**sku** : Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection.
**type** : Specifies whether the entry is a product (physical good) or a service (intangible).
**vatRate** : VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%).


**REST Request**
To access the api you can use the **REST** controller with the path **POST  /v1/productorservices**
```js
  axios({
    method: 'POST',
    url: '/v1/productorservices',
    data: {
            currency:"String",  
            description:"Text",  
            name:"String",  
            notes:"Text",  
            price:"Double",  
            sku:"String",  
            type:"Enum",  
            vatRate:"Double",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrService",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"productOrService": {
		"id": "ID",
		"currency": "String",
		"description": "Text",
		"name": "String",
		"notes": "Text",
		"price": "Double",
		"sku": "String",
		"type": "Enum",
		"type_idx": "Integer",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Delete Productorservice` API
Soft-delete (deactivate) a product or service. Only Owner/Accountant can delete within their business. Deleted (inactive) products are not offered for new invoices but remain for history/reporting.

**API Frontend Description By The Backend Architect**

- Soft delete: product/service is marked inactive ('archived'), not physically removed.\n- Only Owner/Accountant can delete.\n- Deleted items no longer appear in normal selection for invoices, but can be viewed in an 'archived' filter/state in management UI.\n- No delete allowed across business or by unauthorized roles.

**Rest Route**

The `deleteProductOrService` API REST controller can be triggered via the following route:

`/v1/productorservices/:productOrServiceId`


**Rest Request Parameters**


The `deleteProductOrService` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| productOrServiceId  | ID  | true | request.params?.["productOrServiceId"] |
**productOrServiceId** : This id paremeter is used to select the required data object that will be deleted


**REST Request**
To access the api you can use the **REST** controller with the path **DELETE  /v1/productorservices/:productOrServiceId**
```js
  axios({
    method: 'DELETE',
    url: `/v1/productorservices/${productOrServiceId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrService",
	"method": "DELETE",
	"action": "delete",
	"appVersion": "Version",
	"rowCount": 1,
	"productOrService": {
		"id": "ID",
		"currency": "String",
		"description": "Text",
		"name": "String",
		"notes": "Text",
		"price": "Double",
		"sku": "String",
		"type": "Enum",
		"type_idx": "Integer",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": false,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `Get Productorservice` API
Get details of a single product or service by ID within the current business. All roles can view details for selection or management as allowed.

**API Frontend Description By The Backend Architect**

- Any authenticated business role can view details of a product/service in their business.\n- Product/service data is used for invoice itemization screens, catalog drilldown, edit panes, etc.

**Rest Route**

The `getProductOrService` API REST controller can be triggered via the following route:

`/v1/productorservices/:productOrServiceId`


**Rest Request Parameters**


The `getProductOrService` api has got 1 regular request parameter  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| productOrServiceId  | ID  | true | request.params?.["productOrServiceId"] |
**productOrServiceId** : This id paremeter is used to query the required data object.


**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/productorservices/:productOrServiceId**
```js
  axios({
    method: 'GET',
    url: `/v1/productorservices/${productOrServiceId}`,
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrService",
	"method": "GET",
	"action": "get",
	"appVersion": "Version",
	"rowCount": 1,
	"productOrService": {
		"isActive": true
	}
}
```
### `List Productorservices` API
List all products and services in the current business. Supports filter/search by name, type, SKU. All roles within business may view and select for invoice workflows.

**API Frontend Description By The Backend Architect**

- Product/service catalog is presented in tabular/grid with filters for name, type (product/service), and SKU.\n- 'Inactive' or soft-deleted items may be hidden by default, surfaced when needed.\n- VAT rate, price, and currency columns support invoice UI and reporting.\n- All data is scoped to current business, never shown across tenants.

**Rest Route**

The `listProductOrServices` API REST controller can be triggered via the following route:

`/v1/productorservices`


**Rest Request Parameters**
The `listProductOrServices` api has got no request parameters.    



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/productorservices**
```js
  axios({
    method: 'GET',
    url: '/v1/productorservices',
    data: {
    
    },
    params: {
    
        }
  });
```   
**REST Response**

This route's response is constrained to a select list of properties, and therefore does not encompass all attributes of the resource.

```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrServices",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"productOrServices": [
		{
			"isActive": true
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```
### `Update Productorservice` API
Update an existing product/service. Owners and Accountants (and only those within the business) can modify. SKU is validated for uniqueness per business.

**API Frontend Description By The Backend Architect**

- Only Owner/Accountant can update catalog entries.\n- Updates are restricted to product/service records belonging to current business.\n- SKU cannot be set to a value that duplicates another active product for this business.\n- Updated entries remain immediately available for invoice selection; edits reflected in search/filter UI.\n- If conflicting update (e.g., SKU duplicate), clear error is provided for frontend handling.

**Rest Route**

The `updateProductOrService` API REST controller can be triggered via the following route:

`/v1/productorservices/:productOrServiceId`


**Rest Request Parameters**


The `updateProductOrService` api has got 9 regular request parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| productOrServiceId  | ID  | true | request.params?.["productOrServiceId"] |
| currency  | String  | false | request.body?.["currency"] |
| description  | Text  | false | request.body?.["description"] |
| name  | String  | false | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| price  | Double  | false | request.body?.["price"] |
| sku  | String  | false | request.body?.["sku"] |
| type  | Enum  | false | request.body?.["type"] |
| vatRate  | Double  | false | request.body?.["vatRate"] |
**productOrServiceId** : This id paremeter is used to select the required data object that will be updated
**currency** : The ISO currency code (e.g., 'USD', 'EUR', 'GBP'). Every item must be priced in a defined currency; business default applies for new entries.
**description** : Detailed or extended description for internal use and clarity in catalog and invoice dialogs.
**name** : Product or service display name, visible in invoice selection and catalog.
**notes** : Internal notes and comments for this product/service, not exposed to external partners or customers.
**price** : Unit price/cost for the product or service (decimal).
**sku** : Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection.
**type** : Specifies whether the entry is a product (physical good) or a service (intangible).
**vatRate** : VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%).


**REST Request**
To access the api you can use the **REST** controller with the path **PATCH  /v1/productorservices/:productOrServiceId**
```js
  axios({
    method: 'PATCH',
    url: `/v1/productorservices/${productOrServiceId}`,
    data: {
            currency:"String",  
            description:"Text",  
            name:"String",  
            notes:"Text",  
            price:"Double",  
            sku:"String",  
            type:"Enum",  
            vatRate:"Double",  
    
    },
    params: {
    
        }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrService",
	"method": "PATCH",
	"action": "update",
	"appVersion": "Version",
	"rowCount": 1,
	"productOrService": {
		"id": "ID",
		"currency": "String",
		"description": "Text",
		"name": "String",
		"notes": "Text",
		"price": "Double",
		"sku": "String",
		"type": "Enum",
		"type_idx": "Integer",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```
### `_fetch Listproductorservice` API
System API to fetch list of productOrService records for frontend application. Auto-generated, not visible in design.


**Rest Route**

The `_fetchListProductOrService` API REST controller can be triggered via the following route:

`/v1/_fetchlistproductorservice`


**Rest Request Parameters**


**Filter Parameters**

The `_fetchListProductOrService` api supports 6 optional filter parameters for filtering list results:

**currency** (`String`): The ISO currency code (e.g., 'USD', 'EUR', 'GBP'). Every item must be priced in a defined currency; business default applies for new entries.

- Single (partial match, case-insensitive): `?currency=<value>`
- Multiple: `?currency=<value1>&currency=<value2>`
- Null: `?currency=null`


**name** (`String`): Product or service display name, visible in invoice selection and catalog.

- Single (partial match, case-insensitive): `?name=<value>`
- Multiple: `?name=<value1>&name=<value2>`
- Null: `?name=null`


**price** (`Double`): Unit price/cost for the product or service (decimal).

- Single: `?price=<value>`
- Multiple: `?price=<value1>&price=<value2>`
- Range: `?price=$lt-<value>`, `$lte-`, `$gt-`, `$gte-`, `$btw-<min>-<max>`
- Null: `?price=null`


**sku** (`String`): Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection.

- Single (partial match, case-insensitive): `?sku=<value>`
- Multiple: `?sku=<value1>&sku=<value2>`
- Null: `?sku=null`


**type** (`Enum`): Specifies whether the entry is a product (physical good) or a service (intangible).

- Single: `?type=<value>` (case-insensitive)
- Multiple: `?type=<value1>&type=<value2>`
- Null: `?type=null`


**vatRate** (`Double`): VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%).

- Single: `?vatRate=<value>`
- Multiple: `?vatRate=<value1>&vatRate=<value2>`
- Range: `?vatRate=$lt-<value>`, `$lte-`, `$gt-`, `$gte-`, `$btw-<min>-<max>`
- Null: `?vatRate=null`



**REST Request**
To access the api you can use the **REST** controller with the path **GET  /v1/_fetchlistproductorservice**
```js
  axios({
    method: 'GET',
    url: '/v1/_fetchlistproductorservice',
    data: {
    
    },
    params: {
    
        // Filter parameters (see Filter Parameters section above)
        // currency: '<value>' // Filter by currency
        // name: '<value>' // Filter by name
        // price: '<value>' // Filter by price
        // sku: '<value>' // Filter by sku
        // type: '<value>' // Filter by type
        // vatRate: '<value>' // Filter by vatRate
            }
  });
```   
**REST Response**


```json
{
	"status": "OK",
	"statusCode": "200",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrServices",
	"method": "GET",
	"action": "list",
	"appVersion": "Version",
	"rowCount": "\"Number\"",
	"productOrServices": [
		{
			"id": "ID",
			"currency": "String",
			"description": "Text",
			"name": "String",
			"notes": "Text",
			"price": "Double",
			"sku": "String",
			"type": "Enum",
			"type_idx": "Integer",
			"vatRate": "Double",
			"businessId": "ID",
			"isActive": true,
			"recordVersion": "Integer",
			"createdAt": "Date",
			"updatedAt": "Date",
			"_owner": "ID"
		},
		{},
		{}
	],
	"paging": {
		"pageNumber": "Number",
		"pageRowCount": "NUmber",
		"totalRowCount": "Number",
		"pageCount": "Number"
	},
	"filters": [],
	"uiPermissions": []
}
```


### Authentication Specific Routes



### Common Routes

### Route: currentuser

*Route Definition*: Retrieves the currently authenticated user's session information.

*Route Type*: sessionInfo

*Access Route*: `GET /currentuser`

#### Parameters

This route does **not** require any request parameters.

#### Behavior

- Returns the authenticated session object associated with the current access token.
- If no valid session exists, responds with a 401 Unauthorized.

```js
// Sample GET /currentuser call
axios.get("/currentuser", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````
**Success Response**
Returns the session object, including user-related data and token information.
````
{
  "sessionId": "9cf23fa8-07d4-4e7c-80a6-ec6d6ac96bb9",
  "userId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  "email": "user@example.com",
  "fullname": "John Doe",
  "roleId": "user",
  "tenantId": "abc123",
  "accessToken": "jwt-token-string",
  ...
}
````
**Error Response**
**401 Unauthorized:** No active session found.
````
{
  "status": "ERR",
  "message": "No login found"
}
````

**Notes**
* This route is typically used by frontend or mobile applications to fetch the current session state after login.
* The returned session includes key user identity fields, tenant information (if applicable), and the access token for further authenticated requests.
* Always ensure a valid access token is provided in the request to retrieve the session.

### Route: permissions

`*Route Definition*`: Retrieves all effective permission records assigned to the currently authenticated user.

`*Route Type*`: permissionFetch

*Access Route*: `GET /permissions`

#### Parameters

This route does **not** require any request parameters.

#### Behavior

- Fetches all active permission records (`givenPermissions` entries) associated with the current user session.
- Returns a full array of permission objects.
- Requires a valid session (`access token`) to be available.

```js
// Sample GET /permissions call
axios.get("/permissions", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````
**Success Response**

Returns an array of permission objects.
```json
[
  {
    "id": "perm1",
    "permissionName": "adminPanel.access",
    "roleId": "admin",
    "subjectUserId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
    "subjectUserGroupId": null,
    "objectId": null,
    "canDo": true,
    "tenantCodename": "store123"
  },
  {
    "id": "perm2",
    "permissionName": "orders.manage",
    "roleId": null,
    "subjectUserId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
    "subjectUserGroupId": null,
    "objectId": null,
    "canDo": true,
    "tenantCodename": "store123"
  }
]
````
Each object reflects a single permission grant, aligned with the givenPermissions model:

- `**permissionName**`: The permission the user has.
- `**roleId**`: If the permission was granted through a role.
-` **subjectUserId**`: If directly granted to the user.
- `**subjectUserGroupId**`: If granted through a group.
- `**objectId**`: If tied to a specific object (OBAC).
- `**canDo**`: True or false flag to represent if permission is active or restricted.

**Error Responses**
* **401 Unauthorized**: No active session found.
```json
{
  "status": "ERR",
  "message": "No login found"
}
````
* **500 Internal Server Error**: Unexpected error fetching permissions.

**Notes**
* The /permissions route is available across all backend services generated by Mindbricks, not just the auth service.
* Auth service: Fetches permissions freshly from the live database (givenPermissions table).
* Other services: Typically use a cached or projected view of permissions stored in a common ElasticSearch store, optimized for faster authorization checks.

> **Tip**:
> Applications can cache permission results client-side or server-side, but should occasionally refresh by calling this endpoint, especially after login or permission-changing operations.

### Route: permissions/:permissionName

*Route Definition*: Checks whether the current user has access to a specific permission, and provides a list of scoped object exceptions or inclusions.

*Route Type*: permissionScopeCheck

*Access Route*: `GET /permissions/:permissionName`

#### Parameters

| Parameter         | Type   | Required | Population             |
|------------------|--------|----------|------------------------|
| permissionName   | String | Yes      | `request.params.permissionName` |

#### Behavior

- Evaluates whether the current user **has access** to the given `permissionName`.
- Returns a structured object indicating:
  - Whether the permission is generally granted (`canDo`)
  - Which object IDs are explicitly included or excluded from access (`exceptions`)
- Requires a valid session (`access token`).

```js
// Sample GET /permissions/orders.manage
axios.get("/permissions/orders.manage", {
  headers: {
    "Authorization": "Bearer your-jwt-token"
  }
});
````

**Success Response**

```json
{
  "canDo": true,
  "exceptions": [
    "a1f2e3d4-xxxx-yyyy-zzzz-object1",
    "b2c3d4e5-xxxx-yyyy-zzzz-object2"
  ]
}
````

* If `canDo` is `true`, the user generally has the permission, but not for the objects listed in `exceptions` (i.e., restrictions).
* If `canDo` is `false`, the user does not have the permission by default — but only for the objects in `exceptions`, they do have permission (i.e., selective overrides).
* The exceptions array contains valid **UUID strings**, each corresponding to an object ID (typically from the data model targeted by the permission).

## Copyright
All sources, documents and other digital materials are copyright of .

## About Us
For more information please visit our website: .

.
.


---

<a id="productcatalog-service-event-guide"></a>

## EVENT GUIDE

# EVENT GUIDE
## fintrack-productcatalog-service

Handles CRUD operations for products and services offered by the business. Makes products/services available for invoice itemization and supports future extensions (e.g., category, inventory, VAT config).

## Architectural Design Credit and Contact Information

The architectural design of this microservice is credited to . For inquiries, feedback, or further information regarding the architecture, please direct your communication to:

Email: 

We encourage open communication and welcome any questions or discussions related to the architectural aspects of this microservice.

# Documentation Scope

Welcome to the official documentation for the `ProductCatalog` Service Event descriptions. This guide is dedicated to detailing how to subscribe to and listen for state changes within the `ProductCatalog` Service, offering an exclusive focus on event subscription mechanisms.

**Intended Audience**

This documentation is aimed at developers and integrators looking to monitor `ProductCatalog` Service state changes. It is especially relevant for those wishing to implement or enhance business logic based on interactions with `ProductCatalog` objects.

**Overview**

This section provides detailed instructions on monitoring service events, covering payload structures and demonstrating typical use cases through examples.

# Authentication and Authorization

Access to the `ProductCatalog` service's events is facilitated through the project's Kafka server, which is not accessible to the public. Subscription to a Kafka topic requires being on the same network and possessing valid Kafka user credentials.  This document presupposes that readers have existing access to the Kafka server.

Additionally, the service offers a public subscription option via REST for real-time data management in frontend applications, secured through REST API authentication and authorization mechanisms. To subscribe to service events via the REST API, please consult the Realtime REST API Guide.

# Database Events

Database events are triggered at the database layer, automatically and atomically, in response to any modifications at the data level. These events serve to notify subscribers about the creation, update, or deletion of objects within the database, distinct from any overarching business logic. 

Listening to database events is particularly beneficial for those focused on tracking changes at the database level. A typical use case for subscribing to database events is to replicate the data store of one service within another service's scope, ensuring data consistency and syncronization across services.

For example, while a business operation such as "approve membership" might generate a high-level business event like `membership-approved`, the underlying database changes could involve multiple state updates to different entities. These might be published as separate events, such as `dbevent-member-updated` and `dbevent-user-updated`, reflecting the granular changes at the database level.

Such detailed eventing provides a robust foundation for building responsive, data-driven applications, enabling fine-grained observability and reaction to the dynamics of the data landscape. It also facilitates the architectural pattern of event sourcing, where state changes are captured as a sequence of events, allowing for high-fidelity data replication and history replay for analytical or auditing purposes.

## DbEvent productOrService-created

**Event topic**: `fintrack-productcatalog-service-dbevent-productorservice-created`

This event is triggered upon the creation of a `productOrService` data object in the database. The event payload encompasses the newly created data, encapsulated within the root of the paylod.

**Event payload**: 
```json
{"id":"ID","currency":"String","description":"Text","name":"String","notes":"Text","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  
## DbEvent productOrService-updated

**Event topic**: `fintrack-productcatalog-service-dbevent-productorservice-updated`

Activation of this event follows the update of a `productOrService` data object. The payload contains the updated information under the `productOrService` attribute, along with the original data prior to update, labeled as `old_productOrService` and also you can find the old and new versions of updated-only portion of the data..

**Event payload**: 
```json
{
old_productOrService:{"id":"ID","currency":"String","description":"Text","name":"String","notes":"Text","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
productOrService:{"id":"ID","currency":"String","description":"Text","name":"String","notes":"Text","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"},
oldDataValues,
newDataValues
}
``` 
## DbEvent productOrService-deleted

**Event topic**: `fintrack-productcatalog-service-dbevent-productorservice-deleted`

This event announces the deletion of a `productOrService` data object, covering both hard deletions (permanent removal) and soft deletions (where the `isActive` attribute is set to false). Regardless of the deletion type, the event payload will present the data as it was immediately before deletion, highlighting an `isActive` status of false for soft deletions.

**Event payload**: 
```json
{"id":"ID","currency":"String","description":"Text","name":"String","notes":"Text","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  


# ElasticSearch Index Events

Within the `ProductCatalog` service, most data objects are mirrored in ElasticSearch indices, ensuring these indices remain syncronized with their database counterparts through creation, updates, and deletions. These indices serve dual purposes: they act as a data source for external services and furnish aggregated data tailored to enhance frontend user experiences. Consequently, an ElasticSearch index might encapsulate data in its original form or aggregate additional information from other data objects. 

These aggregations can include both one-to-one and one-to-many relationships not only with database objects within the same service but also across different services. This capability allows developers to access comprehensive, aggregated data efficiently. By subscribing to ElasticSearch index events, developers are notified when an index is updated and can directly obtain the aggregated entity within the event payload, bypassing the need for separate ElasticSearch queries.

It's noteworthy that some services may augment another service's index by appending to the entity’s `extends` object. In such scenarios, an `*-extended` event will contain only the newly added data. Should you require the complete dataset, you would need to retrieve the full ElasticSearch index entity using the provided ID.

This approach to indexing and event handling facilitates a modular, interconnected architecture where services can seamlessly integrate and react to changes, enriching the overall data ecosystem and enabling more dynamic, responsive applications.



## Index Event productorservice-created

**Event topic**: `elastic-index-fintrack_productorservice-created`

**Event payload**:
```json
{"id":"ID","currency":"String","description":"Text","name":"String","notes":"Text","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event productorservice-updated

**Event topic**: `elastic-index-fintrack_productorservice-created`

**Event payload**:
```json
{"id":"ID","currency":"String","description":"Text","name":"String","notes":"Text","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event productorservice-deleted

**Event topic**: `elastic-index-fintrack_productorservice-deleted`

**Event payload**:
```json
{"id":"ID","currency":"String","description":"Text","name":"String","notes":"Text","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}
```  

## Index Event productorservice-extended

**Event topic**: `elastic-index-fintrack_productorservice-extended`

**Event payload**:
```js
{
  id: id,
  extends: {
    [extendName]: "Object",
    [extendName + "_count"]: "Number",
  },
}
``` 

# Route Events

Route events are emitted following the successful execution of a route. While most routes perform CRUD (Create, Read, Update, Delete) operations on data objects, resulting in route events that closely resemble database events, there are distinctions worth noting. A single route execution might trigger multiple CRUD actions and ElasticSearch indexing operations. However, for those primarily concerned with the overarching business logic and its outcomes, listening to the consolidated route event, published once at the conclusion of the route's execution, is more pertinent.

Moreover, routes often deliver aggregated data beyond the primary database object, catering to specific client needs. For instance, creating a data object via a route might not only return the entity's data but also route-specific metrics, such as the executing user's permissions related to the entity. Alternatively, a route might automatically generate default child entities following the creation of a parent object. Consequently, the route event encapsulates a unified dataset encompassing both the parent and its children, in contrast to individual events triggered for each entity created. Therefore, subscribing to route events can offer a richer, more contextually relevant set of information aligned with business logic.

The payload of a route event mirrors the REST response JSON of the route, providing a direct and comprehensive reflection of the data and metadata communicated to the client. This ensures that subscribers to route events receive a payload that encapsulates both the primary data involved and any additional information deemed significant at the business level, facilitating a deeper understanding and integration of the service's functional outcomes.


## Route Event productorservice-created

**Event topic** : `fintrack-productcatalog-service-productorservice-created`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `productOrService` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`productOrService`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"201","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"productOrService","method":"POST","action":"create","appVersion":"Version","rowCount":1,"productOrService":{"id":"ID","currency":"String","description":"Text","name":"String","notes":"Text","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event productorservice-deleted

**Event topic** : `fintrack-productcatalog-service-productorservice-deleted`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `productOrService` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`productOrService`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"productOrService","method":"DELETE","action":"delete","appVersion":"Version","rowCount":1,"productOrService":{"id":"ID","currency":"String","description":"Text","name":"String","notes":"Text","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double","businessId":"ID","isActive":false,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  
## Route Event productorservice-retrived

**Event topic** : `fintrack-productcatalog-service-productorservice-retrived`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `productOrService` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`productOrService`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"productOrService","method":"GET","action":"get","appVersion":"Version","rowCount":1,"productOrService":{"isActive":true}}
```  
## Route Event productorservices-listed

**Event topic** : `fintrack-productcatalog-service-productorservices-listed`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `productOrServices` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`productOrServices`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"productOrServices","method":"GET","action":"list","appVersion":"Version","rowCount":"\"Number\"","productOrServices":[{"isActive":true},{},{}],"paging":{"pageNumber":"Number","pageRowCount":"NUmber","totalRowCount":"Number","pageCount":"Number"},"filters":[],"uiPermissions":[]}
```  
## Route Event productorservice-updated

**Event topic** : `fintrack-productcatalog-service-productorservice-updated`

**Event payload**:

The event payload, mirroring the REST API response, is structured as an encapsulated JSON. It includes metadata related to the API as well as the `productOrService` data object itself. 

The following JSON included in the payload illustrates the fullest representation of the **`productOrService`** object. Note, however, that certain properties might be excluded in accordance with the object's inherent logic.

```json
{"status":"OK","statusCode":"200","elapsedMs":126,"ssoTime":120,"source":"db","cacheKey":"hexCode","userId":"ID","sessionId":"ID","requestId":"ID","dataName":"productOrService","method":"PATCH","action":"update","appVersion":"Version","rowCount":1,"productOrService":{"id":"ID","currency":"String","description":"Text","name":"String","notes":"Text","price":"Double","sku":"String","type":"Enum","type_idx":"Integer","vatRate":"Double","businessId":"ID","isActive":true,"recordVersion":"Integer","createdAt":"Date","updatedAt":"Date","_owner":"ID"}}
```  




# Copyright
All sources, documents and other digital materials are copyright of .

# About Us
For more information please visit our website: .

.
.


---

## Data Objects

<a id="productcatalog-service-productorservice-design"></a>

### Service Design Specification - Object Design for productOrService

# Service Design Specification - Object Design for productOrService
**fintrack-productcatalog-service** documentation

## Document Overview
This document outlines the object design for the `productOrService` model in our application. It includes details about the model's attributes, relationships, and any specific validation or business logic that applies.

## productOrService Data Object

### Object Overview
**Description:** Represents a business-specific product or service available for use in invoices. Each entry is owned/scoped exclusively by one business (tenant) and can be searched, filtered, or extended as needed.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** accessPrivate — If enabled, anonymous users may access this object’s data depending on API-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.




### Composite Indexes

- **businessSkuUnique**: [businessId, sku] 
This composite index is defined to optimize query performance for complex queries involving multiple fields.

The index also defines a conflict resolution strategy for duplicate key violations.

When a new record would violate this composite index, the following action will be taken:

**On Duplicate**: `throwError`

An error will be thrown, preventing the insertion of conflicting data.






### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `currency` | String | Yes | The ISO currency code (e.g., &#39;USD&#39;, &#39;EUR&#39;, &#39;GBP&#39;). Every item must be priced in a defined currency; business default applies for new entries. |
| `description` | Text | No | Detailed or extended description for internal use and clarity in catalog and invoice dialogs. |
| `name` | String | Yes | Product or service display name, visible in invoice selection and catalog. |
| `notes` | Text | No | Internal notes and comments for this product/service, not exposed to external partners or customers. |
| `price` | Double | Yes | Unit price/cost for the product or service (decimal). |
| `sku` | String | Yes | Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection. |
| `type` | Enum | Yes | Specifies whether the entry is a product (physical good) or a service (intangible). |
| `vatRate` | Double | Yes | VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%). |
| `businessId` | ID | Yes | An ID value to represent the tenant id of the business |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any business API to set default values dynamically.

- **currency**: 'default'
- **name**: 'default'
- **price**: 0.0
- **sku**: 'default'
- **type**: "product"
- **vatRate**: 0
- **businessId**: 00000000-0000-0000-0000-000000000000


### Constant Properties

`businessId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`currency` `description` `name` `notes` `price` `sku` `type` `vatRate`

An update crud API created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update API's body parameters and can be updated by the user if any value is provided in the request body.

 

### Enum Properties
Enum properties are defined with a set of allowed values, ensuring that only valid options can be assigned to them. 
The enum options value will be stored as strings in the database, 
but when a data object is created an addtional property with the same name plus an idx suffix will be created, which will hold the index of the selected enum option.
You can use the index property to sort by the enum value or when your enum options represent a sequence of values.

- **type**: [product, service]

 

 

### Elastic Search Indexing

`currency` `description` `name` `price` `sku` `type` `vatRate` `businessId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`name` `sku` `type` `businessId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.





### Secondary Key Properties

`businessId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.






### Filter Properties

`currency` `name` `price` `sku` `type` `vatRate` `businessId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as API parameters in the listing API's that have "Auto Params" enabled.

- **currency**: String  has a filter named `currency`

- **name**: String  has a filter named `name`

- **price**: Double  has a filter named `price`

- **sku**: String  has a filter named `sku`

- **type**: Enum  has a filter named `type`

- **vatRate**: Double  has a filter named `vatRate`

- **businessId**: ID  has a filter named `businessId`



  

---

## Business APIs

<a id="productcatalog-service-business-api-createproductorservice-api-design"></a>

### Business API Design Specification - `Create Productorservice`


# Business API Design Specification - `Create Productorservice`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `createProductOrService` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `createProductOrService` Business API is designed to handle a `create` operation on the `ProductOrService` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Create a new product or service entry scoped to the current business. Only Owner/Accountant may create.

## API Frontend Description By The Backend Architect

- Only Owners and Accountants can add new products/services via this API.\n- Input must specify all required product fields: type, name, sku (unique in business), price, currency, and VAT rate.\n- SKU is checked for uniqueness within business context before creation.\n- On success, product/service is added and available for invoice selection; frontends may refresh catalog views automatically.\n- If SKU conflict, API returns error highlighting duplication.

## API Options 

* **Auto Params** : `true`
Determines whether input parameters should be auto-generated from the schema of the associated data object. Set to `false` if you want to define all input parameters manually.

* **Raise Api Event** : `true`
Indicates whether the Business API should emit an API-level event after successful execution. This is typically used for audit trails, analytics, or external integrations.
The event will be emitted to the `productorservice-created` Kafka Topic Note that the DB-Level events for `create`, `update` and `delete` operations will always be raised for internal reasons.

* **Active Check** : ``
Controls how the system checks if a record is active (not soft-deleted or inactive). Uses the `ApiCheckOption` to determine whether this is checked during the query or after fetching the instance.

* **Read From Entity Cache** : `false`
If enabled, the API will attempt to read the target object from the Redis entity cache before querying the database. This can improve performance for frequently accessed records.

## API Controllers
A Mindbricks Business API can be accessed through multiple interfaces, including REST, gRPC, WebSocket, Kafka, or Cron. The controllers listed below map the business workflow to a specific interface, enabling consistent interaction regardless of the communication channel.

### REST Controller

The `createProductOrService` Business API includes a REST controller that can be triggered via the following route:

`/v1/productorservices`

By sending a request to this route using the service API address, you can execute this Business API. Parameters can be provided in multiple HTTP locations, including the URL path, URL query, request body, and request headers. Detailed information about these parameters is provided in the **Parameters** section.




### MCP Tool

REST controllers also expose the Business API as a tool in the MCP, making it accessible to AI agents. This `createProductOrService` Business API will be registered as a tool on the MCP server within the service binding.

## API Parameters

The `createProductOrService` Business API has 9 parameters that must be sent from the controller. Note that all parameters, except session and Redis parameters, should be provided by the client.

Business API parameters can be:

* **Auto-generated by Mindbricks** — inferred from the CRUD type and the property definitions of the main data object when the `autoParameters` option is enabled.
* **Custom parameters added by the architect** — these can supplement or override the auto-generated parameters.

### Regular Parameters

| Name                                            | Type                  | Required                               | Default                                                              | Location                    | Data Path                      |  
| ----------------------------------------------- | --------------------- | -------------------------------------- | -------------------------------------------------------------------- | --------------------------- | ------------------------------ |
|  |                       |                                        |                                                                      |                             |                                | 
| `productOrServiceId`                             | `ID`   | `No` | `-` | `body` | `productOrServiceId` |
| **Description:**                                | This id paremeter is used to create the data object with a given specific id. Leave null for automatic id. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `currency`                             | `String`   | `Yes` | `-` | `body` | `currency` |
| **Description:**                                | The ISO currency code (e.g., 'USD', 'EUR', 'GBP'). Every item must be priced in a defined currency; business default applies for new entries. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `description`                             | `Text`   | `No` | `-` | `body` | `description` |
| **Description:**                                | Detailed or extended description for internal use and clarity in catalog and invoice dialogs. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `name`                             | `String`   | `Yes` | `-` | `body` | `name` |
| **Description:**                                | Product or service display name, visible in invoice selection and catalog. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `notes`                             | `Text`   | `No` | `-` | `body` | `notes` |
| **Description:**                                | Internal notes and comments for this product/service, not exposed to external partners or customers. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `price`                             | `Double`   | `Yes` | `-` | `body` | `price` |
| **Description:**                                | Unit price/cost for the product or service (decimal). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `sku`                             | `String`   | `Yes` | `-` | `body` | `sku` |
| **Description:**                                | Stock Keeping Unit code or internal identifier; must be unique within a business for easy lookup/selection. |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `type`                             | `Enum`   | `Yes` | `-` | `body` | `type` |
| **Description:**                                | Specifies whether the entry is a product (physical good) or a service (intangible). |                              |                                                                      |                             |                                | 
|  |                       |                                        |                                                                      |                             |                                | 
| `vatRate`                             | `Double`   | `Yes` | `-` | `body` | `vatRate` |
| **Description:**                                | VAT (%) applicable to this product/service. Stored as a percentage (e.g., 18 for 18%). |                              |                                                                      |                             |                                | 
|                                       |                       |                                        |                                                                      |                             |                                |

  

### Parameter Transformations

Some parameters are post-processed using **transform scripts** after being read from the request but before validation or workflow execution. Only parameters with a `transform` script are listed below.

*No parameters are transformed in this API.*

## AUTH Configuration

The **authentication and authorization configuration** defines the core access rules for the `createProductOrService` Business API. These checks are applied **after parameter validation** and before executing the main business logic.

While these settings cover the most common scenarios, more **fine-grained or conditional access control**—such as permissions based on object context, nested memberships, or custom workflows—should be implemented using explicit actions like `PermissionCheckAction`, `MembershipCheckAction`, or `ObjectPermissionCheckAction`.


### Login Requirement


This API **requires login** (`loginRequired = true`). Requests from non-logged-in users will return a **401 Unauthorized** error.
Login is necessary **but not sufficient**, as additional role, permission, or other authorization checks may still apply.

---


### Ownership Checks



---

### Role and Permission Settings


- **Absolute roles** (bypass all auth checks):  
  Users with any of the following roles will bypass all authentication and authorization checks, including ownership, membership, and standard role/permission checks:  
  `[owner, tenantOwner, superAdmin]`



- **Check roles** (must pass basic role checks):  
  Users must have at least one of the following roles to execute this API:  
  `[accountant]`




---





## Data Clause
Defines custom field-value assignments used to modify or augment the default payload for `create` and `update` operations. These settings override values derived from the session or parameters if explicitly provided.",
Note that a default data clause is always prepared by Mindbricks using data property settings, however any property in the data clause can be override by Data Clause Settings. 



**Custom Data Clause Override**
*No custom data clause override configured*

**Actual Data Clause**

The business api will use the following data clause. Note that any calculated value will be added to the data clause in the api manager.

```js
{
  id: this.productOrServiceId,
  businessId: this.businessId,
  currency: this.currency,
  description: this.description,
  name: this.name,
  notes: this.notes,
  price: this.price,
  sku: this.sku,
  type: this.type,
  vatRate: this.vatRate,
  isActive: true,
  _archivedAt: null,
}
```







   
## Business Logic Workflow 


### [1] Step : startBusinessApi

Manager initializes context, populates session and request objects, prepares internal structures for parameter handling and workflow execution.


You can use the following settings to change some behavior of this step.
`apiOptions`, `restSettings`, `grpcSettings`, `kafkaSettings`, `socketSettings`, `cronSettings`
---




### [2] Step : readParameters

Manager reads input parameters, normalizes missing values, applies default type casting, and stores them in the API context.


You can use the following settings to change some behavior of this step.
`customParameters`, `redisParameters`
---




### [3] Step : transposeParameters

Manager transforms parameters, computes derived values, flattens or remaps arrays/objects, and adjusts formats for downstream processing.


---




### [4] Step : checkParameters

Manager executes built-in validations: required field checks, type enforcement, and basic business rules. Prevents operation if validation fails.


---




### [5] Step : checkBasicAuth

Manager performs authentication and authorization checks: verifies session, user roles, permissions, and tenant restrictions.


You can use the following settings to change some behavior of this step.
`authOptions`
---




### [6] Step : buildDataClause

Manager constructs the final data object for creation, fills auto-generated fields (IDs, timestamps, owner fields), and ensures schema consistency.


You can use the following settings to change some behavior of this step.
`dataClause`
---




### [7] Step : mainCreateOperation

Manager executes the database insert operation, updates indexes/caches, and triggers internal post-processing like linked default records.


---




### [8] Step : buildOutput

Manager shapes the response: masks sensitive fields, resolves linked references, and formats output according to API contract.


---




### [9] Step : sendResponse

Manager sends the response to the client and finalizes internal tasks like flushing logs or updating session state.


---




### [10] Step : raiseApiEvent

Manager triggers API-level events (Kafka, WebSocket, async workflows) as the final internal step.


---






## Rest Usage


### Rest Client Parameters
Client parameters are the api parameters that are visible to client and will be populated by the client.
Note that some api parameters are not visible to client because they are populated by internal system, session, calculation or joint sources.

The `createProductOrService` api has got 8 regular client parameters  

| Parameter              | Type                   | Required | Population                   |
| ---------------------- | ---------------------- | -------- | ---------------------------- |
| currency  | String  | true | request.body?.["currency"] |
| description  | Text  | false | request.body?.["description"] |
| name  | String  | true | request.body?.["name"] |
| notes  | Text  | false | request.body?.["notes"] |
| price  | Double  | true | request.body?.["price"] |
| sku  | String  | true | request.body?.["sku"] |
| type  | Enum  | true | request.body?.["type"] |
| vatRate  | Double  | true | request.body?.["vatRate"] |

### REST Request
To access the api you can use the **REST** controller with the path **POST  /v1/productorservices**
```js
  axios({
    method: 'POST',
    url: '/v1/productorservices',
    data: {
            currency:"String",  
            description:"Text",  
            name:"String",  
            notes:"Text",  
            price:"Double",  
            sku:"String",  
            type:"Enum",  
            vatRate:"Double",  
    
    },
    params: {
    
        }
  });
```   
### REST Response
The API response is encapsulated within a JSON envelope. Successful operations return an HTTP status code of 200 for get, list, update, or delete requests, and 201 for create requests. Each successful response includes a `"status": "OK"` property. For error handling, refer to the "Error Response" section.

Following JSON represents the most comprehensive form of the **`productOrService`** object in the respones. However, some properties may be omitted based on the object's internal logic.


```json
{
	"status": "OK",
	"statusCode": "201",
	"elapsedMs": 126,
	"ssoTime": 120,
	"source": "db",
	"cacheKey": "hexCode",
	"userId": "ID",
	"sessionId": "ID",
	"requestId": "ID",
	"dataName": "productOrService",
	"method": "POST",
	"action": "create",
	"appVersion": "Version",
	"rowCount": 1,
	"productOrService": {
		"id": "ID",
		"currency": "String",
		"description": "Text",
		"name": "String",
		"notes": "Text",
		"price": "Double",
		"sku": "String",
		"type": "Enum",
		"type_idx": "Integer",
		"vatRate": "Double",
		"businessId": "ID",
		"isActive": true,
		"recordVersion": "Integer",
		"createdAt": "Date",
		"updatedAt": "Date",
		"_owner": "ID"
	}
}
```  

---

<a id="productcatalog-service-business-api-deleteproductorservice-api-design"></a>

### Business API Design Specification - `Delete Productorservice`


# Business API Design Specification - `Delete Productorservice`

A Business API is a set of logical actions centered around a main data object. These actions can range from simple CRUD operations to complex workflows that implement intricate business logic.

While the term “API” traditionally refers to an interface that allows software systems to interact, in Mindbricks a Business API represents a broader concept. It encapsulates a business workflow around a data object, going beyond basic CRUD operations to include rich, internally coordinated actions that can be fully designed and customized.

This document provides an in-depth explanation of the architectural design of the `deleteProductOrService` Business API. It is intended to guide backend architects and developers in maintaining the current design. Additionally, frontend developers and frontend AI agents can use this document to understand how to properly consume this API on the client side.

## Main Data Object and CRUD Operation
The `deleteProductOrService` Business API is designed to handle a `delete` operation on the `ProductOrService` data object. This operation is performed under the specified conditions and may include additional, coordinated actions as part of the workflow.

## API Description

Soft-delete (deactivate) a product or service. Only Owner/Accountant can delete within their business. Deleted (inactive) products are not offered for new invoices but remain for history/reporting.

## API Frontend Description By The Backend Architect

- Soft delete: product/service is marked inactive ('archived'), not physically removed.\n- Only Owner/Accountant can delete.\n- Deleted items no longer appear in normal selection for invoices, but can 